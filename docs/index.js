/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../Formality-JavaScript/node_modules/decode-uri-component/index.js":
/*!**************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/decode-uri-component/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/decode-uri-component/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/define-properties/index.js":
/*!***********************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/define-properties/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar keys = __webpack_require__(/*! object-keys */ \"../Formality-JavaScript/node_modules/object-keys/index.js\");\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\n\t\t\treturn false;\n\t\t}\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/define-properties/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-abstract/GetIntrinsic.js":
/*!************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-abstract/GetIntrinsic.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* globals\n\tSet,\n\tMap,\n\tWeakSet,\n\tWeakMap,\n\n\tPromise,\n\n\tSymbol,\n\tProxy,\n\n\tAtomics,\n\tSharedArrayBuffer,\n\n\tArrayBuffer,\n\tDataView,\n\tUint8Array,\n\tFloat32Array,\n\tFloat64Array,\n\tInt8Array,\n\tInt16Array,\n\tInt32Array,\n\tUint8ClampedArray,\n\tUint16Array,\n\tUint32Array,\n*/\n\nvar undefined; // eslint-disable-line no-shadow-restricted-names\n\nvar ThrowTypeError = Object.getOwnPropertyDescriptor\n\t? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())\n\t: function () { throw new TypeError(); };\n\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar generator; // = function * () {};\nvar generatorFunction = generator ? getProto(generator) : undefined;\nvar asyncFn; // async function() {};\nvar asyncFunction = asyncFn ? asyncFn.constructor : undefined;\nvar asyncGen; // async function * () {};\nvar asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;\nvar asyncGenIterator = asyncGen ? asyncGen() : undefined;\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'$ %Array%': Array,\n\t'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,\n\t'$ %ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'$ %ArrayPrototype%': Array.prototype,\n\t'$ %ArrayProto_entries%': Array.prototype.entries,\n\t'$ %ArrayProto_forEach%': Array.prototype.forEach,\n\t'$ %ArrayProto_keys%': Array.prototype.keys,\n\t'$ %ArrayProto_values%': Array.prototype.values,\n\t'$ %AsyncFromSyncIteratorPrototype%': undefined,\n\t'$ %AsyncFunction%': asyncFunction,\n\t'$ %AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,\n\t'$ %AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,\n\t'$ %AsyncGeneratorFunction%': asyncGenFunction,\n\t'$ %AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,\n\t'$ %AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,\n\t'$ %Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'$ %Boolean%': Boolean,\n\t'$ %BooleanPrototype%': Boolean.prototype,\n\t'$ %DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,\n\t'$ %Date%': Date,\n\t'$ %DatePrototype%': Date.prototype,\n\t'$ %decodeURI%': decodeURI,\n\t'$ %decodeURIComponent%': decodeURIComponent,\n\t'$ %encodeURI%': encodeURI,\n\t'$ %encodeURIComponent%': encodeURIComponent,\n\t'$ %Error%': Error,\n\t'$ %ErrorPrototype%': Error.prototype,\n\t'$ %eval%': eval, // eslint-disable-line no-eval\n\t'$ %EvalError%': EvalError,\n\t'$ %EvalErrorPrototype%': EvalError.prototype,\n\t'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,\n\t'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,\n\t'$ %Function%': Function,\n\t'$ %FunctionPrototype%': Function.prototype,\n\t'$ %Generator%': generator ? getProto(generator()) : undefined,\n\t'$ %GeneratorFunction%': generatorFunction,\n\t'$ %GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,\n\t'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,\n\t'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,\n\t'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,\n\t'$ %isFinite%': isFinite,\n\t'$ %isNaN%': isNaN,\n\t'$ %IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'$ %JSON%': JSON,\n\t'$ %JSONParse%': JSON.parse,\n\t'$ %Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'$ %MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,\n\t'$ %Math%': Math,\n\t'$ %Number%': Number,\n\t'$ %NumberPrototype%': Number.prototype,\n\t'$ %Object%': Object,\n\t'$ %ObjectPrototype%': Object.prototype,\n\t'$ %ObjProto_toString%': Object.prototype.toString,\n\t'$ %ObjProto_valueOf%': Object.prototype.valueOf,\n\t'$ %parseFloat%': parseFloat,\n\t'$ %parseInt%': parseInt,\n\t'$ %Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,\n\t'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,\n\t'$ %Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,\n\t'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,\n\t'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,\n\t'$ %Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'$ %RangeError%': RangeError,\n\t'$ %RangeErrorPrototype%': RangeError.prototype,\n\t'$ %ReferenceError%': ReferenceError,\n\t'$ %ReferenceErrorPrototype%': ReferenceError.prototype,\n\t'$ %Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'$ %RegExp%': RegExp,\n\t'$ %RegExpPrototype%': RegExp.prototype,\n\t'$ %Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'$ %SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,\n\t'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,\n\t'$ %String%': String,\n\t'$ %StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'$ %StringPrototype%': String.prototype,\n\t'$ %Symbol%': hasSymbols ? Symbol : undefined,\n\t'$ %SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,\n\t'$ %SyntaxError%': SyntaxError,\n\t'$ %SyntaxErrorPrototype%': SyntaxError.prototype,\n\t'$ %ThrowTypeError%': ThrowTypeError,\n\t'$ %TypedArray%': TypedArray,\n\t'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,\n\t'$ %TypeError%': TypeError,\n\t'$ %TypeErrorPrototype%': TypeError.prototype,\n\t'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,\n\t'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,\n\t'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,\n\t'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,\n\t'$ %URIError%': URIError,\n\t'$ %URIErrorPrototype%': URIError.prototype,\n\t'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,\n\t'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\t'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar key = '$ ' + name;\n\tif (!(key in INTRINSICS)) {\n\t\tthrow new SyntaxError('intrinsic ' + name + ' does not exist!');\n\t}\n\n\t// istanbul ignore if // hopefully this is impossible to test :-)\n\tif (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {\n\t\tthrow new TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t}\n\treturn INTRINSICS[key];\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-abstract/GetIntrinsic.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-abstract/es5.js":
/*!***************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-abstract/es5.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! ./GetIntrinsic */ \"../Formality-JavaScript/node_modules/es-abstract/GetIntrinsic.js\");\n\nvar $Object = GetIntrinsic('%Object%');\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $String = GetIntrinsic('%String%');\n\nvar assertRecord = __webpack_require__(/*! ./helpers/assertRecord */ \"../Formality-JavaScript/node_modules/es-abstract/helpers/assertRecord.js\");\nvar $isNaN = __webpack_require__(/*! ./helpers/isNaN */ \"../Formality-JavaScript/node_modules/es-abstract/helpers/isNaN.js\");\nvar $isFinite = __webpack_require__(/*! ./helpers/isFinite */ \"../Formality-JavaScript/node_modules/es-abstract/helpers/isFinite.js\");\n\nvar sign = __webpack_require__(/*! ./helpers/sign */ \"../Formality-JavaScript/node_modules/es-abstract/helpers/sign.js\");\nvar mod = __webpack_require__(/*! ./helpers/mod */ \"../Formality-JavaScript/node_modules/es-abstract/helpers/mod.js\");\n\nvar IsCallable = __webpack_require__(/*! is-callable */ \"../Formality-JavaScript/node_modules/is-callable/index.js\");\nvar toPrimitive = __webpack_require__(/*! es-to-primitive/es5 */ \"../Formality-JavaScript/node_modules/es-to-primitive/es5.js\");\n\nvar has = __webpack_require__(/*! has */ \"../Formality-JavaScript/node_modules/has/src/index.js\");\n\n// https://es5.github.io/#x9\nvar ES5 = {\n\tToPrimitive: toPrimitive,\n\n\tToBoolean: function ToBoolean(value) {\n\t\treturn !!value;\n\t},\n\tToNumber: function ToNumber(value) {\n\t\treturn +value; // eslint-disable-line no-implicit-coercion\n\t},\n\tToInteger: function ToInteger(value) {\n\t\tvar number = this.ToNumber(value);\n\t\tif ($isNaN(number)) { return 0; }\n\t\tif (number === 0 || !$isFinite(number)) { return number; }\n\t\treturn sign(number) * Math.floor(Math.abs(number));\n\t},\n\tToInt32: function ToInt32(x) {\n\t\treturn this.ToNumber(x) >> 0;\n\t},\n\tToUint32: function ToUint32(x) {\n\t\treturn this.ToNumber(x) >>> 0;\n\t},\n\tToUint16: function ToUint16(value) {\n\t\tvar number = this.ToNumber(value);\n\t\tif ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }\n\t\tvar posInt = sign(number) * Math.floor(Math.abs(number));\n\t\treturn mod(posInt, 0x10000);\n\t},\n\tToString: function ToString(value) {\n\t\treturn $String(value);\n\t},\n\tToObject: function ToObject(value) {\n\t\tthis.CheckObjectCoercible(value);\n\t\treturn $Object(value);\n\t},\n\tCheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {\n\t\t/* jshint eqnull:true */\n\t\tif (value == null) {\n\t\t\tthrow new $TypeError(optMessage || 'Cannot call method on ' + value);\n\t\t}\n\t\treturn value;\n\t},\n\tIsCallable: IsCallable,\n\tSameValue: function SameValue(x, y) {\n\t\tif (x === y) { // 0 === -0, but they are not identical.\n\t\t\tif (x === 0) { return 1 / x === 1 / y; }\n\t\t\treturn true;\n\t\t}\n\t\treturn $isNaN(x) && $isNaN(y);\n\t},\n\n\t// https://www.ecma-international.org/ecma-262/5.1/#sec-8\n\tType: function Type(x) {\n\t\tif (x === null) {\n\t\t\treturn 'Null';\n\t\t}\n\t\tif (typeof x === 'undefined') {\n\t\t\treturn 'Undefined';\n\t\t}\n\t\tif (typeof x === 'function' || typeof x === 'object') {\n\t\t\treturn 'Object';\n\t\t}\n\t\tif (typeof x === 'number') {\n\t\t\treturn 'Number';\n\t\t}\n\t\tif (typeof x === 'boolean') {\n\t\t\treturn 'Boolean';\n\t\t}\n\t\tif (typeof x === 'string') {\n\t\t\treturn 'String';\n\t\t}\n\t},\n\n\t// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n\tIsPropertyDescriptor: function IsPropertyDescriptor(Desc) {\n\t\tif (this.Type(Desc) !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\tvar allowed = {\n\t\t\t'[[Configurable]]': true,\n\t\t\t'[[Enumerable]]': true,\n\t\t\t'[[Get]]': true,\n\t\t\t'[[Set]]': true,\n\t\t\t'[[Value]]': true,\n\t\t\t'[[Writable]]': true\n\t\t};\n\n\t\tfor (var key in Desc) { // eslint-disable-line\n\t\t\tif (has(Desc, key) && !allowed[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar isData = has(Desc, '[[Value]]');\n\t\tvar IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n\t\tif (isData && IsAccessor) {\n\t\t\tthrow new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n\t\t}\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1\n\tIsAccessorDescriptor: function IsAccessorDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2\n\tIsDataDescriptor: function IsDataDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3\n\tIsGenericDescriptor: function IsGenericDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4\n\tFromPropertyDescriptor: function FromPropertyDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn Desc;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (this.IsDataDescriptor(Desc)) {\n\t\t\treturn {\n\t\t\t\tvalue: Desc['[[Value]]'],\n\t\t\t\twritable: !!Desc['[[Writable]]'],\n\t\t\t\tenumerable: !!Desc['[[Enumerable]]'],\n\t\t\t\tconfigurable: !!Desc['[[Configurable]]']\n\t\t\t};\n\t\t} else if (this.IsAccessorDescriptor(Desc)) {\n\t\t\treturn {\n\t\t\t\tget: Desc['[[Get]]'],\n\t\t\t\tset: Desc['[[Set]]'],\n\t\t\t\tenumerable: !!Desc['[[Enumerable]]'],\n\t\t\t\tconfigurable: !!Desc['[[Configurable]]']\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new $TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');\n\t\t}\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5\n\tToPropertyDescriptor: function ToPropertyDescriptor(Obj) {\n\t\tif (this.Type(Obj) !== 'Object') {\n\t\t\tthrow new $TypeError('ToPropertyDescriptor requires an object');\n\t\t}\n\n\t\tvar desc = {};\n\t\tif (has(Obj, 'enumerable')) {\n\t\t\tdesc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);\n\t\t}\n\t\tif (has(Obj, 'configurable')) {\n\t\t\tdesc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);\n\t\t}\n\t\tif (has(Obj, 'value')) {\n\t\t\tdesc['[[Value]]'] = Obj.value;\n\t\t}\n\t\tif (has(Obj, 'writable')) {\n\t\t\tdesc['[[Writable]]'] = this.ToBoolean(Obj.writable);\n\t\t}\n\t\tif (has(Obj, 'get')) {\n\t\t\tvar getter = Obj.get;\n\t\t\tif (typeof getter !== 'undefined' && !this.IsCallable(getter)) {\n\t\t\t\tthrow new TypeError('getter must be a function');\n\t\t\t}\n\t\t\tdesc['[[Get]]'] = getter;\n\t\t}\n\t\tif (has(Obj, 'set')) {\n\t\t\tvar setter = Obj.set;\n\t\t\tif (typeof setter !== 'undefined' && !this.IsCallable(setter)) {\n\t\t\t\tthrow new $TypeError('setter must be a function');\n\t\t\t}\n\t\t\tdesc['[[Set]]'] = setter;\n\t\t}\n\n\t\tif ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {\n\t\t\tthrow new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');\n\t\t}\n\t\treturn desc;\n\t}\n};\n\nmodule.exports = ES5;\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-abstract/es5.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-abstract/helpers/assertRecord.js":
/*!********************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-abstract/helpers/assertRecord.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! ../GetIntrinsic */ \"../Formality-JavaScript/node_modules/es-abstract/GetIntrinsic.js\");\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\n\nvar has = __webpack_require__(/*! has */ \"../Formality-JavaScript/node_modules/has/src/index.js\");\n\nvar predicates = {\n  // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n  'Property Descriptor': function isPropertyDescriptor(ES, Desc) {\n    if (ES.Type(Desc) !== 'Object') {\n      return false;\n    }\n    var allowed = {\n      '[[Configurable]]': true,\n      '[[Enumerable]]': true,\n      '[[Get]]': true,\n      '[[Set]]': true,\n      '[[Value]]': true,\n      '[[Writable]]': true\n    };\n\n    for (var key in Desc) { // eslint-disable-line\n      if (has(Desc, key) && !allowed[key]) {\n        return false;\n      }\n    }\n\n    var isData = has(Desc, '[[Value]]');\n    var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n    if (isData && IsAccessor) {\n      throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n    }\n    return true;\n  }\n};\n\nmodule.exports = function assertRecord(ES, recordType, argumentName, value) {\n  var predicate = predicates[recordType];\n  if (typeof predicate !== 'function') {\n    throw new $SyntaxError('unknown record type: ' + recordType);\n  }\n  if (!predicate(ES, value)) {\n    throw new $TypeError(argumentName + ' must be a ' + recordType);\n  }\n  console.log(predicate(ES, value), value);\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-abstract/helpers/assertRecord.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-abstract/helpers/isFinite.js":
/*!****************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-abstract/helpers/isFinite.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var $isNaN = Number.isNaN || function (a) { return a !== a; };\n\nmodule.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-abstract/helpers/isFinite.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-abstract/helpers/isNaN.js":
/*!*************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-abstract/helpers/isNaN.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-abstract/helpers/isNaN.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-abstract/helpers/mod.js":
/*!***********************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-abstract/helpers/mod.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function mod(number, modulo) {\n\tvar remain = number % modulo;\n\treturn Math.floor(remain >= 0 ? remain : remain + modulo);\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-abstract/helpers/mod.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-abstract/helpers/sign.js":
/*!************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-abstract/helpers/sign.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function sign(number) {\n\treturn number >= 0 ? 1 : -1;\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-abstract/helpers/sign.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-to-primitive/es5.js":
/*!*******************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-to-primitive/es5.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nvar isPrimitive = __webpack_require__(/*! ./helpers/isPrimitive */ \"../Formality-JavaScript/node_modules/es-to-primitive/helpers/isPrimitive.js\");\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"../Formality-JavaScript/node_modules/is-callable/index.js\");\n\n// http://ecma-international.org/ecma-262/5.1/#sec-8.12.8\nvar ES5internalSlots = {\n\t'[[DefaultValue]]': function (O) {\n\t\tvar actualHint;\n\t\tif (arguments.length > 1) {\n\t\t\tactualHint = arguments[1];\n\t\t} else {\n\t\t\tactualHint = toStr.call(O) === '[object Date]' ? String : Number;\n\t\t}\n\n\t\tif (actualHint === String || actualHint === Number) {\n\t\t\tvar methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];\n\t\t\tvar value, i;\n\t\t\tfor (i = 0; i < methods.length; ++i) {\n\t\t\t\tif (isCallable(O[methods[i]])) {\n\t\t\t\t\tvalue = O[methods[i]]();\n\t\t\t\t\tif (isPrimitive(value)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new TypeError('No default value');\n\t\t}\n\t\tthrow new TypeError('invalid [[DefaultValue]] hint supplied');\n\t}\n};\n\n// http://ecma-international.org/ecma-262/5.1/#sec-9.1\nmodule.exports = function ToPrimitive(input) {\n\tif (isPrimitive(input)) {\n\t\treturn input;\n\t}\n\tif (arguments.length > 1) {\n\t\treturn ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);\n\t}\n\treturn ES5internalSlots['[[DefaultValue]]'](input);\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-to-primitive/es5.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/es-to-primitive/helpers/isPrimitive.js":
/*!***********************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/es-to-primitive/helpers/isPrimitive.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isPrimitive(value) {\n\treturn value === null || (typeof value !== 'function' && typeof value !== 'object');\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/es-to-primitive/helpers/isPrimitive.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/for-each/index.js":
/*!**************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/for-each/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"../Formality-JavaScript/node_modules/is-callable/index.js\");\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/for-each/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/function-bind/implementation.js":
/*!****************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/function-bind/implementation.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/function-bind/index.js":
/*!*******************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/function-bind/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"../Formality-JavaScript/node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/function-bind/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/global/window.js":
/*!*************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/global/window.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../Provit/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/global/window.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/has/src/index.js":
/*!*************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/has/src/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"../Formality-JavaScript/node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/has/src/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/is-callable/index.js":
/*!*****************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/is-callable/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar fnToStr = Function.prototype.toString;\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isCallable(value) {\n\tif (!value) { return false; }\n\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\tif (typeof value === 'function' && !value.prototype) { return true; }\n\tif (hasToStringTag) { return tryFunctionObject(value); }\n\tif (isES6ClassFn(value)) { return false; }\n\tvar strClass = toStr.call(value);\n\treturn strClass === fnClass || strClass === genClass;\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/is-callable/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/is-function/index.js":
/*!*****************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/is-function/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/is-function/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/object-assign/index.js":
/*!*******************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/object-assign/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/object-assign/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/object-keys/implementation.js":
/*!**************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/object-keys/implementation.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = __webpack_require__(/*! ./isArguments */ \"../Formality-JavaScript/node_modules/object-keys/isArguments.js\"); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/object-keys/implementation.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/object-keys/index.js":
/*!*****************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/object-keys/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar slice = Array.prototype.slice;\nvar isArgs = __webpack_require__(/*! ./isArguments */ \"../Formality-JavaScript/node_modules/object-keys/isArguments.js\");\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ \"../Formality-JavaScript/node_modules/object-keys/implementation.js\");\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/object-keys/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/object-keys/isArguments.js":
/*!***********************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/object-keys/isArguments.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/object-keys/isArguments.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/parse-headers/parse-headers.js":
/*!***************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/parse-headers/parse-headers.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var trim = __webpack_require__(/*! string.prototype.trim */ \"../Formality-JavaScript/node_modules/string.prototype.trim/index.js\")\n  , forEach = __webpack_require__(/*! for-each */ \"../Formality-JavaScript/node_modules/for-each/index.js\")\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/parse-headers/parse-headers.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/query-string/index.js":
/*!******************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/query-string/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar strictUriEncode = __webpack_require__(/*! strict-uri-encode */ \"../Formality-JavaScript/node_modules/strict-uri-encode/index.js\");\nvar objectAssign = __webpack_require__(/*! object-assign */ \"../Formality-JavaScript/node_modules/object-assign/index.js\");\nvar decodeComponent = __webpack_require__(/*! decode-uri-component */ \"../Formality-JavaScript/node_modules/decode-uri-component/index.js\");\n\nfunction encoderForArrayFormat(opts) {\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, index) {\n\t\t\t\treturn value === null ? [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tindex,\n\t\t\t\t\t']'\n\t\t\t\t].join('') : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tencode(index, opts),\n\t\t\t\t\t']=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[]=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(opts) {\n\tvar result;\n\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t} else if (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, opts) {\n\tif (opts.encode) {\n\t\treturn opts.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t} else if (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input)).sort(function (a, b) {\n\t\t\treturn Number(a) - Number(b);\n\t\t}).map(function (key) {\n\t\t\treturn input[key];\n\t\t});\n\t}\n\n\treturn input;\n}\n\nfunction extract(str) {\n\tvar queryStart = str.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\treturn str.slice(queryStart + 1);\n}\n\nfunction parse(str, opts) {\n\topts = objectAssign({arrayFormat: 'none'}, opts);\n\n\tvar formatter = parserForArrayFormat(opts);\n\n\t// Create an object with no prototype\n\t// https://github.com/sindresorhus/query-string/issues/47\n\tvar ret = Object.create(null);\n\n\tif (typeof str !== 'string') {\n\t\treturn ret;\n\t}\n\n\tstr = str.trim().replace(/^[?#&]/, '');\n\n\tif (!str) {\n\t\treturn ret;\n\t}\n\n\tstr.split('&').forEach(function (param) {\n\t\tvar parts = param.replace(/\\+/g, ' ').split('=');\n\t\t// Firefox (pre 40) decodes `%3D` to `=`\n\t\t// https://github.com/sindresorhus/query-string/pull/37\n\t\tvar key = parts.shift();\n\t\tvar val = parts.length > 0 ? parts.join('=') : undefined;\n\n\t\t// missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tval = val === undefined ? null : decodeComponent(val);\n\n\t\tformatter(decodeComponent(key), val, ret);\n\t});\n\n\treturn Object.keys(ret).sort().reduce(function (result, key) {\n\t\tvar val = ret[key];\n\t\tif (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(val);\n\t\t} else {\n\t\t\tresult[key] = val;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = function (obj, opts) {\n\tvar defaults = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t};\n\n\topts = objectAssign(defaults, opts);\n\n\tif (opts.sort === false) {\n\t\topts.sort = function () {};\n\t}\n\n\tvar formatter = encoderForArrayFormat(opts);\n\n\treturn obj ? Object.keys(obj).sort(opts.sort).map(function (key) {\n\t\tvar val = obj[key];\n\n\t\tif (val === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (val === null) {\n\t\t\treturn encode(key, opts);\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tvar result = [];\n\n\t\t\tval.slice().forEach(function (val2) {\n\t\t\t\tif (val2 === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult.push(formatter(key, val2, result.length));\n\t\t\t});\n\n\t\t\treturn result.join('&');\n\t\t}\n\n\t\treturn encode(key, opts) + '=' + encode(val, opts);\n\t}).filter(function (x) {\n\t\treturn x.length > 0;\n\t}).join('&') : '';\n};\n\nexports.parseUrl = function (str, opts) {\n\treturn {\n\t\turl: str.split('?')[0] || '',\n\t\tquery: parse(extract(str), opts)\n\t};\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/query-string/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/strict-uri-encode/index.js":
/*!***********************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/strict-uri-encode/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (str) {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n\t\treturn '%' + c.charCodeAt(0).toString(16).toUpperCase();\n\t});\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/strict-uri-encode/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/string.prototype.trim/implementation.js":
/*!************************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/string.prototype.trim/implementation.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"../Formality-JavaScript/node_modules/function-bind/index.js\");\nvar ES = __webpack_require__(/*! es-abstract/es5 */ \"../Formality-JavaScript/node_modules/es-abstract/es5.js\");\nvar replace = bind.call(Function.call, String.prototype.replace);\n\n/* eslint-disable no-control-regex */\nvar leftWhitespace = /^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+/;\nvar rightWhitespace = /[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+$/;\n/* eslint-enable no-control-regex */\n\nmodule.exports = function trim() {\n\tvar S = ES.ToString(ES.CheckObjectCoercible(this));\n\treturn replace(replace(S, leftWhitespace, ''), rightWhitespace, '');\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/string.prototype.trim/implementation.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/string.prototype.trim/index.js":
/*!***************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/string.prototype.trim/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"../Formality-JavaScript/node_modules/function-bind/index.js\");\nvar define = __webpack_require__(/*! define-properties */ \"../Formality-JavaScript/node_modules/define-properties/index.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"../Formality-JavaScript/node_modules/string.prototype.trim/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"../Formality-JavaScript/node_modules/string.prototype.trim/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"../Formality-JavaScript/node_modules/string.prototype.trim/shim.js\");\n\nvar boundTrim = bind.call(Function.call, getPolyfill());\n\ndefine(boundTrim, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = boundTrim;\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/string.prototype.trim/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/string.prototype.trim/polyfill.js":
/*!******************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/string.prototype.trim/polyfill.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"../Formality-JavaScript/node_modules/string.prototype.trim/implementation.js\");\n\nvar zeroWidthSpace = '\\u200b';\n\nmodule.exports = function getPolyfill() {\n\tif (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace) {\n\t\treturn String.prototype.trim;\n\t}\n\treturn implementation;\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/string.prototype.trim/polyfill.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/string.prototype.trim/shim.js":
/*!**************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/string.prototype.trim/shim.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"../Formality-JavaScript/node_modules/define-properties/index.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"../Formality-JavaScript/node_modules/string.prototype.trim/polyfill.js\");\n\nmodule.exports = function shimStringTrim() {\n\tvar polyfill = getPolyfill();\n\tdefine(String.prototype, { trim: polyfill }, {\n\t\ttrim: function testTrim() {\n\t\t\treturn String.prototype.trim !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/string.prototype.trim/shim.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/url-set-query/index.js":
/*!*******************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/url-set-query/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = urlSetQuery\nfunction urlSetQuery (url, query) {\n  if (query) {\n    // remove optional leading symbols\n    query = query.trim().replace(/^(\\?|#|&)/, '')\n\n    // don't append empty query\n    query = query ? ('?' + query) : query\n\n    var parts = url.split(/[\\?\\#]/)\n    var start = parts[0]\n    if (query && /\\:\\/\\/[^\\/]*$/.test(start)) {\n      // e.g. http://foo.com -> http://foo.com/\n      start = start + '/'\n    }\n    var match = url.match(/(\\#.*)$/)\n    url = start + query\n    if (match) { // add hash back in\n      url = url + match[0]\n    }\n  }\n  return url\n}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/url-set-query/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/xhr-request-promise/index.js":
/*!*************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/xhr-request-promise/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var request = __webpack_require__(/*! xhr-request */ \"../Formality-JavaScript/node_modules/xhr-request/index.js\")\n\nmodule.exports = function (url, options) {\n  return new Promise(function (resolve, reject) {\n    request(url, options, function (err, data) {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/xhr-request-promise/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/xhr-request/index.js":
/*!*****************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/xhr-request/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var queryString = __webpack_require__(/*! query-string */ \"../Formality-JavaScript/node_modules/query-string/index.js\")\nvar setQuery = __webpack_require__(/*! url-set-query */ \"../Formality-JavaScript/node_modules/url-set-query/index.js\")\nvar assign = __webpack_require__(/*! object-assign */ \"../Formality-JavaScript/node_modules/object-assign/index.js\")\nvar ensureHeader = __webpack_require__(/*! ./lib/ensure-header.js */ \"../Formality-JavaScript/node_modules/xhr-request/lib/ensure-header.js\")\n\n// this is replaced in the browser\nvar request = __webpack_require__(/*! ./lib/request.js */ \"../Formality-JavaScript/node_modules/xhr-request/lib/request-browser.js\")\n\nvar mimeTypeJson = 'application/json'\nvar noop = function () {}\n\nmodule.exports = xhrRequest\nfunction xhrRequest (url, opt, cb) {\n  if (!url || typeof url !== 'string') {\n    throw new TypeError('must specify a URL')\n  }\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (cb && typeof cb !== 'function') {\n    throw new TypeError('expected cb to be undefined or a function')\n  }\n\n  cb = cb || noop\n  opt = opt || {}\n\n  var defaultResponse = opt.json ? 'json' : 'text'\n  opt = assign({ responseType: defaultResponse }, opt)\n\n  var headers = opt.headers || {}\n  var method = (opt.method || 'GET').toUpperCase()\n  var query = opt.query\n  if (query) {\n    if (typeof query !== 'string') {\n      query = queryString.stringify(query)\n    }\n    url = setQuery(url, query)\n  }\n\n  // allow json response\n  if (opt.responseType === 'json') {\n    ensureHeader(headers, 'Accept', mimeTypeJson)\n  }\n\n  // if body content is json\n  if (opt.json && method !== 'GET' && method !== 'HEAD') {\n    ensureHeader(headers, 'Content-Type', mimeTypeJson)\n    opt.body = JSON.stringify(opt.body)\n  }\n\n  opt.method = method\n  opt.url = url\n  opt.headers = headers\n  delete opt.query\n  delete opt.json\n\n  return request(opt, cb)\n}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/xhr-request/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/xhr-request/lib/ensure-header.js":
/*!*****************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/xhr-request/lib/ensure-header.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ensureHeader\nfunction ensureHeader (headers, key, value) {\n  var lower = key.toLowerCase()\n  if (!headers[key] && !headers[lower]) {\n    headers[key] = value\n  }\n}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/xhr-request/lib/ensure-header.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/xhr-request/lib/normalize-response.js":
/*!**********************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/xhr-request/lib/normalize-response.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = getResponse\nfunction getResponse (opt, resp) {\n  if (!resp) return null\n  return {\n    statusCode: resp.statusCode,\n    headers: resp.headers,\n    method: opt.method,\n    url: opt.url,\n    // the XHR object in browser, http response in Node\n    rawRequest: resp.rawRequest ? resp.rawRequest : resp\n  }\n}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/xhr-request/lib/normalize-response.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/xhr-request/lib/request-browser.js":
/*!*******************************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/xhr-request/lib/request-browser.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var xhr = __webpack_require__(/*! xhr */ \"../Formality-JavaScript/node_modules/xhr/index.js\")\nvar normalize = __webpack_require__(/*! ./normalize-response */ \"../Formality-JavaScript/node_modules/xhr-request/lib/normalize-response.js\")\nvar noop = function () {}\n\nmodule.exports = xhrRequest\nfunction xhrRequest (opt, cb) {\n  delete opt.uri\n\n  // for better JSON.parse error handling than xhr module\n  var useJson = false\n  if (opt.responseType === 'json') {\n    opt.responseType = 'text'\n    useJson = true\n  }\n\n  var req = xhr(opt, function xhrRequestResult (err, resp, body) {\n    if (useJson && !err) {\n      try {\n        var text = resp.rawRequest.responseText\n        body = JSON.parse(text)\n      } catch (e) {\n        err = e\n      }\n    }\n\n    resp = normalize(opt, resp)\n    if (err) cb(err, null, resp)\n    else cb(err, body, resp)\n    cb = noop\n  })\n\n  // Patch abort() so that it also calls the callback, but with an error\n  var onabort = req.onabort\n  req.onabort = function () {\n    var ret = onabort.apply(req, Array.prototype.slice.call(arguments))\n    cb(new Error('XHR Aborted'))\n    cb = noop\n    return ret\n  }\n\n  return req\n}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/xhr-request/lib/request-browser.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/xhr/index.js":
/*!*********************************************************!*\
  !*** ../Formality-JavaScript/node_modules/xhr/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar window = __webpack_require__(/*! global/window */ \"../Formality-JavaScript/node_modules/global/window.js\")\nvar isFunction = __webpack_require__(/*! is-function */ \"../Formality-JavaScript/node_modules/is-function/index.js\")\nvar parseHeaders = __webpack_require__(/*! parse-headers */ \"../Formality-JavaScript/node_modules/parse-headers/parse-headers.js\")\nvar xtend = __webpack_require__(/*! xtend */ \"../Formality-JavaScript/node_modules/xtend/immutable.js\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/xhr/index.js?");

/***/ }),

/***/ "../Formality-JavaScript/node_modules/xtend/immutable.js":
/*!***************************************************************!*\
  !*** ../Formality-JavaScript/node_modules/xtend/immutable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/node_modules/xtend/immutable.js?");

/***/ }),

/***/ "../Formality-JavaScript/package.json":
/*!********************************************!*\
  !*** ../Formality-JavaScript/package.json ***!
  \********************************************/
/*! exports provided: name, version, description, main, bin, scripts, repository, author, license, bugs, homepage, dependencies, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"formality-lang\",\"version\":\"0.3.91\",\"description\":\"\",\"main\":\"src/exports.js\",\"bin\":{\"fm\":\"src/main.js\"},\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/moonad/formality-core.git\"},\"author\":\"Victor Maia\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/moonad/formality-core/issues\"},\"homepage\":\"https://github.com/moonad/formality-core#readme\",\"dependencies\":{\"xhr-request-promise\":\"^0.1.2\"}};\n\n//# sourceURL=webpack:///../Formality-JavaScript/package.json?");

/***/ }),

/***/ "../Formality-JavaScript/src/exports.js":
/*!**********************************************!*\
  !*** ../Formality-JavaScript/src/exports.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fm = module.exports = {\n  core: __webpack_require__(/*! ./fm-core.js */ \"../Formality-JavaScript/src/fm-core.js\"),\n  lang: __webpack_require__(/*! ./fm-lang.js */ \"../Formality-JavaScript/src/fm-lang.js\"),\n  net: __webpack_require__(/*! ./fm-net.js */ \"../Formality-JavaScript/src/fm-net.js\"),\n  to_net: __webpack_require__(/*! ./fm-to-net.js */ \"../Formality-JavaScript/src/fm-to-net.js\"),\n  to_js: __webpack_require__(/*! ./fm-to-js.js */ \"../Formality-JavaScript/src/fm-to-js.js\"),\n};\n\n// TODO: move to FM-Lang\nfm.lang.norm = function norm(term, defs, mode = \"DEBUG\", opts, stats = {}) {\n  var erase = opts.erased ? fm.lang.erase : (x => x);\n  switch (mode) {\n    case \"DEBUG\":\n      var erased = (opts.erased ? fm.lang.erase : (x=>x))(term);\n      return fm.core.norm(erased, defs, {weak: opts.weak, unbox: opts.unbox, logging: opts.logging});\n    case \"JAVASCRIPT\":\n      return fm.to_js.decompile(fm.to_js.compile(fm.lang.erase(term, defs), defs));\n    case \"OPTIMAL\":\n      var net = fm.to_net.compile(fm.lang.erase(term, defs), defs);\n      if (stats && stats.input_net === null) {\n        stats.input_net = JSON.parse(JSON.stringify(net));\n      }\n      if (opts.strict) {\n        var new_stats = net.reduce_strict(stats || {});\n      } else {\n        var new_stats = net.reduce_lazy(stats || {});\n      }\n      if (stats && stats.output_net !== undefined) {\n        stats.output_net = JSON.parse(JSON.stringify(net));\n      }\n      return fm.to_net.decompile(net);\n    case \"TYPE\":\n      fm.lang.boxcheck(term, defs);\n      return fm.core.norm(fm.lang.typecheck(term, null, defs), {}, {weak: false, unbox: true});\n  }\n}\n\n// TODO: move to FM-Lang\nfm.lang.exec = function exec(name, defs, mode = \"OPTIMAL_LAZY\", opts, stats = {}) {\n  if (defs[name] && defs[name][0] === \"Ref\" && !defs[defs[name][1].name]) {\n    name = defs[name][1].name;\n  }\n  var term = defs[name] || fm.lang.Ref(name);\n  var result = fm.lang.norm(term, defs, mode, opts, stats);\n  return result;\n}\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/src/exports.js?");

/***/ }),

/***/ "../Formality-JavaScript/src/fm-core.js":
/*!**********************************************!*\
  !*** ../Formality-JavaScript/src/fm-core.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Core Language ~~\n\n// ::::::::::\n// :: Term ::\n// ::::::::::\n\n// An FM-Lang term is an ADT represented as a JSON.\n// - Var: a variable\n// - Typ: the type of types, `Type`\n// - All: the dependent function type, `{x : A} -> B`, optionally erased\n// - Lam: a lambda, `{x} => B`, optionally erased/annotated\n// - App: an application `f(a)`, optionally erased\n// - Box: a boxed type, `!A`\n// - Put: a boxed value, `#a`\n// - Tak: unboxes a boxed value, `<>a`\n// - Dup: copies a boxed value, `dup x = a; b`\n// - Wrd: type of a native number\n// - Num: value of a native number\n// - Op1: partially applied binary numeric operation, `|n + k|`, with `k` fixed\n// - Op2: binary numeric operation, `|x + y|`\n// - Ite: if-then-else, `if n p`,  with a numeric conditional `n`, and two branches in a pair `p`\n// - Cpy: copies a number, `cpy x = a; b`\n// - Sig: type of a dependent pair, `[x : A, B(x)]`, or of a subset type, `[x : A ~ B(x)]`\n// - Par: value of a dependent pair, `[a, b]`, or of a dependent intersection `[a ~ b]`\n// - Fst: extracts 1st value of a dependent pair, `fst p`, or of a dependent intersection, `~fst p`\n// - Snd: extracts 2nd value of a dependent pair, `snd p`, or of a dependent intersection, `~snd p`\n// - Prj: projects a dependent pair, `get [x , y] = a; b`, or a dependent intersection, `get [x ~ y] = a; b`\n// - Eql: erased untyped equality type, `<a = b>`\n// - Rfl: reflexivity, i.e., a proof that a value is equal to itself, `$a`\n// - Sym: symmetry of equality, `sym e`\n// - Rwt: rewrite equal terms in types, `rwt e <x @ (P x)> a`\n// - Ann: an explicit type annotaion, `: A a`\n// - Log: debug-prints a term during evaluation\n// - Ref: a reference to a global def\nvar MEMO  = true;\nconst Var = (index)                        => [\"Var\", {index},                        MEMO && (\"^\" + index)];\nconst Typ = ()                             => [\"Typ\", {},                             MEMO && (\"ty\")];\nconst Tid = (expr)                         => [\"Tid\", {expr},                         MEMO && expr[2]];\nconst All = (name, bind, body, eras)       => [\"All\", {name, bind, body, eras},       MEMO && (\"al\" + (eras?\"-\":\"\") + bind[2] + body[2])];\nconst Lam = (name, bind, body, eras)       => [\"Lam\", {name, bind, body, eras},       MEMO && (\"lm\" + (eras?\"-\":\"\") + body[2])];\nconst App = (func, argm, eras)             => [\"App\", {func, argm, eras},             MEMO && (\"ap\" + (eras?\"-\":\"\") + func[2] + argm[2])];\nconst Box = (expr)                         => [\"Box\", {expr},                         MEMO && (\"bx\" + expr[2])];\nconst Put = (expr)                         => [\"Put\", {expr},                         MEMO && (\"pt\" + expr[2])];\nconst Tak = (expr)                         => [\"Tak\", {expr},                         MEMO && (\"tk\" + expr[2])];\nconst Dup = (name, expr, body)             => [\"Dup\", {name, expr, body},             MEMO && (\"dp\" + expr[2] + body[2])];\nconst Wrd = ()                             => [\"Wrd\", {},                             MEMO && (\"wd\")];\nconst Num = (numb)                         => [\"Num\", {numb},                         MEMO && (\"[\" + numb + \"]\")];\nconst Op1 = (func, num0, num1)             => [\"Op1\", {func, num0, num1},             MEMO && (\"o1\" + func +  num0[2] + num1[2])];\nconst Op2 = (func, num0, num1)             => [\"Op2\", {func, num0, num1},             MEMO && (\"o2\" + func + num0[2] + num1[2])];\nconst Ite = (cond, pair)                   => [\"Ite\", {cond, pair},                   MEMO && (\"ie\" + cond[2] + pair[2])];\nconst Cpy = (name, numb, body)             => [\"Cpy\", {name, numb, body},             MEMO && (\"cy\" + numb[2] + body[2])];\nconst Sig = (name, typ0, typ1, eras)       => [\"Sig\", {name, typ0, typ1, eras},       MEMO && (\"sg\" + eras + typ0[2] + typ1[2])];\nconst Par = (val0, val1, eras)             => [\"Par\", {val0, val1, eras},             MEMO && (\"pr\" + eras + val0[2] + val1[2])];\nconst Fst = (pair, eras)                   => [\"Fst\", {pair, eras},                   MEMO && (\"ft\" + eras + pair[2])];\nconst Snd = (pair, eras)                   => [\"Snd\", {pair, eras},                   MEMO && (\"sd\" + eras + pair[2])];\nconst Prj = (nam0, nam1, pair, body, eras) => [\"Prj\", {nam0, nam1, pair, body, eras}, MEMO && (\"pj\" + eras + pair[2] + body[2])];\nconst Eql = (val0, val1)                   => [\"Eql\", {val0, val1},                   MEMO && (\"eq\" + val0[2] + val1[2])];\nconst Rfl = (expr)                         => [\"Rfl\", {expr},                         MEMO && \"*\"];\nconst Sym = (prof)                         => [\"Sym\", {prof},                         MEMO && \"*\"];\nconst Rwt = (name, type, prof, expr)       => [\"Rwt\", {name, type, prof, expr},       MEMO && expr[2]];\nconst Slf = (name, type)                   => [\"Slf\", {name, type},                   MEMO && (\"sf\" + type[2])];\nconst New = (type, expr)                   => [\"New\", {type, expr},                   MEMO && expr[2]];\nconst Use = (expr)                         => [\"Use\", {expr},                         MEMO && expr[2]];\nconst Ann = (type, expr, done)             => [\"Ann\", {type, expr, done},             MEMO && expr[2]];\nconst Log = (msge, expr)                   => [\"Log\", {msge, expr},                   MEMO && expr[2]];\nconst Ref = (name, eras)                   => [\"Ref\", {name, eras},                   MEMO && (\"{\" + name + \"}\")];\n\n// :::::::::::::::::::::\n// :: Stringification ::\n// :::::::::::::::::::::\n\n// Converts a term to a string\nconst show = ([ctor, args], nams = [], opts = {}) => {\n  const print_output = (term) => {\n    try {\n      if (term[1].val0[1].numb === 0x53484f57) {\n        term = term[1].val1;\n        var nums = [];\n        while (term[1].body[1].body[0] !== \"Var\") {\n          term = term[1].body[1].body;\n          nums.push(term[1].func[1].argm[1].numb);\n          term = term[1].argm;\n        }\n        return new TextDecoder(\"utf-8\").decode(new Uint8Array(new Uint32Array(nums).buffer));\n      } else {\n        return null;\n      }\n    } catch (e) {\n      return null;\n    }\n  }\n  switch (ctor) {\n    case \"Var\":\n      var name = nams[nams.length - args.index - 1];\n      if (!name) {\n        return \"^\" + args.index;\n      } else {\n        var suff = \"\";\n        for (var i = 0; i < args.index; ++i) {\n          if (nams[nams.length - i - 1] === name) {\n            var suff = suff + \"^\";\n          }\n        }\n        return name + suff;\n      }\n    case \"Typ\":\n      return \"Type\";\n    case \"Tid\":\n      var expr = show(args.expr, nams, opts);\n      return \"type(\" + expr + \")\";\n    case \"All\":\n      var term = [ctor, args];\n      var erase = [];\n      var names = [];\n      var types = [];\n      while (term[0] === \"All\") {\n        erase.push(term[1].eras);\n        names.push(term[1].name);\n        types.push(show(term[1].bind, nams.concat(names.slice(0,-1)), opts));\n        term = term[1].body;\n      }\n      var text = \"{\";\n      for (var i = 0; i < names.length; ++i) {\n        text += erase[i] ? \"~\" : \"\";\n        text += names[i] + (names[i].length > 0 ? \" : \" : \":\") + types[i];\n        text += i < names.length - 1 ? \", \" : \"\";\n      }\n      text += \"} -> \";\n      text += show(term, nams.concat(names), opts);\n      return text;\n    case \"Lam\":\n      var term = [ctor, args];\n      var numb = null;\n      var erase = [];\n      var names = [];\n      var types = [];\n      while (term[0] === \"Lam\") {\n        erase.push(term[1].eras);\n        names.push(term[1].name);\n        types.push(term[1].bind ? show(term[1].bind, nams.concat(names.slice(0,-1)), opts) : null);\n        term = term[1].body;\n      }\n      var text = \"{\";\n      for (var i = 0; i < names.length; ++i) {\n        text += erase[i] ? \"~\" : \"\";\n        text += names[i] + (types[i] !== null ? \" : \" + types[i] : \"\");\n        text += i < names.length - 1 ? \", \" : \"\";\n      }\n      text += \"} => \";\n      if (numb !== null) {\n        text += \"%\" + Number(numb);\n      } else {\n        text += show(term, nams.concat(names), opts);\n      }\n      return text;\n    case \"App\":\n      var text = \")\";\n      var term = [ctor, args];\n      while (term[0] === \"App\") {\n        text = (term[1].func[0] === \"App\" ? \", \" : \"\") + (term[1].eras ? \"~\" : \"\") + show(term[1].argm, nams, opts) + text;\n        term = term[1].func;\n      }\n      if (term[0] === \"Ref\" || term[0] === \"Var\" || term[0] === \"Tak\") {\n        var func = show(term, nams, opts);\n      } else {\n        var func = \"(\" + show(term,nams, opts) + \")\";\n      }\n      return func + \"(\" + text;\n    case \"Box\":\n      var expr = show(args.expr, nams, opts);\n      return \"!\" + expr;\n    case \"Put\":\n      var expr = show(args.expr, nams, opts);\n      return \"#\" + expr;\n    case \"Tak\":\n      var expr = show(args.expr, nams, opts);\n      return \"<\" + expr + \">\";\n    case \"Dup\":\n      var name = args.name;\n      var expr = show(args.expr, nams, opts);\n      if (args.body[0] === \"Var\" && args.body[1].index === 0) {\n        return \"<\" + expr + \">\";\n      } else {\n        var body = show(args.body, nams.concat([name]), opts);\n        return \"dup \" + name + \" = \" + expr + \"; \" + body;\n      }\n    case \"Wrd\":\n      return \"Word\";\n    case \"Num\":\n      return args.numb.toString();\n    case \"Op1\":\n    case \"Op2\":\n      var func = args.func;\n      var num0 = show(args.num0, nams, opts);\n      var num1 = show(args.num1, nams, opts);\n      return num0 + \" \" + func + \" \" + num1;\n    case \"Ite\":\n      var cond = show(args.cond, nams, opts);\n      var pair = show(args.pair, nams, opts);\n      return \"if \" + cond + \" \" + pair;\n    case \"Cpy\":\n      var name = args.name;\n      var numb = show(args.numb, nams, opts);\n      var body = show(args.body, nams.concat([name]), opts);\n      return \"cpy \" + name + \" = \" + numb + \"; \" + body;\n    case \"Sig\":\n      var era1 = args.eras === 1 ? \"~\" : \"\";\n      var era2 = args.eras === 2 ? \"~\" : \"\";\n      var name = args.name;\n      var typ0 = show(args.typ0, nams, opts);\n      var typ1 = show(args.typ1, nams.concat([name]), opts);\n      return \"[\" + era1 + name + (name.length > 0 ? \" \" : \"\") + \": \" + typ0 + \", \" + era2 + typ1 + \"]\";\n    case \"Par\":\n      var text = print_output([ctor, args]);\n      if (text !== null) {\n        return text;\n      } else {\n        var era1 = args.eras === 1 ? \"~\" : \"\";\n        var era2 = args.eras === 2 ? \"~\" : \"\";\n        var val0 = show(args.val0, nams, opts);\n        var val1 = show(args.val1, nams, opts);\n        return \"[\" + era1 + val0 + \", \" + era2 + val1 + \"]\";\n      }\n    case \"Fst\":\n      var pair = show(args.pair, nams, opts);\n      var eras = args.eras > 0 ? \"~\" : \"\";\n      return eras + \"fst(\" + pair + \")\";\n    case \"Snd\":\n      var pair = show(args.pair, nams, opts);\n      var eras = args.eras > 0 ? \"~\" : \"\";\n      return eras + \"snd(\" + pair + \")\";\n    case \"Prj\":\n      var nam0 = args.nam0;\n      var nam1 = args.nam1;\n      var pair = show(args.pair, nams, opts);\n      var body = show(args.body, nams.concat([nam0, nam1]), opts);\n      var era1 = args.eras === 1 ? \"~\" : \"\";\n      var era2 = args.eras === 2 ? \"~\" : \"\";\n      return \"get [\" + era1 + nam0 + \",\" + era2 + nam1 + \"] = \" + pair + \"; \" + body;\n    case \"Eql\":\n      var val0 = show(args.val0, nams, opts);\n      var val1 = show(args.val1, nams, opts);\n      return val0 + \" == \" + val1;\n    case \"Rfl\":\n      var expr = show(args.expr, nams, opts);\n      return \"refl(~\" + expr + \")\";\n    case \"Sym\":\n      var prof = show(args.prof, nams, opts);\n      return \"sym(~\" + prof + \")\";\n    case \"Rwt\":\n      var name = args.name;\n      var type = show(args.type, nams.concat([name]), opts);\n      var prof = show(args.prof, nams, opts);\n      var expr = show(args.expr, nams, opts);\n      return expr + \" :: rewrite \" + name + \" in \" + type + \" with \" + prof;\n    case \"Slf\":\n      var name = args.name;\n      var type = show(args.type, nams.concat([name]), opts);\n      return \"$\" + name + \" \" + type;\n    case \"New\":\n      var type = show(args.type, nams, opts);\n      var expr = show(args.expr, nams, opts);\n      return \"new(~\" + type + \") \" + expr;\n    case \"Use\":\n      var expr = show(args.expr, nams, opts);\n      return \"%\" + expr;\n    case \"Ann\":\n      var expr = show(args.expr, nams, opts);\n      //var type = show(args.type, nams, opts);\n      //return \"\\n: \" + type + \"\\n= \" + expr;\n      return expr;\n    case \"Log\":\n      var expr = show(args.expr, nams, opts);\n      return expr;\n    case \"Ref\":\n      return !opts.full_refs ? args.name.replace(new RegExp(\".*/\", \"g\"), \"\") : args.name;\n  }\n};\n\n// ::::::::::::::::::\n// :: Substitution ::\n// ::::::::::::::::::\n\n// Shifts a term\nconst shift = ([ctor, term], inc, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index < depth ? term.index : term.index + inc);\n    case \"Typ\":\n      return Typ();\n    case \"Tid\":\n      var expr = shift(term.expr, inc, depth);\n      return Tid(expr);\n    case \"All\":\n      var name = term.name;\n      var bind = shift(term.bind, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      var eras = term.eras;\n      return All(name, bind, body, eras);\n    case \"Lam\":\n      var name = term.name;\n      var bind = term.bind && shift(term.bind, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      var eras = term.eras;\n      return Lam(name, bind, body, eras);\n    case \"App\":\n      var func = shift(term.func, inc, depth);\n      var argm = shift(term.argm, inc, depth);\n      var eras = term.eras;\n      return App(func, argm, term.eras);\n    case \"Box\":\n      var expr = shift(term.expr, inc, depth);\n      return Box(expr);\n    case \"Put\":\n      var expr = shift(term.expr, inc, depth);\n      return Put(expr);\n    case \"Tak\":\n      var expr = shift(term.expr, inc, depth);\n      return Tak(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = shift(term.expr, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Dup(name, expr, body);\n    case \"Wrd\":\n      return Wrd();\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = shift(term.num0, inc, depth);\n      var num1 = shift(term.num1, inc, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = shift(term.cond, inc, depth);\n      var pair = shift(term.pair, inc, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = shift(term.numb, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Cpy(name, numb, body);\n    case \"Sig\":\n      var name = term.name;\n      var typ0 = shift(term.typ0, inc, depth);\n      var typ1 = shift(term.typ1, inc, depth + 1);\n      var eras = term.eras;\n      return Sig(name, typ0, typ1, eras);\n    case \"Par\":\n      var val0 = shift(term.val0, inc, depth);\n      var val1 = shift(term.val1, inc, depth);\n      var eras = term.eras;\n      return Par(val0, val1, eras);\n    case \"Fst\":\n      var pair = shift(term.pair, inc, depth);\n      var eras = term.eras;\n      return Fst(pair, eras);\n    case \"Snd\":\n      var pair = shift(term.pair, inc, depth);\n      var eras = term.eras;\n      return Snd(pair, eras);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = shift(term.pair, inc, depth);\n      var body = shift(term.body, inc, depth + 2);\n      var eras = term.eras;\n      return Prj(nam0, nam1, pair, body, eras);\n    case \"Eql\":\n      var val0 = shift(term.val0, inc, depth);\n      var val1 = shift(term.val1, inc, depth);\n      return Eql(val0, val1);\n    case \"Rfl\":\n      var expr = shift(term.expr, inc, depth);\n      return Rfl(expr);\n    case \"Sym\":\n      var prof = shift(term.prof, inc, depth);\n      return Sym(prof);\n    case \"Rwt\":\n      var name = term.name;\n      var type = shift(term.type, inc, depth + 1);\n      var prof = shift(term.prof, inc, depth);\n      var expr = shift(term.expr, inc, depth);\n      return Rwt(name, type, prof, expr);\n    case \"Slf\":\n      var name = term.name;\n      var type = shift(term.type, inc, depth + 1);\n      return Slf(name, type);\n    case \"New\":\n      var type = shift(term.type, inc, depth);\n      var expr = shift(term.expr, inc, depth);\n      return New(type, expr);\n    case \"Use\":\n      var expr = shift(term.expr, inc, depth);\n      return Use(expr);\n    case \"Ann\":\n      var type = shift(term.type, inc, depth);\n      var expr = shift(term.expr, inc, depth);\n      var done = term.done;\n      return Ann(type, expr, done);\n    case \"Log\":\n      var msge = shift(term.msge, inc, depth);\n      var expr = shift(term.expr, inc, depth);\n      return Log(msge, expr);\n    case \"Ref\":\n      return Ref(term.name, term.eras);\n  }\n}\n\n// Substitution\nconst subst = ([ctor, term], val, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return depth === term.index ? val : Var(term.index - (term.index > depth ? 1 : 0));\n    case \"Typ\":\n      return Typ();\n    case \"Tid\":\n      var expr = subst(term.expr, val, depth);\n      return Tid(expr);\n    case \"All\":\n      var name = term.name;\n      var bind = subst(term.bind, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      var eras = term.eras;\n      return All(name, bind, body, eras);\n    case \"Lam\":\n      var name = term.name;\n      var bind = term.bind && subst(term.bind, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      var eras = term.eras;\n      return Lam(name, bind, body, eras);\n    case \"App\":\n      var func = subst(term.func, val, depth);\n      var argm = subst(term.argm, val, depth);\n      var eras = term.eras;\n      return App(func, argm, eras);\n    case \"Box\":\n      var expr = subst(term.expr, val, depth);\n      return Box(expr);\n    case \"Put\":\n      var expr = subst(term.expr, val, depth);\n      return Put(expr);\n    case \"Tak\":\n      var expr = subst(term.expr, val, depth);\n      return Tak(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = subst(term.expr, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Dup(name, expr, body);\n    case \"Wrd\":\n      return Wrd();\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = subst(term.num0, val, depth);\n      var num1 = subst(term.num1, val, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = subst(term.cond, val, depth);\n      var pair = subst(term.pair, val, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = subst(term.numb, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Cpy(name, numb, body);\n    case \"Sig\":\n      var name = term.name;\n      var typ0 = subst(term.typ0, val, depth);\n      var typ1 = subst(term.typ1, val && shift(val, 1, 0), depth + 1);\n      var eras = term.eras;\n      return Sig(name, typ0, typ1, eras);\n    case \"Par\":\n      var val0 = subst(term.val0, val, depth);\n      var val1 = subst(term.val1, val, depth);\n      var eras = term.eras;\n      return Par(val0, val1, eras);\n    case \"Fst\":\n      var pair = subst(term.pair, val, depth);\n      var eras = term.eras;\n      return Fst(pair, eras);\n    case \"Snd\":\n      var pair = subst(term.pair, val, depth);\n      var eras = term.eras;\n      return Snd(pair, eras);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = subst(term.pair, val, depth);\n      var body = subst(term.body, val && shift(val, 2, 0), depth + 2);\n      var eras = term.eras;\n      return Prj(nam0, nam1, pair, body, eras);\n    case \"Eql\":\n      var val0 = subst(term.val0, val, depth);\n      var val1 = subst(term.val1, val, depth);\n      return Eql(val0, val1);\n    case \"Rfl\":\n      var expr = subst(term.expr, val, depth);\n      return Rfl(expr);\n    case \"Sym\":\n      var prof = subst(term.prof, val, depth);\n      return Sym(prof);\n    case \"Rwt\":\n      var name = term.name;\n      var type = subst(term.type, val && shift(val, 1, 0), depth + 1);\n      var prof = subst(term.prof, val, depth);\n      var expr = subst(term.expr, val, depth);\n      return Rwt(name, type, prof, expr);\n    case \"Slf\":\n      var name = term.name;\n      var type = subst(term.type, val && shift(val, 1, 0), depth + 1);\n      return Slf(name, type);\n    case \"New\":\n      var type = subst(term.type, val, depth);\n      var expr = subst(term.expr, val, depth);\n      return New(type, expr);\n    case \"Use\":\n      var expr = subst(term.expr, val, depth);\n      return Use(expr);\n    case \"Ann\":\n      var type = subst(term.type, val, depth);\n      var expr = subst(term.expr, val, depth);\n      var done = term.done;\n      return Ann(type, expr, done);\n    case \"Log\":\n      var msge = subst(term.msge, val, depth);\n      var expr = subst(term.expr, val, depth);\n      return Log(msge, expr);\n    case \"Ref\":\n      var name = term.name;\n      return Ref(name, term.eras);\n  }\n}\n\nconst subst_many = (term, vals, depth) => {\n  for (var i = 0; i < vals.length; ++i) {\n    term = subst(term, shift(vals[i], vals.length - i - 1, 0), depth + vals.length - i - 1);\n  }\n  return term;\n}\n\n// ::::::::::::::::\n// :: Evaluation ::\n// ::::::::::::::::\n\n// Reduces a term to normal form or head normal form\n// Opts: weak, unbox, logging, eta\nconst norm = (term, defs = {}, opts) => {\n  var opts = opts || {};\n  const names_new = null;\n  const names_ext = (name, rest) => opts.logging ? {name, rest} : rest;\n  const names_arr = names => names ? [names.name].concat(names_arr(names.rest)) : [];\n  //const lam_eta = term => {\n    //if (opts.eta) {\n      //const is_eta = (term[1].body[0] === \"App\"\n        //&& term[1].body[1].argm[0] === \"Var\"\n        //&& term[1].body[1].argm[1].index === 0\n        //&& uses(term[1].body[1].func, 0) === 0);\n      //return is_eta ? subst(term[1].body[1].func, Typ(), 0) : term;\n    //} else {\n      //return term;\n    //}\n  //};\n  const apply = (func, argm, eras, names) => {\n    var func = reduce(func, names);\n    // ([x]a b) ~> [b/x]a\n    if (func[0] === \"Lam\") {\n      return reduce(func[1].body(argm), names);\n    // ((dup x = a; b) c) ~> dup x = a; (b c)\n    } else if (func[0] === \"Dup\") {\n      return Dup(func[1].name, func[1].expr, x => weak_reduce(App(func[1].body(x), argm, eras), names_ext(func[1].name, names)));\n    // (|a b) ~> ⊥\n    } else if (func[0] === \"Put\") {\n      throw \"[RUNTIME-ERROR]\\nCan't apply a boxed value.\";\n    } else {\n      return App(func, weak_reduce(argm, names), eras);\n    }\n  };\n  const take = (expr, names) => {\n    var expr = reduce(expr, names);\n    // <> #a ~> a\n    if (expr[0] === \"Put\") {\n      return reduce(expr[1].expr, names);\n    // <> (dup x = a; b) ~> dup x = a; <> b\n    } else if (expr[0] === \"Dup\"){\n      return Dup(expr[1].name, expr[1].expr, x => weak_reduce(Tak(expr[1].body(x)), names_ext(expr[1].name, names)));\n    } else {\n      return Tak(expr);\n    }\n  };\n  const duplicate = (name, expr, body, names) => {\n    var expr = reduce(expr, names);\n    // [x = |a] b ~> [a/x]b\n    if (expr[0] === \"Put\") {\n      return reduce(body(expr[1].expr), names);\n    // dup x = (dup y = a; b); c ~> dup y = a; dup x = b; c\n    } else if (expr[0] === \"Dup\") {\n      return Dup(expr[1].name, expr[1].expr, x => weak_reduce(Dup(name, expr[1].body(x), x => body(x)), names_ext(name, expr[1].name)));\n    // dup x = {y} b; c ~> ⊥\n    } else if (expr[0] === \"Lam\") {\n      throw \"[RUNTIME-ERROR]\\nCan't duplicate a lambda.\";\n    } else {\n      if (opts.undup) {\n        return reduce(body(Tak(expr)), names);\n      } else {\n        return Dup(name, expr, x => weak_reduce(body(x), names_ext(name, names)));\n      }\n    }\n  };\n  const dereference = (name, eras, names) => {\n    if (defs[name]) {\n      return reduce(unquote(eras ? erase(defs[name]) : defs[name], []), names_new);\n    } else {\n      return Ref(name, eras);\n    }\n  };\n  const op1 = (func, num0, num1, names) => {\n    var num0 = reduce(num0, names);\n    if (num0[0] === \"Num\") {\n      switch (func) {\n        case \"+\"  : return Num((num0[1].numb + num1[1].numb) >>> 0);\n        case \"-\"  : return Num((num0[1].numb - num1[1].numb) >>> 0);\n        case \"*\"  : return Num((num0[1].numb * num1[1].numb) >>> 0);\n        case \"/\"  : return Num((num0[1].numb / num1[1].numb) >>> 0);\n        case \"%\"  : return Num((num0[1].numb % num1[1].numb) >>> 0);\n        case \"^\"  : return Num((num0[1].numb ** num1[1].numb) >>> 0);\n        case \"**\" : return Num((num0[1].numb ** (num1[1].numb / (2 ** 32))) >>> 0);\n        case \".&\" : return Num((num0[1].numb & num1[1].numb) >>> 0);\n        case \".|\" : return Num((num0[1].numb | num1[1].numb) >>> 0);\n        case \".^\" : return Num((num0[1].numb ^ num1[1].numb) >>> 0);\n        case \".!\" : return Num((~ num1[1].numb) >>> 0);\n        case \".>>\": return Num((num0[1].numb >>> num1[1].numb) >>> 0);\n        case \".<<\": return Num((num0[1].numb << num1[1].numb) >>> 0);\n        case \".>\" : return Num((num0[1].numb > num1[1].numb ? 1 : 0) >>> 0);\n        case \".<\" : return Num((num0[1].numb < num1[1].numb ? 1 : 0) >>> 0);\n        case \".=\" : return Num((num0[1].numb === num1[1].numb ? 1 : 0) >>> 0);\n        default   : throw \"[RUNTIME-ERROR]\\nUnknown primitive: \" + func + \".\";\n      }\n    } else {\n      return Op1(func, num0, num1);\n    }\n  };\n  const op2 = (func, num0, num1, names) => {\n    var num1 = reduce(num1, names);\n    if (num1[0] === \"Num\") {\n      return reduce(Op1(func, num0, num1, null), names);\n    } else {\n      return Op2(func, weak_reduce(num0, names), num1);\n    }\n  };\n  const if_then_else = (cond, pair, names) => {\n    var cond = reduce(cond, names);\n    if (cond[0] === \"Num\") {\n      return cond[1].numb > 0 ? reduce(Fst(pair, false, null), names) : reduce(Snd(pair, false, null), names);\n    } else {\n      return Ite(cond, weak_reduce(pair, names));\n    }\n  };\n  const copy = (name, numb, body, names) => {\n    var numb = reduce(numb, names);\n    if (numb[0] === \"Num\") {\n      return reduce(body(numb), names);\n    } else {\n      return Cpy(name, numb, x => weak_reduce(body(x), names_ext(name, names)));\n    }\n  };\n  const first = (pair, eras, names) => {\n    var pair = reduce(pair, names);\n    if (pair[0] === \"Par\") {\n      return reduce(pair[1].val0, names);\n    } else {\n      return Fst(pair, eras);\n    }\n  };\n  const second = (pair, eras, names) => {\n    var pair = reduce(pair, names);\n    if (pair[0] === \"Par\") {\n      return reduce(pair[1].val1, names);\n    } else {\n      return Snd(pair, eras);\n    }\n  };\n  const project = (nam0, nam1, pair, body, eras, names) => {\n    var pair = reduce(pair, names);\n    if (pair[0] === \"Par\") {\n      return reduce(body(pair[1].val0, pair[1].val1), names);\n    } else {\n      return Prj(nam0, nam1, pair, (x,y) => weak_reduce(body(x,y), names_ext(nam0, names_ext(nam1, names))), eras);\n    }\n  };\n  const log = (msge, expr, names) => {\n    var msge = reduce(msge, names);\n    var expr = reduce(expr, names);\n    if (opts.logging) {\n      var nams = names_arr(names).reverse();\n    }\n    console.log(show(quote(msge, 0), names || []));\n    return expr;\n  };\n  const unquote = (term, vars, names) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return vars[term.index] || Var(vars.length - term.index - 1);\n      case \"Typ\": return Typ();\n      case \"Tid\": return Tid(unquote(term.expr, vars));\n      case \"All\": return All(term.name, unquote(term.bind, vars), x => unquote(term.body, [x].concat(vars)), term.eras);\n      case \"Lam\": return Lam(term.name, term.bind && unquote(term.bind, vars), x => unquote(term.body, [x].concat(vars)), term.eras);\n      case \"App\": return App(unquote(term.func, vars), unquote(term.argm, vars), term.eras);\n      case \"Box\": return Box(unquote(term.expr, vars));\n      case \"Put\": return Put(unquote(term.expr, vars));\n      case \"Tak\": return Tak(unquote(term.expr, vars));\n      case \"Dup\": return Dup(term.name, unquote(term.expr, vars), x => unquote(term.body, [x].concat(vars)));\n      case \"Wrd\": return Wrd();\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return Op1(term.func, unquote(term.num0, vars), unquote(term.num1, vars));\n      case \"Op2\": return Op2(term.func, unquote(term.num0, vars), unquote(term.num1, vars));\n      case \"Ite\": return Ite(unquote(term.cond, vars), unquote(term.pair, vars));\n      case \"Cpy\": return Cpy(term.name, unquote(term.numb, vars), x => unquote(term.body, [x].concat(vars)));\n      case \"Sig\": return Sig(term.name, unquote(term.typ0, vars), x => unquote(term.typ1, [x].concat(vars)), term.eras);\n      case \"Par\": return Par(unquote(term.val0, vars), unquote(term.val1, vars), term.eras);\n      case \"Fst\": return Fst(unquote(term.pair, vars), term.eras);\n      case \"Snd\": return Snd(unquote(term.pair, vars), term.eras);\n      case \"Prj\": return Prj(term.nam0, term.nam1, unquote(term.pair, vars), (x,y) => unquote(term.body, [y,x].concat(vars)), term.eras);\n      case \"Eql\": return Eql(unquote(term.val0, vars), unquote(term.val1, vars));\n      case \"Rfl\": return Rfl(unquote(term.expr, vars));\n      case \"Sym\": return Sym(unquote(term.prof, vars));\n      case \"Rwt\": return Rwt(term.name, unquote(term.type, vars), unquote(term.prof, vars), unquote(term.expr, vars));\n      case \"Slf\": return Slf(term.name, x => unquote(term.type, [x].concat(vars)));\n      case \"New\": return New(unquote(term.type, vars), unquote(term.expr, vars));\n      case \"Use\": return Use(unquote(term.expr, vars));\n      case \"Ann\": return Ann(unquote(term.type, vars), unquote(term.expr, vars), term.done);\n      case \"Log\": return Log(unquote(term.msge, vars), unquote(term.expr, vars));\n      case \"Ref\": return Ref(term.name, term.eras);\n    }\n  };\n  const reduce = (term, names = null) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return Var(term.index);\n      case \"Typ\": return Typ();\n      case \"Tid\": return reduce(term.expr, names);\n      case \"All\": return All(term.name, weak_reduce(term.bind, names), x => weak_reduce(term.body(x), names_ext(term.name, names)), term.eras);\n      case \"Lam\": return Lam(term.name, term.bind && weak_reduce(term.bind, names), x => weak_reduce(term.body(x), names_ext(term.name, names)), term.eras);\n      case \"App\": return apply(term.func, term.argm, term.eras, names);\n      case \"Box\": return Box(weak_reduce(term.expr, names));\n      case \"Put\": return opts.unbox ? reduce(term.expr, names) : Put(weak_reduce(term.expr, names));\n      case \"Tak\": return opts.unbox ? reduce(term.expr, names) : take(weak_reduce(term.expr, names), names);\n      case \"Dup\": return opts.unbox ? reduce(term.body(term.expr), names) : duplicate(term.name, term.expr, term.body, names);\n      case \"Wrd\": return Wrd();\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return op1(term.func, term.num0, term.num1, names);\n      case \"Op2\": return op2(term.func, term.num0, term.num1, names);\n      case \"Ite\": return if_then_else(term.cond, term.pair, names);\n      case \"Cpy\": return copy(term.name, term.numb, term.body, names);\n      case \"Sig\": return Sig(term.name, weak_reduce(term.typ0, names), x => weak_reduce(term.typ1(x), names_ext(term.name, names)), term.eras);\n      case \"Par\": return Par(weak_reduce(term.val0, names), weak_reduce(term.val1, names), term.eras);\n      case \"Fst\": return first(term.pair, term.eras, names);\n      case \"Snd\": return second(term.pair, term.eras, names);\n      case \"Prj\": return project(term.nam0, term.nam1, term.pair, term.body, term.eras, names);\n      case \"Eql\": return Eql(weak_reduce(term.val0, names), weak_reduce(term.val1, names));\n      case \"Rfl\": return Rfl(weak_reduce(term.expr, names));\n      case \"Sym\": return reduce(term.prof, names);\n      case \"Rwt\": return reduce(term.expr, names);\n      case \"Slf\": return Slf(term.name, x => weak_reduce(term.type(x), names_ext(term.name, names)));\n      case \"New\": return reduce(term.expr, names);\n      case \"Use\": return reduce(term.expr, names);\n      case \"Ann\": return reduce(term.expr, names);\n      case \"Log\": return log(term.msge, term.expr, names);\n      case \"Ref\": return dereference(term.name, term.eras, names);\n    }\n  };\n  const weak_reduce = (term, names) => {\n    return opts.weak ? term : reduce(term, names);\n  };\n  const quote = (term, depth) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return Var(depth - 1 - term.index);\n      case \"Typ\": return Typ();\n      case \"Tid\": return Tid(quote(term.expr, depth));\n      case \"All\": return All(term.name, quote(term.bind, depth), quote(term.body(Var(depth)), depth + 1), term.eras);\n      case \"Lam\": return Lam(term.name, term.bind && quote(term.bind, depth), quote(term.body(Var(depth)), depth + 1), term.eras);\n      case \"App\": return App(quote(term.func, depth), quote(term.argm, depth), term.eras);\n      case \"Box\": return Box(quote(term.expr, depth));\n      case \"Put\": return Put(quote(term.expr, depth));\n      case \"Tak\": return Tak(quote(term.expr, depth));\n      case \"Dup\": return Dup(term.name, quote(term.expr, depth), quote(term.body(Var(depth)), depth + 1));\n      case \"Wrd\": return Wrd();\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return Op1(term.func, quote(term.num0, depth), quote(term.num1, depth));\n      case \"Op2\": return Op2(term.func, quote(term.num0, depth), quote(term.num1, depth));\n      case \"Ite\": return Ite(quote(term.cond, depth), quote(term.pair, depth));\n      case \"Cpy\": return Cpy(term.name, quote(term.numb, depth), quote(term.body(Var(depth)), depth + 1));\n      case \"Sig\": return Sig(term.name, quote(term.typ0, depth), quote(term.typ1(Var(depth)), depth + 1), term.eras);\n      case \"Par\": return Par(quote(term.val0, depth), quote(term.val1, depth), term.eras);\n      case \"Fst\": return Fst(quote(term.pair, depth), term.eras);\n      case \"Snd\": return Snd(quote(term.pair, depth), term.eras);\n      case \"Prj\": return Prj(term.nam0, term.nam1, quote(term.pair, depth), quote(term.body(Var(depth), Var(depth + 1)), depth + 2), term.eras);\n      case \"Eql\": return Eql(quote(term.val0, depth), quote(term.val1, depth));\n      case \"Rfl\": return Rfl(quote(term.expr, depth));\n      case \"Sym\": return Sym(quote(term.prof, depth));\n      case \"Rwt\": return Rwt(term.name, quote(term.type, depth + 1), quote(term.prof, depth), quote(term.expr, depth));\n      case \"Slf\": return Slf(term.name, quote(term.type(Var(depth)), depth + 1));\n      case \"New\": return New(quote(term.type, depth), quote(term.expr, depth));\n      case \"Use\": return Use(quote(term.expr, depth));\n      case \"Ann\": return Ann(quote(term.type, depth), quote(term.expr, depth), term.done);\n      case \"Log\": return Log(quote(term.msge, depth), quote(term.expr, depth));\n      case \"Ref\": return Ref(term.name, term.eras);\n    }\n  };\n  MEMO = false;\n  var unquoted = unquote(term, []);\n  var reduced = reduce(unquoted);\n  MEMO = true;\n  var quoted = quote(reduced, 0);\n  return quoted;\n}\n\nconst erase = (term) => {\n  var [ctor, term] = term;\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index);\n    case \"Typ\":\n      return Typ();\n    case \"Tid\":\n      return erase(term.expr);\n    case \"All\":\n      return All(term.name, erase(term.bind), erase(term.body), term.eras);\n    case \"Lam\":\n      if (term.eras) {\n        return erase(subst(term.body, Put(Num(0)), 0));\n      } else {\n        return Lam(term.name, null, erase(term.body), term.eras);\n      }\n    case \"App\":\n      if (term.eras) {\n        return erase(term.func);\n      } else {\n        return App(erase(term.func), erase(term.argm), term.eras);\n      }\n    case \"Box\":\n      return Box(erase(term.expr));\n    case \"Put\":\n      return Put(erase(term.expr));\n    case \"Tak\":\n      return Tak(erase(term.expr));\n    case \"Dup\":\n      return Dup(term.name, erase(term.expr), erase(term.body));\n    case \"Wrd\":\n      return Wrd();\n    case \"Num\":\n      return Num(term.numb);\n    case \"Op1\":\n      return Op1(term.func, erase(term.num0), erase(term.num1));\n    case \"Op2\":\n      return Op2(term.func, erase(term.num0), erase(term.num1));\n    case \"Ite\":\n      return Ite(erase(term.cond), erase(term.pair));\n    case \"Cpy\":\n      return Cpy(term.name, erase(term.numb), erase(term.body));\n    case \"Sig\":\n      return Sig(term.name, erase(term.typ0), erase(term.typ1), term.eras);\n    case \"Par\":\n      if (term.eras === 1) {\n        return erase(term.val1);\n      } else if (term.eras === 2) {\n        return erase(term.val0);\n      } else {\n        return Par(erase(term.val0), erase(term.val1), term.eras);\n      }\n    case \"Fst\":\n      if (term.eras === 1) {\n        return Put(Num(0));\n      } else if (term.eras === 2) {\n        return erase(term.pair);\n      } else {\n        return Fst(erase(term.pair), term.eras);\n      }\n    case \"Snd\":\n      if (term.eras === 1) {\n        return erase(term.pair);\n      } else if (term.eras === 2) {\n        return Put(Num(0));\n      } else {\n        return Snd(erase(term.pair), term.eras);\n      }\n    case \"Prj\":\n      if (term.eras === 1) {\n        return erase(subst_many(term.body, [Num(7), erase(term.pair)], 0));\n      } else if (term.eras === 2) {\n        return erase(subst_many(term.body, [erase(term.pair), Num(7)], 0));\n      } else {\n        return Prj(term.nam0, term.nam1, erase(term.pair), erase(term.body), term.eras);\n      }\n    case \"Eql\":\n      return Eql(erase(term.val0), erase(term.val1));\n    case \"Rfl\":\n      return Put(Num(0));\n    case \"Sym\":\n      return Put(Num(0));\n    case \"Rwt\":\n      return erase(term.expr);\n    case \"Slf\":\n      return Slf(term.name, erase(term.type));\n    case \"New\":\n      return erase(term.expr);\n    case \"Use\":\n      return erase(term.expr);\n    case \"Ann\":\n      return erase(term.expr);\n    case \"Log\":\n      return Log(erase(term.msge), erase(term.expr));\n    case \"Ref\":\n      return Ref(term.name, true);\n  }\n}\n\n// ::::::::::::::\n// :: Equality ::\n// ::::::::::::::\n\nconst equal = (a, b, defs) => {\n  const Eqs = (a, b)    => [\"Eqs\", {a, b}];\n  const Bop = (v, x, y) => [\"Bop\", {v, x, y}];\n  const And = (x,y)     => Bop(false, x, y);\n  const Or  = (x,y)     => Bop(true, x, y);\n  const Val = (v)       => [\"Val\", {v}];\n\n  const step = (node) => {\n    switch (node[0]) {\n      // An equality test\n      case \"Eqs\":\n        var {a, b} = node[1];\n\n        // Gets whnfs with and without dereferencing\n        // Note: can't use weak:true because it won't give opportunity to eta...\n        var ax = norm(a, {}, {weak: true, undup: true});\n        var bx = norm(b, {}, {weak: true, undup: true});\n        var ay = norm(a, defs, {weak: true, undup: true});\n        var by = norm(b, defs, {weak: true, undup: true});\n\n        // Optimization: if hashes are equal, then a == b prematurely\n        if (a[2] === b[2] || ax[2] === bx[2] || ay[2] === by[2]) {\n          return Val(true);\n        }\n\n        // If non-deref whnfs are app and fields are equal, then a == b\n        var x = null;\n        if (ax[0] === \"Ref\" && bx[0] === \"Ref\" && ax[1].name === bx[1].name) {\n          x = Val(true);\n        } else if (ax[0] === \"App\" && bx[0] === \"App\") {\n          var func = Eqs(ax[1].func, bx[1].func);\n          var argm = Eqs(ax[1].argm, bx[1].argm);\n          x = Bop(false, func, argm);\n        }\n\n        // If whnfs are equal and fields are equal, then a == b\n        var y = null;\n        switch (ay[0] + \"-\" + by[0]) {\n          case \"Var-Var\": y = Val(ay[1].index === by[1].index); break;\n          case \"Typ-Typ\": y = Val(true); break;\n          case \"Tid-Tid\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"All-All\": y = And(And(Eqs(ay[1].bind, by[1].bind), Eqs(ay[1].body, by[1].body)), Val(ay[1].eras === by[1].eras)); break;\n          case \"Lam-Lam\": y = And(Eqs(ay[1].body, by[1].body), Val(ay[1].eras === by[1].eras)); break;\n          case \"App-App\": y = And(And(Eqs(ay[1].func, by[1].func), Eqs(ay[1].argm, by[1].argm)), Val(ay[1].eras === by[1].eras)); break;\n          case \"Box-Box\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Put-Put\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Tak-Tak\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Dup-Dup\": y = And(Eqs(ay[1].expr, by[1].expr), Eqs(ay[1].body, by[1].body)); break;\n          case \"Wrd-Wrd\": y = Val(true); break;\n          case \"Num-Num\": y = Val(ay[1].numb === by[1].numb); break;\n          case \"Op1-Op1\": y = And(Val(ay[1].func === by[1].func), And(Eqs(ay[1].num0, by[1].num0), Val(ay[1].num1[1].numb === ay[1].num1[1].numb))); break;\n          case \"Op2-Op2\": y = And(Val(ay[1].func === by[1].func), And(Eqs(ay[1].num0, by[1].num0), Eqs(ay[1].num1, by[1].num1))); break;\n          case \"Ite-Ite\": y = And(Eqs(ay[1].cond, by[1].cond), Eqs(ay[1].pair, by[1].pair)); break;\n          case \"Cpy-Cpy\": y = And(Eqs(ay[1].numb, by[1].numb), Eqs(ay[1].body, by[1].body)); break;\n          case \"Sig-Sig\": y = And(Eqs(ay[1].typ0, by[1].typ0), Eqs(ay[1].typ1, by[1].typ1)); break;\n          case \"Par-Par\": y = And(Eqs(ay[1].val0, by[1].val0), Eqs(ay[1].val1, by[1].val1)); break;\n          case \"Fst-Fst\": y = And(Eqs(ay[1].pair, by[1].pair), Val(ay[1].eras === by[1].eras)); break;\n          case \"Snd-Snd\": y = And(Eqs(ay[1].pair, by[1].pair), Val(ay[1].eras === by[1].eras)); break;\n          case \"Prj-Prj\": y = And(Eqs(ay[1].pair, by[1].pair), Eqs(ay[1].body, by[1].body)); break;\n          case \"Eql-Eql\": y = And(Eqs(ay[1].val0, by[1].val0), Eqs(ay[1].val1, by[1].val1)); break;\n          case \"Rfl-Rfl\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Sym-Sym\": y = Eqs(ay[1].prof, by[1].prof); break;\n          case \"Rwt-Rwt\": y = And(And(Eqs(ay[1].prof, by[1].prof), Eqs(ay[1].type, by[1].type)), Eqs(ay[1].expr, by[1].expr)); break;\n          case \"Slf-Slf\": y = Eqs(ay[1].type, by[1].type); break;\n          case \"New-New\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Use-Use\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Log-Log\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Ann-Ann\": y = Eqs(ay[1].expr, by[1].expr); break;\n          default:        y = Val(false); break;\n        }\n\n        return x ? Bop(true, x, y) : y;\n\n      // A binary operation (or / and)\n      case \"Bop\":\n        var {v, x, y} = node[1];\n        if (x[0] === \"Val\") {\n          return x[1].v === v ? Val(v) : y;\n        } else if (y[0] === \"Val\") {\n          return y[1].v === v ? Val(v) : x;\n        } else {\n          var X = step(x);\n          var Y = step(y);\n          return Bop(v, X, Y);\n        }\n\n      // A result value (true / false)\n      case \"Val\":\n        return node;\n    }\n  }\n\n  // Expands the search tree until it finds an answer\n  var tree = Eqs(erase(a), erase(b));\n  while (tree[0] !== \"Val\") {\n    var tree = step(tree);\n  }\n  return tree[1].v;\n}\n\n\n// ::::::::::::::::::::\n// :: Stratification ::\n// ::::::::::::::::::::\n\n// How many times a variable was used in computational positions\nconst uses = ([ctor, term], depth = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index === depth ? 1 : 0;\n    case \"Typ\": return 0;\n    case \"Tid\": return 0;\n    case \"All\": return 0;\n    case \"Lam\": return uses(term.body, depth + 1);\n    case \"App\": return uses(term.func, depth) + (term.eras ? 0 : uses(term.argm, depth));\n    case \"Box\": return 0;\n    case \"Put\": return uses(term.expr, depth);\n    case \"Tak\": return uses(term.expr, depth);\n    case \"Dup\": return uses(term.expr, depth) + uses(term.body, depth + 1);\n    case \"Wrd\": return 0;\n    case \"Num\": return 0;\n    case \"Op1\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Op2\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Ite\": return uses(term.cond, depth) + uses(term.pair, depth);\n    case \"Cpy\": return uses(term.numb, depth) + uses(term.body, depth + 1);\n    case \"Sig\": return 0;\n    case \"Par\": return (term.eras === 1 ? 0 : uses(term.val0, depth)) + (term.eras === 2 ? 0 : uses(term.val1, depth));\n    case \"Fst\": return uses(term.pair, depth);\n    case \"Snd\": return uses(term.pair, depth);\n    case \"Prj\": return uses(term.pair, depth) + uses(term.body, depth + 2);\n    case \"Eql\": return 0;\n    case \"Rfl\": return uses(term.expr, depth);\n    case \"Sym\": return 0;\n    case \"Rwt\": return 0;\n    case \"Slf\": return 0;\n    case \"New\": return uses(term.expr, depth);\n    case \"Use\": return uses(term.expr, depth);\n    case \"Ann\": return uses(term.expr, depth);\n    case \"Log\": return uses(term.expr, depth);\n    case \"Ref\": return 0;\n  }\n}\n\n// Checks if variable only occurs at a specific relative level\nconst is_at_level = ([ctor, term], at_level, depth = 0, level = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index !== depth || level === at_level;\n    case \"Typ\": return true;\n    case \"Tid\": return true;\n    case \"All\": return true;\n    case \"Lam\": return is_at_level(term.body, at_level, depth + 1, level);\n    case \"App\": return is_at_level(term.func, at_level, depth, level) && (term.eras ? true : is_at_level(term.argm, at_level, depth, level));\n    case \"Box\": return true;\n    case \"Put\": return is_at_level(term.expr, at_level, depth, level + 1);\n    case \"Tak\": return false;\n    case \"Dup\": return is_at_level(term.expr, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Wrd\": return true;\n    case \"Num\": return true;\n    case \"Op1\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Op2\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Ite\": return is_at_level(term.cond, at_level, depth, level) && is_at_level(term.pair, at_level, depth, level);\n    case \"Cpy\": return is_at_level(term.numb, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Sig\": return true;\n    case \"Par\": return (term.eras === 1 || is_at_level(term.val0, at_level, depth, level)) && (term.eras === 2 || is_at_level(term.val1, at_level, depth, level));\n    case \"Fst\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Snd\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Prj\": return is_at_level(term.pair, at_level, depth, level) && is_at_level(term.body, at_level, depth + 2, level);\n    case \"Ann\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Pri\": return is_at_level(term.argm, at_level, depth, level);\n    case \"Eql\": return true;\n    case \"Rfl\": return true;\n    case \"Sym\": return true;\n    case \"Rwt\": return true;\n    case \"Slf\": return true;\n    case \"New\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Use\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Log\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Ref\": return true;\n  }\n}\n\n// Checks if a term is stratified\nconst boxcheck = (term, defs = {}, ctx = []) => {\n  const check = ([ctor, term], defs = {}, ctx = [], seen = {}) => {\n    switch (ctor) {\n      case \"All\":\n        break;\n      case \"Lam\":\n        if (uses(term.body) > 1) {\n          throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used more than once in:\\n\" + show([ctor, term], ctx);\n        }\n        if (!is_at_level(term.body, 0)) {\n          throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used inside a box in:\\n\" + show([ctor, term], ctx);\n        }\n        check(term.body, defs, ctx.concat([term.name]), seen);\n        break;\n      case \"App\":\n        check(term.func, defs, ctx, seen);\n        if (!term.eras) {\n          check(term.argm, defs, ctx, seen);\n        }\n        break;\n      case \"Box\":\n        break;\n      case \"Put\":\n        check(term.expr, defs, ctx, seen);\n        break;\n      case \"Tak\":\n        check(term.expr, defs, ctx, seen);\n        break;\n      case \"Dup\":\n        if (!is_at_level(term.body, 1)) {\n          throw \"[ERROR]\\nDuplication variable `\" + term.name + \"` must always have exactly 1 enclosing box on the body of:\\n\" + show([ctor, term], ctx);\n        }\n        check(term.expr, defs, ctx, seen);\n        check(term.body, defs, ctx.concat([term.name]), seen);\n        break;\n      case \"Op1\":\n      case \"Op2\":\n        check(term.num0, defs, ctx, seen);\n        check(term.num1, defs, ctx, seen);\n        break;\n      case \"Ite\":\n        check(term.cond, defs, ctx, seen);\n        check(term.pair, defs, ctx, seen);\n        break;\n      case \"Cpy\":\n        check(term.numb, defs, ctx, seen);\n        check(term.body, defs, ctx.concat([term.name]), seen);\n        break;\n      case \"Sig\":\n        break;\n      case \"Par\":\n        if (term.eras !== 1) check(term.val0, defs, ctx, seen);\n        if (term.eras !== 2) check(term.val1, defs, ctx, seen);\n        break;\n      case \"Fst\":\n        check(term.pair, defs, ctx, seen);\n        break;\n      case \"Snd\":\n        check(term.pair, defs, ctx, seen);\n        break;\n      case \"Prj\":\n        var uses0 = uses(term.body, 1);\n        var uses1 = uses(term.body, 0);\n        var isat0 = is_at_level(term.body, 0, 1);\n        var isat1 = is_at_level(term.body, 0, 0);\n        if (uses0 > 1 || uses1 > 1) {\n          throw \"[ERROR]\\nProjection variable `\" + (uses0 > 1 ? term.nam0 : term.nam1) + \"` used more than once in:\\n\" + show([ctor, term], ctx);\n        }\n        if (!isat0 || !isat1) {\n          throw \"[ERROR]\\nProjection variable `\" + (!isat0 ? term.nam0 : term.nam1) + \"` used inside a box in:\\n\" + show([ctor, term], ctx);\n        }\n        check(term.pair, defs, ctx, seen);\n        check(term.body, defs, ctx.concat([term.nam0, term.nam1]), seen);\n        break;\n      case \"Eql\":\n        break;\n      case \"Rfl\":\n        break;\n      case \"Sym\":\n        break;\n      case \"Rwt\":\n        break;\n      case \"Ann\":\n        check(term.expr, defs, ctx, seen);\n        break;\n      case \"Slf\":\n        break;\n      case \"New\":\n        check(term.expr, defs, ctx, seen);\n        break;\n      case \"Use\":\n        check(term.expr, defs, ctx, seen);\n        break;\n      case \"Log\":\n        check(term.expr, defs, ctx, seen);\n        break;\n      case \"Ref\":\n        if (!defs[term.name]) {\n          throw \"[ERROR]\\nUndefined reference: `\" + term.name + \"`.\";\n        } else if (!seen[term.name]) {\n          check(defs[term.name], defs, ctx, {...seen, [term.name]: true});\n          break;\n        } else if (seen[term.name]) {\n          throw \"[ERROR]\\nRecursive occurrence of '\" + term.name + \"' in a computational position.\";\n          break;\n        }\n    }\n  };\n  return check(term, defs, ctx);\n}\n\n// :::::::::::::::::::\n// :: Type Checking ::\n// :::::::::::::::::::\n\nconst PADR = (len, chr, str) => {\n  while (str.length < len) {\n    str += chr;\n  }\n  return str;\n};\n\nconst CODE = (str)  => {\n  return \"\\x1b[2m\" + str + \"\\x1b[0m\";\n};\n\nconst DENON = (a, defs) => {\n  return norm(erase(a), defs);\n};\n\nconst ctx_new = null;\n\nconst ctx_ext = (name, type, ctx) => {\n  return {name, type, rest: ctx};\n};\n\nconst ctx_get = (i, ctx) => {\n  if (i < 0) return null;\n  for (var k = 0; k < i; ++k) {\n    if (!ctx.rest) return null;\n    ctx = ctx.rest;\n  }\n  return [ctx.name, shift(ctx.type, i + 1, 0)];\n};\n\nconst ctx_str = (ctx, defs) => {\n  var txt = [];\n  var idx = 0;\n  var max_len = 0;\n  for (var c = ctx; c !== null; c = c.rest) {\n    max_len = Math.max(c.name.length, max_len);\n  }\n  for (var c = ctx; c !== null; c = c.rest) {\n    var name = c.name;\n    var type = c.type;\n    txt.push(\"- \" + PADR(max_len, \" \", c.name) + \" : \" + show(norm(type, {}, {weak: false, unbox: true}), ctx_names(c.rest)));\n  }\n  return txt.reverse().join(\"\\n\");\n};\n\nconst ctx_names = (ctx) => {\n  var names = [];\n  while (ctx !== null) {\n    names.push(ctx.name);\n    ctx = ctx.rest;\n  }\n  return names.reverse();\n};\n\n\nconst typecheck = (term, expect, defs, ctx = ctx_new, inside = null) => {\n  var type_memo = {};\n\n  const typecheck = (term, expect, defs, ctx = ctx_new, inside = null) => {\n    const TERM = (term) => {\n      return CODE(show(term, ctx_names(ctx)));\n    };\n\n    const ERROR = (str)  => {\n      throw \"[ERROR]\\n\" + str\n        + \"\\n- When checking \" + TERM(term)\n        + (inside ? \"\\n- On expression \" + CODE(show(inside[0], ctx_names(inside[1]))) : \"\")\n        //+ (inside ? \"\\n- On expression \" + JSON.stringify(inside[0]) + \" | \" + JSON.stringify(ctx_names(inside[1])) : \"\")\n        + (ctx !== null ? \"\\n- With the following context:\\n\" + ctx_str(ctx, defs) : \"\");\n    };\n\n    const MATCH = (a, b, ctx) => {\n      if (!equal(a, b, defs)) {\n        throw ERROR(\"Type mismatch.\"\n          + \"\\n- Found type... \" + TERM(norm(a, {}, {weak: false, undup: true}))\n          + \"\\n- Instead of... \" + TERM(norm(b, {}, {weak: false, undup: true})));\n      }\n    };\n\n    var expect_nf = expect ? norm(expect, defs, {undup: true, weak: true}) : null;\n    var type;\n    switch (term[0]) {\n      case \"Var\":\n        var name_type = ctx_get(term[1].index, ctx);\n        if (name_type) {\n          type = name_type[1];\n        } else {\n          ERROR(\"Unbound variable.\");\n        }\n        break;\n      case \"Typ\":\n        type = Typ();\n        break;\n      case \"Tid\":\n        var expr_t = typecheck(term[1].expr, null, defs, ctx, [term, ctx]);\n        MATCH(expr_t, Typ(), ctx);\n        type = Typ();\n        break;\n      case \"All\":\n        if (expect_nf && expect_nf[0] !== \"Typ\") {\n          ERROR(\"The annotated type of a forall (\" + TERM(All(\"x\", Ref(\"A\"), Ref(\"B\"), false)) +\") isn't \" + TERM(Typ()) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var bind_t = typecheck(term[1].bind, null, defs, ctx, [term, ctx]);\n        var ex_ctx = ctx_ext(term[1].name, term[1].bind, ctx);\n        var body_t = typecheck(term[1].body, null, defs, ex_ctx, [term, ctx]);\n        MATCH(bind_t, Typ(), ctx);\n        MATCH(body_t, Typ(), ctx);\n        type = Typ();\n        break;\n      case \"Lam\":\n        var bind_v = expect_nf && expect_nf[0] === \"All\" ? expect_nf[1].bind : term[1].bind;\n        if (bind_v === null && expect_nf === null) {\n          ERROR(\"Can't infer non-annotated lambda.\");\n        }\n        if (bind_v === null && expect_nf !== null) {\n          ERROR(\"The annotated type of a lambda (\" + TERM(Lam(\"x\",null,Ref(\"f\"),false)) + \") isn't forall (\" + TERM(All(\"x\", Ref(\"A\"), Ref(\"B\"), false)) + \").\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var ex_ctx = ctx_ext(term[1].name, bind_v, ctx);\n        var body_t = typecheck(term[1].body, expect_nf && expect_nf[0] === \"All\" ? expect_nf[1].body : null, defs, ex_ctx, [term, ctx]);\n        var term_t = All(term[1].name, bind_v, body_t, term[1].eras);\n        if (term_t[1].eras !== term[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        typecheck(term_t, Typ(), defs, ctx, [term, ctx]);\n        type = term_t;\n        break;\n      case \"App\":\n        var func_t = norm(typecheck(term[1].func, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (func_t[0] !== \"All\") {\n          ERROR(\"Attempted to apply a value that isn't a function.\");\n        }\n        typecheck(term[1].argm, func_t[1].bind, defs, ctx, [term, ctx]);\n        if (func_t[1].eras !== term[1].eras) {\n          ERROR(\"Erasure doesn't match.\");\n        }\n        type = subst(func_t[1].body, Ann(func_t[1].bind, term[1].argm, false), 0);\n        break;\n      case \"Box\":\n        if (expect_nf !== null && expect_nf[0] !== \"Typ\") {\n          ERROR(\"The annotated type of a box (\" + TERM(Box(Ref(\"A\"))) + \") isn't \" + TERM(Typ()) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var expr_t = norm(typecheck(term[1].expr, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        MATCH(expr_t, Typ(), ctx);\n        type = Typ();\n        break;\n      case \"Put\":\n        if (expect_nf !== null && expect_nf[0] !== \"Box\") {\n          ERROR(\"The annotated type of a put (\" + TERM(Put(Ref(\"x\"))) + \") isn't a box (\" + TERM(Box(Ref(\"A\"))) + \").\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var expr_t = expect_nf && expect_nf[0] === \"Box\" ? expect_nf[1].expr : null;\n        var term_t = typecheck(term[1].expr, expr_t, defs, ctx, [term, ctx]);\n        type = Box(term_t);\n        break;\n      case \"Tak\":\n        var expr_t = norm(typecheck(term[1].expr, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (expr_t[0] !== \"Box\") {\n          ERROR(\"Unboxed duplication.\");\n        }\n        type = expr_t[1].expr;\n        break;\n      case \"Dup\":\n        var expr_t = norm(typecheck(term[1].expr, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (expr_t[0] !== \"Box\") {\n          ERROR(\"Unboxed duplication.\");\n        }\n        var unboxd = Tak(term[1].expr);\n        var term_t = typecheck(subst(term[1].body, Tak(term[1].expr), 0), expect_nf, defs, ctx, [term, ctx]);\n        type = term_t;\n        break;\n      case \"Wrd\":\n        type = Typ();\n        break;\n      case \"Num\":\n        type = Wrd();\n        break;\n      case \"Op1\":\n      case \"Op2\":\n        if (expect_nf !== null && expect_nf[0] !== \"Wrd\") {\n          ERROR(\"The annotated type of a numeric operation (\" + TERM(Op2(term[1].func, Ref(\"x\"), Ref(\"y\"))) + \") isn't \" + TERM(Wrd()) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        typecheck(term[1].num0, Wrd(), defs, ctx, [term, ctx]);\n        typecheck(term[1].num1, Wrd(), defs, ctx, [term, ctx]);\n        type = Wrd();\n        break;\n      case \"Ite\":\n        var cond_t = norm(typecheck(term[1].cond, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (cond_t[0] !== \"Wrd\") {\n          ERROR(\"Attempted to use if on a non-numeric value.\");\n        }\n        var pair_t = expect_nf ? Sig(\"x\", expect_nf, shift(expect_nf, 1, 0), 0) : null;\n        var pair_t = norm(typecheck(term[1].pair, pair_t, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (pair_t[0] !== \"Sig\") {\n          ERROR(\"The body of an if must be a pair.\");\n        }\n        var typ0_v = pair_t[1].typ0;\n        var typ1_v = subst(pair_t[1].typ1, Typ(), 0);\n        if (!equal(typ0_v, typ1_v, defs)) {\n          ERROR(\"Both branches of if must have the same type.\");\n        }\n        type = expect_nf || typ0_v;\n        break;\n      case \"Cpy\":\n        var numb_t = norm(typecheck(term[1].numb, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (numb_t[0] !== \"Wrd\") {\n          ERROR(\"Atempted to copy a non-numeric value.\");\n        }\n        type = typecheck(subst(term[1].body, term[1].numb, 0), expect_nf, defs, ctx, [term, ctx]);\n        break;\n      case \"Sig\":\n        if (expect_nf && expect_nf[0] !== \"Typ\") {\n          ERROR(\"The annotated type of a sigma (\" + TERM(Sig(\"x\", Ref(\"A\"), Ref(\"B\"))) + \") isn't \" + TERM(Typ()) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var typ0_t = typecheck(term[1].typ0, null, defs, ctx, [term, ctx]);\n        var ex_ctx = ctx_ext(term[1].name, term[1].typ0, ctx);\n        var typ1_t = typecheck(term[1].typ1, null, defs, ex_ctx, [term, ctx]);\n        MATCH(typ0_t, Typ(), ctx);\n        MATCH(typ1_t, Typ(), ctx);\n        type = Typ();\n        break;\n      case \"Par\":\n        if (expect_nf && expect_nf[0] !== \"Sig\") {\n          ERROR(\"Annotated type of a pair (\" + TERM(Par(Ref(\"a\"),Ref(\"b\"))) + \") isn't \" + TERM(Sig(\"x\", Ref(\"A\"), Ref(\"B\"))) + \".\\n- Annotated type is \" + TERM(norm(expect_nf, defs, {undup: true, weak: true})));\n        }\n        if (expect_nf && expect_nf[1].eras !== term[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        var val0_t = typecheck(term[1].val0, expect_nf && expect_nf[1].typ0, defs, ctx, [term, ctx]);\n        if (expect_nf) {\n          var val1_t = typecheck(term[1].val1, subst(expect_nf[1].typ1, term[1].val0, 0), defs, ctx, [term, ctx]);\n        } else {\n          var val1_t = shift(typecheck(term[1].val1, null, defs, ctx, [term, ctx]), 1, 0);\n        }\n        type = expect_nf || Sig(\"x\", val0_t, val1_t, term[1].eras);\n        break;\n      case \"Fst\":\n        var pair_t = norm(typecheck(term[1].pair, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (pair_t[0] !== \"Sig\") {\n          ERROR(\"Attempted to extract the first element of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        type = pair_t[1].typ0;\n        break;\n      case \"Snd\":\n        var pair_t = norm(typecheck(term[1].pair, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (pair_t[0] !== \"Sig\") {\n          ERROR(\"Attempted to extract the second element of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        type = subst(pair_t[1].typ1, Fst(term[1].pair, term[1].eras), 0);\n        break;\n      case \"Prj\":\n        var pair_t = norm(typecheck(term[1].pair, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (pair_t[0] !== \"Sig\") {\n          ERROR(\"Attempted to project the elements of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        var ex_ctx = ctx_ext(term[1].nam0, pair_t[1].typ0, ctx);\n        var ex_ctx = ctx_ext(term[1].nam1, pair_t[1].typ1, ex_ctx);\n        type = typecheck(term[1].body, null, defs, ex_ctx, [term, ctx]);\n        type = subst(type, Snd(shift(term[1].pair, 1, 0), term[1].eras), 0);\n        type = subst(type, Fst(term[1].pair, term[1].eras), 0);\n        break;\n      case \"Eql\":\n        var val0_t = norm(typecheck(term[1].val0, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        var val1_t = norm(typecheck(term[1].val1, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        MATCH(val0_t, val1_t, ctx);\n        type = Typ();\n        break;\n      case \"Rfl\":\n        type = Eql(term[1].expr, term[1].expr);\n        break;\n      case \"Sym\":\n        var prof_t = norm(typecheck(term[1].prof, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (prof_t[0] !== \"Eql\") {\n          ERROR(\"Attempted to use sym with an invalid equality proof.\");\n        }\n        type = Eql(prof_t[1].val1, prof_t[1].val0);\n        break;\n      case \"Rwt\":\n        var prof_t = norm(typecheck(term[1].prof, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (prof_t[0] !== \"Eql\") {\n          ERROR(\"Attempted to use rwt with an invalid equality proof.\");\n        }\n        var expr_t0 = subst(term[1].type, prof_t[1].val0, 0);\n        var expr_t1 = typecheck(term[1].expr, null, defs, ctx, [term, ctx]);\n        MATCH(expr_t1, expr_t0, ctx);\n        type = subst(term[1].type, prof_t[1].val1, 0);\n        break;\n      case \"Slf\":\n        var ex_ctx = ctx_ext(term[1].name, term, ctx);\n        var type_t = typecheck(term[1].type, null, defs, ex_ctx, [term, ctx]);\n        MATCH(type_t, Typ(), ctx);\n        return Typ();\n      case \"New\":\n        var type = norm(term[1].type, defs, {undup: true, weak: true});\n        if (type[0] !== \"Slf\") {\n          ERROR(\"Attempted to make an instance of a type that isn't self.\");\n        }\n        typecheck(type, null, defs, ctx, [term, ctx]);\n        typecheck(term[1].expr, subst(type[1].type, Ann(type, term, true), 0), defs, ctx, [term, ctx]);\n        type = term[1].type;\n        break;\n      case \"Use\":\n        var expr_t = norm(typecheck(term[1].expr, null, defs, ctx, [term, ctx]), defs, {undup: true, weak: true});\n        if (expr_t[0] !== \"Slf\") {\n          ERROR(\"Attempted to use a value that isn't a self type.\");\n        }\n        type = subst(expr_t[1].type, term[1].expr, 0);\n        break;\n      case \"Ann\":\n        if (!term[1].done) {\n          term[1].done = true;\n          try {\n            typecheck(term[1].expr, term[1].type, defs, ctx, [term, ctx]);\n          } catch (e) {\n            term[1].done = false;\n            throw e;\n          }\n        }\n        type = term[1].type;\n        break;\n      case \"Log\":\n        type = typecheck(term[1].expr, type, defs, ctx, [term, ctx]);\n        break;\n      case \"Ref\":\n        if (!defs[term[1].name]) {\n          ERROR(\"Undefined reference: `\" + term[1].name + \"`.\");\n        } else if (!type_memo[term[1].name]) {\n          type_memo[term[1].name] = typecheck(defs[term[1].name], null, defs, ctx, [term, ctx]);\n        }\n        type = type_memo[term[1].name]\n        break;\n      default:\n        throw \"TODO: type checker for \" + term[0] + \".\";\n    }\n    if (expect) {\n      MATCH(type, expect, ctx);\n    }\n    return type;\n  };\n\n  return typecheck(term, expect, defs, ctx, inside);\n};\n\nmodule.exports = {\n  Var,\n  Typ,\n  Tid,\n  All,\n  Lam,\n  App,\n  Box,\n  Put,\n  Tak,\n  Dup,\n  Wrd,\n  Num,\n  Op1,\n  Op2,\n  Ite,\n  Cpy,\n  Sig,\n  Par,\n  Fst,\n  Snd,\n  Prj,\n  Eql,\n  Rfl,\n  Sym,\n  Rwt,\n  Slf,\n  New,\n  Use,\n  Ann,\n  Log,\n  Ref,\n  show,\n  shift,\n  subst,\n  subst_many,\n  norm,\n  erase,\n  equal,\n  uses,\n  boxcheck,\n  typecheck,\n  ctx_new,\n  ctx_ext,\n  ctx_get,\n  ctx_str,\n  ctx_names,\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/src/fm-core.js?");

/***/ }),

/***/ "../Formality-JavaScript/src/fm-lang.js":
/*!**********************************************!*\
  !*** ../Formality-JavaScript/src/fm-lang.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Parser for Formality-Lang. This is essentially a pack of syntax-sugars that\n// are converted to FM-Core terms. This file is substantially less elegant than\n// the others. Be warned!\n\nconst {\n  Var,\n  Typ,\n  Tid,\n  All,\n  Lam,\n  App,\n  Box,\n  Put,\n  Tak,\n  Dup,\n  Wrd,\n  Num,\n  Op1,\n  Op2,\n  Ite,\n  Cpy,\n  Sig,\n  Par,\n  Fst,\n  Snd,\n  Prj,\n  Eql,\n  Rfl,\n  Sym,\n  Rwt,\n  Slf,\n  New,\n  Use,\n  Ann,\n  Log,\n  Ref,\n  show,\n  shift,\n  subst,\n  subst_many,\n  norm,\n  erase,\n  equal,\n  uses,\n  boxcheck,\n  typecheck,\n  ctx_new,\n  ctx_ext,\n  ctx_get,\n  ctx_str,\n  ctx_names,\n} = __webpack_require__(/*! ./fm-core.js */ \"../Formality-JavaScript/src/fm-core.js\");\n\n// Usng eval prevents being catched by Webpack\nconst fs = typeof window === \"object\" ? null : eval('require(\"fs\")');\nconst ls = typeof window === \"object\" ? window.localStorage : null;\nconst path = typeof window === \"object\" ? null : eval('require(\"path\")');\nconst xhr = __webpack_require__(/*! xhr-request-promise */ \"../Formality-JavaScript/node_modules/xhr-request-promise/index.js\");\nconst version = __webpack_require__(/*! ./../package.json */ \"../Formality-JavaScript/package.json\").version;\n\n// :::::::::::::\n// :: Parsing ::\n// :::::::::::::\n\n// Converts a string to a term\nconst parse = async (file, code, tokenify, root = true, loaded = {}) => {\n  var init_parse = Date.now();\n\n  async function do_import(import_file) {\n    if (import_file.indexOf(\"@\") === -1) {\n      local_imports[import_file] = true;\n    }\n    if (!loaded[import_file]) {\n      var file_code = await load_file(import_file);\n      loaded[import_file] = await parse(import_file, file_code, tokenify, false, loaded);\n    }\n    var {defs: file_defs\n      , unbx: file_unbx\n      , adts: file_adts\n      , open_imports: file_open_imports\n      } = loaded[import_file];\n    for (let term_path in file_defs) {\n      defs[term_path] = file_defs[term_path];\n    }\n    for (let term_path in file_unbx) {\n      unbx[term_path] = file_unbx[term_path];\n    }\n    for (let term_path in file_adts) {\n      adts[term_path] = file_adts[term_path];\n    }\n    for (let open_import in file_open_imports) {\n      open_imports[open_import] = true;\n    }\n    return true;\n  }\n\n  function ref_path(str) {\n    var result = (function () {\n      if (str.indexOf(\"/\") === -1) {\n        var [str_file, str_name] = [null, str];\n      } else {\n        var [str_file, str_name] = str.split(\"/\");\n      }\n      if (!str_file && defs[file + \"/\" + str_name]) {\n        return file + \"/\" + str_name;\n      }\n      if (qual_imports[str_file]) {\n        return qual_imports[str_file] + \"/\" + str_name;\n      }\n      if (!str_file) {\n        for (var open_import in open_imports) {\n          if (defs[open_import + \"/\" + str_name]) {\n            return open_import + \"/\" + str_name;\n          }\n        }\n      }\n      return str_file ? str_file + \"/\" + str_name : file + \"/\" + str_name;\n    })();\n    return result;\n  }\n\n  function ref(str) {\n    return Ref(ref_path(str));\n  }\n\n  function base_ref(str) {\n    var path = ref_path(str);\n    if (defs[path]) {\n      return Ref(path);\n    } else {\n      error(\"Attempted to use a syntax-sugar which requires `\" + str + \"` to be in scope, but it isn't.\\n\"\n          + \"To solve that, add `import Base@0 open` to the start of your file.\\n\"\n          + \"See http://docs.formality-lang.org/en/latest/language/Hello,-world!.html for more info.\");\n    }\n  }\n\n  function build_charset(chars) {\n    var set = {};\n    for (var i = 0; i < chars.length; ++i) {\n      set[chars[i]] = 1;\n    }\n    return chr => set[chr] === 1;\n  }\n\n  var is_native_op = {\"+\":1,\"-\":1,\"*\":1,\"/\":1,\"%\":1,\"^\":1,\"**\":1,\".&\":1,\".|\":1,\".^\":1,\".!\":1,\".>>\":1,\".<<\":1,\".>\":1,\".<\":1,\".=\":1};\n  var op_inits     = \"+-*/%^.=\";\n  var is_op_init   = build_charset(\"+-*/%^.=\");\n  var is_name_char = build_charset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-@/\");\n  var is_op_char   = build_charset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-@+*/%^!<>=&|\");\n  var is_space     = build_charset(\" \\t\\n\\r;\");\n  var is_newline   = build_charset(\"\\n\");\n\n  function next() {\n    if (tokens) {\n      tokens[tokens.length - 1][1] += code[idx];\n    }\n    if (is_newline(code[idx])) {\n      row += 1;\n      col = 0;\n    } else {\n      col += 1;\n    }\n    idx += 1;\n  }\n\n  function skip_spaces() {\n    while (idx < code.length && is_space(code[idx])) {\n      next();\n    }\n  }\n\n  function next_char() {\n    skip_spaces();\n    while (code.slice(idx, idx + 2) === \"//\") {\n      if (tokens) tokens.push([\"cmm\", \"\"]);\n      while (code[idx] !== \"\\n\" && idx < code.length) {\n        next();\n      }\n      if (tokens) tokens.push([\"txt\", \"\"]);\n      skip_spaces();\n    }\n  }\n\n  function match_here(string) {\n    if (code.slice(idx, idx + 2) === \"//\") {\n      return false;\n    } else {\n      var sliced = code.slice(idx, idx + string.length);\n      if (sliced === string) {\n        if (tokens) tokens.push([\"sym\", \"\"]);\n        for (var i = 0; i < string.length; ++i) {\n          next();\n        }\n        if (tokens) tokens.push([\"txt\", \"\"]);\n        return true;\n      }\n      return false;\n    }\n  }\n\n  function match(string) {\n    next_char();\n    return match_here(string);\n  }\n\n  function is_sigma(string) {\n    var i = idx;\n    while (i < code.length && code[i] === \"~\" || is_name_char(code[i])) { ++i; }\n    while (i < code.length && is_space(code[i])) { ++i; }\n    return code[i] === \":\";\n  }\n\n  function error(error_message) {\n    var part = \"\";\n    var text = \"\";\n    text += \"[PARSE-ERROR]\\n\";\n    text += error_message;\n    text += \"\\n\\nI noticed the problem on line \" + (row+1) + \", col \" + col + \":\\n\";\n    for (var ini = idx, il = 0; il < 7 && ini >=          0; --ini) if (code[ini] === \"\\n\") ++il;\n    for (var end = idx, el = 0; el < 6 && end < code.length; ++end) if (code[end] === \"\\n\") ++el;\n    part += \"\\x1b[31m\" + code.slice(ini+1, idx) + \"\\x1b[4m\" + (code[idx]||\"\") + \"\\x1b[0m\\x1b[31m\" + code.slice(idx + 1, end) + \"\\x1b[0m\";\n    text += part.split(\"\\n\").map((line,i) => {\n      return (i === 7 ? \"\\x1b[31m\" : \"\\x1b[2m\") + (\"    \" + (row-il+i+1)).slice(-4) + \"| \" + line + \"\\x1b[0m\";\n    }).join(\"\\n\");\n    text += \"\\nBut it could have happened a little earlier.\";\n    var excuses = [\n      \"My parse-robot brain isn't perfect, sorry.\",\n      \"What? If you can't get this right, don't expect me to!\",\n      \"Like you, I'm doing my best, ok?\",\n      \"I hope you figure it out!\",\n      \"I can't help any further. But I can pray for you!\",\n      \"I could be more precise, but unlike you, I'm not good enough.\",\n      \"Hey, at least I'm showing a location. I'm looking at you, type-checker...\",\n      \"Why programming needs to be so hard?\",\n      \"I hope this doesn't affect your deadlines!\",\n      \"If this is hard, consider relaxing. You deserve it!\",\n      \"It takes me some time to process things. Have patience with me!\"\n    ];\n    text += \"\\n\" + excuses[Math.floor(Math.random() * excuses.length)];\n    throw text;\n  }\n\n  function build_ind(name) {\n    var numb = name === \"\" ? Math.pow(2,48) - 1 : Number(name);\n    var bits = numb.toString(2);\n    var bits = bits === \"0\" ? \"\" : bits;\n    var term = base_ref(\"base\");\n    for (var i = 0; i < bits.length; ++i) {\n      term = App(base_ref(\"twice\"), term, false);\n      if (bits[i] === \"1\") {\n        term = App(base_ref(\"step\"), term, false);\n      }\n    }\n    return term;\n  }\n\n  function parse_exact(string) {\n    if (!match(string)) {\n      var text = \"\";\n      var part = \"\";\n      error(\"Expected '\" + string + \"', but found '\" + (code[idx] || \"(end of file)\") + \"' instead.\");\n    }\n  }\n\n  function parse_string_here(fn = is_name_char) {\n    var name = \"\";\n    while (idx < code.length && fn(code[idx])) {\n      name = name + code[idx];\n      next();\n    }\n    return name;\n  }\n\n  function parse_string(fn = is_name_char) {\n    next_char();\n    return parse_string_here(fn);\n  }\n\n  function parse_name() {\n    if (is_op_init(code[idx])) {\n      match(code[idx]);\n      return code[idx - 1] + parse_string_here(is_op_char);\n    } else {\n      return parse_string();\n    }\n  }\n\n  function parse_var(nams, ind_num = false) {\n    var term = null;\n    if (tokens) tokens.push([\"???\", \"\"]);\n    var name = parse_name();\n    var numb = Number(name);\n    if (!isNaN(numb)) {\n      term = ind_num ? build_ind(name) : Num(numb >>> 0);\n      if (tokens) tokens[tokens.length - 1][0] = \"num\";\n    } else {\n      var skip = 0;\n      while (match_here(\"^\")) {\n        skip += 1;\n      }\n      for (var i = nams.length - 1; i >= 0; --i) {\n        if (nams[i] === name) {\n          if (skip === 0) break;\n          else skip -= 1;\n        }\n      }\n      if (i === -1) {\n        if (is_native_op[name]) {\n          term = Lam(\"x\", Wrd(), Lam(\"y\", Wrd(), Op2(name, Var(1), Var(0)), false), false);\n          if (tokens) tokens[tokens.length - 1][0] = \"nop\";\n        } else {\n          for (var mini in enlarge) {\n            if (name.slice(0, mini.length) === mini) {\n              var name = enlarge[mini] + name.slice(mini.length);\n              break;\n            }\n          }\n          term = Ref(ref_path(name), false);\n          if (tokens) {\n            tokens[tokens.length - 1][0] = \"ref\";\n            tokens[tokens.length - 1][2] = term[1].name;\n          }\n        }\n      } else {\n        term = Var(nams.length - i - 1);\n        if (tokens) tokens[tokens.length - 1][0] = \"var\";\n      }\n    }\n    if (tokens) tokens.push([\"txt\", \"\"]);\n    return term;\n  }\n\n  function parse_term(nams) {\n    var parsed;\n\n    // Parenthesis\n    if (match(\"(\")) {\n      var term = parse_term(nams);\n      var skip = parse_exact(\")\");\n      parsed = term;\n    }\n\n    // Type\n    else if (match(\"Type\")) {\n      parsed = Typ();\n    }\n\n    // Type\n    else if (match(\"type(\")) {\n      var expr = parse_term(nams);\n      var skip = parse_exact(\")\");\n      parsed = Tid(expr);\n    }\n\n    // Prints active definitions\n    else if (match(\"?scope?\")) {\n      console.log(\"Scope:\");\n      for (var i = 0; i < nams.length; ++i) {\n        console.log(\"- \" + nams[i]);\n      }\n      parsed = parse_term(nams);\n    }\n\n    // Hole\n    else if (match(\"?\")) {\n      parsed = Num(0); // TODO: a proper HOLE constructor\n    }\n\n    // Lambdas and Forall\n    else if (match(\"{\")) {\n      var erass = [];\n      var names = [];\n      var types = [];\n      while (idx < code.length) {\n        erass.push(match(\"~\"));\n        names.push(parse_string());\n        types.push(match(\":\") ? parse_term(nams.concat(names.slice(0,-1))) : null);\n        if (match(\"}\")) break; else parse_exact(\",\");\n      }\n      var isall = match(\"->\");\n      var islam = match(\"=>\");\n      if (!isall && !islam) {\n        // TODO: error\n      }\n      var term = parse_term(nams.concat(names));\n      for (var i = names.length - 1; i >= 0; --i) {\n        var ctr = isall ? All : Lam;\n        term = ctr(names[i], types[i], term, erass[i]);\n        if (isall && !types[i]) {\n          error(\"Parse error: invalid forall.\");\n        }\n      }\n      parsed = term;\n    }\n\n    // Duplication\n    else if (match(\"dup \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var expr = parse_term(nams);\n      var body = parse_term(nams.concat([name]));\n      parsed = Dup(name, expr, body);\n    }\n\n    // Box\n    else if (match(\"!\")) {\n      var expr = parse_term(nams);\n      parsed = Box(expr);\n    }\n\n    // Put\n    else if (match(\"#\")) {\n      var expr = parse_term(nams);\n      parsed = Put(expr);\n    }\n\n    // Take\n    else if (match(\"<\")) {\n      var expr = parse_term(nams);\n      var skip = parse_exact(\">\");\n      parsed = Tak(expr);\n    }\n\n    // Let\n    else if (match(\"let \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var copy = parse_term(nams);\n      var body = parse_term(nams.concat([name]));\n      parsed = subst(body, copy, 0);\n    }\n\n    // Wrd\n    else if (match(\"Word\")) {\n      parsed = Wrd();\n    }\n\n    // String\n    else if (match(\"\\\"\")) {\n      // Parses text\n      var text = \"\";\n      while (code[idx] !== \"\\\"\") {\n        text += code[idx];\n        next();\n      }\n      next();\n      var bytes = [].slice.call(new TextEncoder(\"utf-8\").encode(text), 0);\n      while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n      }\n      var nums = new Uint32Array(new Uint8Array(bytes).buffer);\n      var term = App(base_ref(\"nil\"), Wrd(), true);\n      for (var i = nums.length - 1; i >= 0; --i) {\n        var term = App(App(App(base_ref(\"cons\"), Wrd(), true), Num(nums[i]), false), term, false);\n      }\n      parsed = Ann(base_ref(\"String\"), term);\n    }\n\n    // Nat\n    else if (match(\"0n\")) {\n      var name = parse_string();\n      var numb = Number(name);\n      var term = base_ref(\"zero\");\n      for (var i = 0; i < numb; ++i) {\n        term = App(base_ref(\"succ\"), term, false);\n      }\n      parsed = term;\n    }\n\n    // Ind\n    else if (match(\"*\")) {\n      var name = parse_string();\n      parsed = build_ind(name);\n    }\n\n    // If-Then-Else\n    else if (match(\"if \")) {\n      var cond = parse_term(nams);\n      var skip = match(\"then:\") || parse_exact(\":\");\n      var val0 = parse_term(nams);\n      var skip = parse_exact(\"else:\");\n      var val1 = parse_term(nams);\n      parsed = Ite(cond, Par(val0, val1, 0));\n    }\n\n    // Copy\n    else if (match(\"cpy \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var numb = parse_term(nams);\n      var body = parse_term(nams.concat([name]));\n      parsed = Cpy(name, numb, body);\n    }\n\n    // Sigma / Pair\n    else if (match(\"[\")) {\n      // Sigma\n      if (is_sigma()) {\n        var era1 = match(\"~\");\n        var name = parse_string();\n        var skip = parse_exact(\":\");\n        var typ0 = parse_term(nams);\n        var skip = parse_exact(\",\");\n        var era2 = match(\"~\");\n        var typ1 = parse_term(nams.concat([name]));\n        var skip = parse_exact(\"]\");\n        parsed = Sig(name, typ0, typ1, era1 ? 1 : era2 ? 2 : 0);\n      // Pair\n      } else {\n        var era1 = match(\"~\");\n        var val0 = parse_term(nams);\n        var skip = parse_exact(\",\");\n        var era2 = match(\"~\");\n        var val1 = parse_term(nams);\n        var skip = parse_exact(\"]\");\n        parsed = Par(val0, val1, era1 ? 1 : era2 ? 2 : 0);\n      }\n    }\n\n    // First\n    else if (match(\"fst(\")) {\n      var pair = parse_term(nams);\n      var skip = parse_exact(\")\");\n      parsed = Fst(pair, 0);\n    }\n\n    // First (erased)\n    else if (match(\"~fst(\")) {\n      var pair = parse_term(nams);\n      var skip = parse_exact(\")\");\n      parsed = Fst(pair, 2);\n    }\n\n    // Second\n    else if (match(\"snd(\")) {\n      var pair = parse_term(nams);\n      var skip = parse_exact(\")\");\n      parsed = Snd(pair, 0);\n    }\n\n    // Second (erased)\n    else if (match(\"~snd(\")) {\n      var pair = parse_term(nams);\n      var skip = parse_exact(\")\");\n      parsed = Snd(pair, 1);\n    }\n\n    // Projection\n    else if (match(\"get \")) {\n      var skip = parse_exact(\"[\");\n      var era1 = match(\"~\");\n      var nam0 = parse_string();\n      var skip = parse_exact(\",\");\n      var era2 = match(\"~\");\n      var nam1 = parse_string();\n      var skip = parse_exact(\"]\");\n      var skip = parse_exact(\"=\");\n      var pair = parse_term(nams);\n      var body = parse_term(nams.concat([nam0, nam1]));\n      parsed = Prj(nam0, nam1, pair, body, era1 ? 1 : era2 ? 2 : 0);\n    }\n\n    // Reflexivity\n    else if (match(\"refl(~\")) {\n      var expr = parse_term(nams);\n      var skip = parse_exact(\")\");\n      parsed = Rfl(expr);\n    }\n\n    // Symmetry\n    else if (match(\"sym(~\")) {\n      var prof = parse_term(nams);\n      var skip = parse_exact(\")\");\n      parsed = Sym(prof);\n    }\n\n    // Annotation\n    else if (match(\":\")) {\n      var type = parse_term(nams);\n      var expr = parse_term(nams);\n      parsed = Ann(type, expr, false);\n    }\n\n    // Logging\n    else if (match(\"log(\")) {\n      var msge = parse_term(nams);\n      var skip = parse_exact(\")\");\n      var expr = parse_term(nams);\n      parsed = Log(msge, expr);\n    }\n\n    // Slf\n    else if (match(\"$\")) {\n      var name = parse_string();\n      var type = parse_term(nams.concat([name]));\n      parsed = Slf(name, type);\n    }\n\n    // New\n    else if (match(\"new(~\")) {\n      var type = parse_term(nams);\n      var skip = parse_exact(\")\");\n      var expr = parse_term(nams);\n      parsed = New(type, expr);\n    }\n\n    // Use\n    else if (match(\"%\")) {\n      var expr = parse_term(nams);\n      parsed = Use(expr);\n    }\n\n    // Case syntax sugar\n    else if (match(\"case/\")) {\n      var adt_name = parse_string();\n      var term = parse_term(nams);\n      if (!adt_name || !adts[ref_path(adt_name)]) {\n        error(\"Used case-syntax on undefined type `\" + (adt_name || \"?\") + \"`.\");\n      }\n      var {adt_name, adt_pram, adt_indx, adt_ctor} = adts[ref_path(adt_name)];\n\n      var cses = [];\n      for (var c = 0; c < adt_ctor.length; ++c) {\n        var skip = parse_exact(\"|\");\n        var skip = parse_exact(adt_ctor[c][0]);\n        var skip = parse_exact(\"=>\");\n        var ctors = adt_ctor[c][1];\n        cses[c] = parse_term(nams.concat(adt_ctor[c][1].map(([name,type]) => name)));\n        for (var i = 0; i < ctors.length; ++i) {\n          cses[c] = Lam(ctors[ctors.length - i - 1][0], null, cses[c], ctors[ctors.length - i - 1][2]);\n        }\n      }\n\n      var skip = parse_exact(\":\");\n      var moti = parse_term(nams.concat(adt_indx.map(([name,type]) => name)).concat([\"self\"]));\n      for (var i = 0; i < adt_indx.length; ++i) {\n        var moti = Lam(adt_indx[i][0], null, moti, false);\n      }\n      var moti = Lam(\"self\", null, moti, false);\n\n      var term = Use(term);\n      var term = App(term, moti, true);\n      for (var i = 0; i < cses.length; ++i) {\n        var term = App(term, cses[i], false);\n      }\n\n      parsed = term;\n    }\n\n    // Variable / Reference\n    else {\n      parsed = parse_var(nams, false);\n    }\n\n    // Apply to Ind\n    if (match_here(\"*\")) {\n      var term = parse_var(nams, true);\n      parsed = App(parsed, term, false);\n    }\n\n    // Applications\n    var applier = null;\n    while ((applier = code[idx]), applier === \"(\") {\n      var skip = match_here(applier);\n      var term = parsed;\n      while (idx < code.length) {\n        var eras = match(\"~\");\n        var argm = parse_term(nams);\n        var term = App(term, argm, eras);\n        if (match(\")\")) break;\n        parse_exact(\",\");\n      }\n      parsed = term;\n    }\n\n    // List\n    while (match_here(\"$\")) {\n      var type = parsed;\n      var list = [];\n      var skip = parse_exact(\"[\");\n      while (idx < code.length && !match(\"]\")) {\n        list.push(parse_term(nams));\n        if (match(\"]\")) break; else parse_exact(\",\");\n      }\n      var term = App(base_ref(\"nil\"), type, true);\n      for (var i = list.length - 1; i >= 0; --i) {\n        var term = App(App(App(base_ref(\"cons\"), type, true), list[i], false), term, false);\n      }\n      parsed = term;\n    }\n\n    // Rewrite\n    if (match_here(\" ::\")) {\n      var skip = parse_exact(\"rewrite\");\n      var name = parse_string();\n      var skip = parse_exact(\"in\");\n      var type = parse_term(nams.concat([name]));\n      var skip = parse_exact(\"with\");\n      var prof = parse_term(nams);\n      parsed = Rwt(name, type, prof, parsed);\n    }\n\n    // Operators\n    while (match_here(\" \")) {\n      var matched = false;\n      for (var i = 0; i < op_inits.length; ++i) {\n        var op_init = op_inits[i];\n        if (match_here(op_init)) {\n          matched = true;\n          if (tokens) tokens.pop();\n          var func = op_init + parse_string_here(x => !is_space(x));\n          if (tokens) tokens.push([\"txt\", \"\"]);\n          var argm = parse_term(nams);\n          if (is_native_op[func]) {\n            parsed = Op2(func, parsed, argm);\n          } else if (func === \"->\") {\n            parsed = All(\"\", parsed, shift(argm, 1, 0), false);\n          } else if (func === \"==\") {\n            parsed = Eql(parsed, argm);\n          } else {\n            parsed = App(App(ref(func), parsed, false), argm, false);\n          }\n        }\n        if (matched) break;\n      }\n    }\n\n    return parsed;\n  }\n\n  var open_imports = {};\n  var qual_imports = {};\n  var local_imports = {};\n  var file_version = {};\n  var tokens = tokenify ? [[\"txt\",\"\"]] : null;\n  var idx = 0;\n  var row = 0;\n  var col = 0;\n  var defs = {};\n  var adts = {};\n  var unbx = {};\n  var enlarge = {};\n  while (idx < code.length) {\n    next_char();\n\n    // Shorten\n    if (match(\"alias\")) {\n      var full = parse_string();\n      var skip = parse_exact(\"as\");\n      var mini = parse_string();\n      enlarge[mini] = full;\n\n    // Import\n    } else if (match(\"import\")) {\n      var impf = parse_string();\n      var qual = match(\"as\") ? parse_string() : null;\n      var open = match(\"open\");\n      qual_imports[qual || impf] = impf;\n      if (open) {\n        open_imports[impf] = true;\n      }\n      await do_import(impf);\n\n    // Datatypes\n    } else if (match(\"T \")) {\n      var adt_pram = [];\n      var adt_indx = [];\n      var adt_ctor = [];\n      var adt_name = parse_string();\n      var adt_nams = [adt_name];\n      var adt_typs = [null];\n\n      // Datatype parameters\n      if (match(\"{\")) {\n        while (idx < code.length) {\n          var eras = false;\n          var name = parse_string();\n          var skip = parse_exact(\":\");\n          var type = await parse_term(adt_pram.map((([name,type]) => name)));\n          adt_pram.push([name, type, eras]);\n          if (match(\"}\")) break; else parse_exact(\",\");\n        }\n      }\n\n      // Datatype indices\n      var adt_nams = adt_nams.concat(adt_pram.map(([name,type]) => name));\n      var adt_typs = adt_typs.concat(adt_pram.map(([name,type]) => type));\n      if (match(\"(\")) {\n        while (idx < code.length) {\n          //var eras = match(\"~\");\n          var eras = false;\n          var name = parse_string();\n          var skip = parse_exact(\":\");\n          var type = await parse_term(adt_nams.concat(adt_indx.map((([name,type]) => name))));\n          adt_indx.push([name, type, eras]);\n          if (match(\")\")) break; else parse_exact(\",\");\n        }\n      }\n\n      // Datatype constructors\n      while (match(\"|\")) {\n        // Constructor name\n        var ctor_name = parse_string();\n        // Constructor fields\n        var ctor_flds = [];\n        if (match(\"{\")) {\n          while (idx < code.length) {\n            var eras = match(\"~\");\n            var name = parse_string();\n            var skip = parse_exact(\":\");\n            var type = await parse_term(adt_nams.concat(ctor_flds.map(([name,type]) => name)));\n            ctor_flds.push([name, type, eras]);\n            if (match(\"}\")) break; else parse_exact(\",\");\n          }\n        }\n        // Constructor type (written)\n        if (match(\":\")) {\n          var ctor_type = await parse_term(adt_nams.concat(ctor_flds.map(([name,type]) => name)));\n        // Constructor type (auto-filled)\n        } else {\n          var ctor_indx = [];\n          if (match(\"(\")) {\n            while (idx < code.length) {\n              ctor_indx.push(await parse_term(adt_nams.concat(ctor_flds.map(([name,type]) => name))));\n              if (match(\")\")) break; else parse_exact(\",\");\n            }\n          }\n          var ctor_type = Var(-1 + ctor_flds.length + adt_pram.length + 1);\n          for (var p = 0; p < adt_pram.length; ++p) {\n            ctor_type = App(ctor_type, Var(-1 + ctor_flds.length + adt_pram.length - p), false);\n          }\n          for (var i = 0; i < ctor_indx.length; ++i) {\n            ctor_type = App(ctor_type, ctor_indx[i], false);\n          }\n        }\n        adt_ctor.push([ctor_name, ctor_flds, ctor_type]);\n      }\n      var adt = {adt_pram, adt_indx, adt_ctor, adt_name};\n      defs[file+\"/\"+adt_name] = derive_adt_type(file, adt);\n      for (var c = 0; c < adt_ctor.length; ++c) {\n        defs[file+\"/\"+adt_ctor[c][0]] = derive_adt_ctor(file, adt, c);\n      }\n      adts[file+\"/\"+adt_name] = adt;\n\n    // Prints active definitions\n    } else if (match(\"?defs\")) {\n      var filt = match(\"/\") ? parse_string(x => x !== \"/\") : \"\";\n      var regx = new RegExp(filt, \"i\");\n      console.log(\"Definitions:\");\n      for (var def in defs) {\n        if (def[0] !== \"$\" && regx.test(def)) {\n          console.log(\"- \" + def);\n        }\n      }\n      parsed = parse_term([]);\n\n    // Definitions or end-of-file\n    } else {\n      // Parses box annotation\n      var boxed = match(\"!\");\n\n      // Parses definition name\n      if (tokens) tokens.push([\"def\", \"\"]);\n      var name = parse_name();\n      if (tokens) tokens[tokens.length - 1][2] = file+\"/\"+name;\n      if (tokens) tokens.push([\"txt\", \"\"]);\n\n      // If name is empty, stop\n      if (name.length === 0) break;\n\n      // Parses recursion depth name\n      var recur     = match_here(\"*\");\n      var rec_depth = recur ? parse_string() : null;\n      var rec_idx_n = recur ? [rec_depth] : [];\n      var rec_names = recur ? [name] : [];\n\n      var typed = match(\":\");\n\n      // Typed definition\n      if (typed) {\n\n        // Parses level 0 argument names and types\n        var lv0_erass = [];\n        var lv0_names = [];\n        var lv0_boxed = [];\n        var lv0_dup_n = [];\n        var lv0_dup_t = [];\n        var lv0_dup_i = [];\n        var lv0_types = [];\n        if (boxed && match(\"{\")) {\n          var count = 0;\n          while (idx < code.length) {\n            var arg_eras = match(\"~\");\n            var arg_name = parse_string();\n            var arg_skip = parse_exact(\":\");\n            var arg_boxd = match(\"!\");\n            var arg_type = await parse_term(lv0_names);\n            lv0_erass.push(arg_eras);\n            lv0_names.push(arg_name);\n            lv0_boxed.push(arg_boxd);\n            if (arg_boxd) {\n              lv0_dup_n.push(arg_name);\n              lv0_dup_t.push(null);\n              lv0_dup_i.push(count);\n            }\n            lv0_types.push(arg_type);\n            if (match(\"}\")) break; else parse_exact(\",\");\n            ++count;\n          }\n          var skip = parse_exact(\"->\");\n        }\n\n        // Parses extra level_0 duplications\n        var lv0_imp_n = [];\n        var lv0_imp_t = [];\n        var lv0_imp_v = [];\n        while (match(\"dup \")) {\n          var dup_name = parse_string();\n          var dup_skip = parse_exact(\"=\");\n          var dup_expr = parse_term(lv0_names.concat(lv0_imp_n));\n          lv0_imp_n.push(dup_name);\n          lv0_imp_t.push(null);\n          lv0_imp_v.push(dup_expr);\n        }\n\n        // Checks if it is properly boxed\n        if ((recur || boxed) && !match(\"!\")) {\n          error((recur ? \"Recursive definition\" : \"Definition\") + \" `\" + name + \"` must be boxed. Annotate its type with a `!`.\");\n        }\n\n        // Parses argument names and types\n        var erass = [];\n        var names = [];\n        var projs = [];\n        var keeps = [];\n        var wordn = [];\n        var wordt = [];\n        var wordi = [];\n        var types = [];\n        var basex = null;\n        if (match(\"{\")) {\n          var count = 0;\n          while (idx < code.length) {\n            var arg_proj = match(\"case \");\n            var arg_eras = match(\"~\");\n            var arg_halt = match(\"*\");\n            var arg_name = parse_string();\n            var arg_skip = parse_exact(\":\");\n            var arg_type = await parse_term(lv0_names.concat(lv0_dup_n).concat(lv0_imp_n).concat(rec_idx_n).concat(names));\n            erass.push(arg_eras);\n            names.push(arg_name);\n            types.push(arg_type);\n            basex = arg_halt ? count : basex;\n            if (arg_proj) {\n              projs.push(count);\n            } else if (!arg_eras) {\n              keeps.push(count);\n            }\n            if (arg_type[0] === \"Wrd\") {\n              wordn.push(arg_name);\n              wordt.push(Wrd());\n              wordi.push(count);\n            };\n            if (match(\"}\")) break; else parse_exact(\",\");\n            ++count;\n          }\n          var skip = parse_exact(\"->\");\n        }\n        var type = await parse_term(lv0_names.concat(lv0_dup_n).concat(lv0_imp_n).concat(rec_idx_n).concat(names));\n\n        // Parses the definition body\n        var body_nams = lv0_names.concat(lv0_dup_n).concat(lv0_imp_n).concat(rec_idx_n).concat(rec_names).concat(names);\n\n        // Case-tree syntax\n        if (projs.length > 0) {\n\n          // Finds the ADTs from annotated types\n          var proj_adts = [];\n          for (var i = 0; i < projs.length; ++i) {\n            var proj_type = types[projs[i]];\n            while (proj_type[0] === \"App\") {\n              proj_type = erase(proj_type[1].func);\n            }\n            var adt_name = proj_type[0] === \"Ref\" ? ref_path(proj_type[1].name) : null;\n            if (adts[adt_name]) {\n              proj_adts[i] = adts[adt_name];\n            } else {\n              error(\"Couldn't find the datatype of the `\" + names[projs[i]] + \"` argument of the `\" + name + \"` function.\\n\"\n                  + \"This is a language limitation. Consider removing type alises, or using the case expression instead.\");\n            }\n          }\n\n          // Builds the objects for each proj\n          var proj_names = [];\n          var proj_terms = [];\n          var proj_types = [];\n          var proj_infos = [];\n          for (var i = 0; i < projs.length; ++i) {\n            proj_infos[i] = {\n              name: names[projs[i]],\n              orig: Var(-1 + names.length - projs[i]),\n              term: Var(-1 + names.length - projs[i]),\n              type: shift(types[projs[i]], names.length - projs[i], 0),\n              adt: proj_adts[i]\n            };\n          }\n\n          // Builds the objects for each keep\n          var keep_infos = [];\n          if (recur) {\n            var moti_type = ref(name + \".moti\");\n            for (var i = 0; i < lv0_names.length; ++i) {\n              var moti_type = App(moti_type, Var(-1 + names.length + rec_names.length + rec_idx_n.length + lv0_imp_n.length + lv0_dup_n.length + lv0_names.length - i), false);\n            }\n            var moti_type = App(moti_type, Var(-1 + names.length + rec_names.length + rec_idx_n.length), false);\n            keep_infos.push({\n              name: name,\n              orig: Var(-1 + names.length + rec_names.length),\n              term: Var(-1 + names.length + rec_names.length),\n              type: moti_type\n            });\n          }\n          for (var i = 0; i < keeps.length; ++i) {\n            keep_infos[i] = {\n              name: names[keeps[i]],\n              orig: Var(-1 + names.length - keeps[i]),\n              term: Var(-1 + names.length - keeps[i]),\n              type: shift(types[keeps[i]], names.length - keeps[i], 0)\n            };\n          }\n\n          // Builds the initial motive\n          var moti = type;\n          var moti = shift(moti, rec_idx_n.length, names.length); // Adds recur variable\n          if (recur) { // Adjusts recur index to step(n)\n            var moti = replace(names.length + rec_names.length + rec_idx_n.length - 1, App(ref(\"step\"), Var(names.length + 1), false), moti);\n          }\n\n          // Builds the case-tree by matching projected terms\n          var term = await (async function parse_case_tree(idx, projs, keeps, moti, branch, nams) {\n            // We still have values to project\n            if (idx < projs.length) {\n\n              // Gets the projected dataype\n              var {adt_name, adt_pram, adt_indx, adt_ctor} = projs[idx].adt;\n              if (adt_indx.length > 0) {\n                error(\"The case-tree syntax isn't compatible with the indexed datatype '\" + adt_name + \"' yet.\"\n                    + \"Use the @ syntax to write the '\" + name + \"' function instead.\");\n              }\n\n              // Builds the application motive\n              var term_moti = shift(moti, adt_indx.length + 1 + projs.length - (idx + 1) + keeps.length, 0);\n              for (var i = keeps.length - 1; i >= 0; --i) {\n                var term_moti = All(keeps[i].name, shift(keeps[i].type, 1 + projs.length - (idx + 1) + i, 0), term_moti, false);\n              }\n              for (var i = projs.length - 1; i > idx; --i) {\n                var term_moti = replace(projs[i].orig[1].index + 1 + i - (idx + 1) + 1, Var(0), term_moti);\n                var term_moti = All(projs[i].name, shift(projs[i].type, 1 + i - (idx + 1), 0), term_moti, false);\n              }\n              var term_moti = replace(projs[i].orig[1].index + 1, Var(0), term_moti);\n              var term_moti = Lam(\"self\", null, term_moti, false);\n\n              // Builds the application term\n              var term = Use(projs[idx].term);\n              var term = App(term, term_moti, true);\n\n              // Builds each applied case\n              for (var ctor_n = 0; ctor_n < adt_ctor.length; ++ctor_n) {\n                // Adjusts scope to enter case\n                var fldn = adt_ctor[ctor_n][1].map((([name,type,eras]) => projs[idx].name + \".\" + name));\n                var fldt = adt_ctor[ctor_n][1].map((([name,type,eras]) => type));\n                var prjn = projs.slice(idx + 1).map(({name}) => name);\n                var kepn = keeps.map(({name}) => name);\n                var newn = [].concat(fldn).concat(prjn).concat(kepn);\n\n                // Adjusts keeps to enter case\n                var new_keeps = [];\n                for (var i = 0; i < keeps.length; ++i) {\n                  new_keeps.push({\n                    name: keeps[i].name,\n                    term: Var(-1 + keeps.length - i),\n                    orig: shift(keeps[i].orig, newn.length, 0),\n                    type: shift(keeps[i].type, newn.length, 0)\n                  });\n                }\n\n                // Adjusts projs to enter case\n                var new_projs = [];\n                for (var i = 0; i < projs.length; ++i) {\n                  new_projs.push({\n                    name: projs[i].name,\n                    term: i < idx\n                      ? shift(projs[i].term, newn.length, 0)\n                      : Var(-1 + kepn.length + prjn.length - (i - (idx + 1))),\n                    orig: shift(projs[i].orig, newn.length, 0),\n                    type: shift(projs[i].type, newn.length, 0),\n                    adt: projs[i].adt\n                  });\n                }\n\n                // Builds the substitution list for ADT parameters\n                var adtt = projs[idx].type;\n                var pram = [];\n                while (adtt[0] === \"App\") {\n                  pram.push(adtt[1].argm);\n                  adtt = adtt[1].func;\n                }\n                if (pram.length !== adt_pram.length) {\n                  error(\"Couldn't build parameter list for argument `\" + projs[idx].name + \"` of function `\" + name + \"`.\\n\"\n                      + \"This is a language limitation. Consider removing type alises, or using the case expression instead.\");\n                }\n                var subs = [ref(adt_name)].concat(pram.reverse());\n\n                // Add constructor fields to keeps\n                for (var i = 0; i < fldn.length; ++i) {\n                  var field_type = fldt[i];\n                  var field_type = subst_many(field_type, subs, i);\n                  var field_type = shift(field_type, newn.length, 0);\n                  new_keeps.push({\n                    name: fldn[i],\n                    term: Var(-1 + newn.length - i),\n                    orig: Var(-1 + newn.length - i),\n                    type: field_type\n                  });\n                }\n\n                // Adjusts motive to enter case\n                var new_moti = shift(moti, newn.length, 0);\n\n                // Builds the case body recursively\n                var argm = await parse_case_tree(idx + 1, new_projs, new_keeps, new_moti, branch.concat([ctor_n]), nams.concat(newn));\n\n                // Substitutes the open form of the projected value\n                var self = ref(adt_ctor[ctor_n][0]);\n                for (var i = 0; i < fldn.length; ++i) {\n                  self = App(self, Var(-1 + kepn.length + prjn.length + fldn.length - i), false);\n                }\n                var argm = replace(projs[idx].orig[1].index + newn.length, self, argm);\n\n                // Wraps keeps, projs and field lambdas\n                for (var i = kepn.length - 1; i >= 0; --i) {\n                  argm = Lam(kepn[i], null, argm, false);\n                }\n                for (var i = prjn.length - 1; i >= 0; --i) {\n                  argm = Lam(prjn[i], null, argm, false);\n                }\n                for (var i = fldn.length - 1; i >= 0; --i) {\n                  argm = Lam(fldn[i], null, argm, false);\n                }\n                var term = App(term, argm, false);\n              }\n\n              // Applies term to each proj and keep\n              for (var i = idx + 1; i < projs.length; ++i) {\n                var term = App(term, projs[i].term, false);\n              }\n              for (var i = 0; i < keeps.length; ++i) {\n                var term = App(term, keeps[i].term, false);\n              }\n\n              return term;\n            } else {\n              // Parses the case line\n              var skip = parse_exact(\"|\");\n              for (var i = 0; i < branch.length; ++i) {\n                var skip = parse_exact(projs[i].adt.adt_ctor[branch[i]][0]);\n              }\n              var skip = parse_exact(\"=>\");\n\n              // Parses the case term\n              var term = parse_term(nams);\n\n              return term;\n            }\n          })(0, proj_infos, keep_infos, moti, [], body_nams);\n\n        } else {\n          var term = await parse_term(body_nams.concat(wordn));\n\n          // Fills numeric copies\n          for (var i = wordn.length - 1; i >= 0; --i) {\n            var term = Cpy(wordn[i], Var(-1 + names.length + i - wordi[i]), term);\n          }\n        }\n\n        // Parses the halting case\n        if (recur && basex === null && !match(\"*\")) {\n          error(\"The bounded-recursive (inductive) definition '\" + name + \"' needs a halting (base) case. Provide it using `*`.\");\n        }\n        if (recur && basex !== null) {\n          var base = Var(-1 + names.length - basex);\n        } else if (recur) {\n          var base = await parse_term(lv0_names.concat(lv0_dup_n).concat(lv0_imp_n).concat(names));\n        } else {\n          var base = null;\n        }\n\n        // Fills type wrapper\n        if (type[0] === \"Typ\") {\n          var term = Tid(term);\n        }\n\n        // Fills foralls and lambdas of arguments\n        for (var i = names.length - 1; i >= 0; --i) {\n          var type = All(names[i], types[i], type, erass[i]);\n          var term = Lam(names[i], null    , term, erass[i]);\n          var base = base && Lam(names[i], null    , base, erass[i]);\n        }\n\n        // Aux function to add level 0 headers\n        const lv0_headers = (is_type, term, eras = true) => {\n          for (var i = lv0_imp_n.length - 1; i >= 0; --i) {\n            var term = Dup(lv0_imp_n[i], lv0_imp_v[i], term);\n          }\n          for (var i = lv0_dup_n.length - 1; i >= 0; --i) {\n            var term = Dup(lv0_dup_n[i], Var(-1 + lv0_names.length + i - lv0_dup_i[i]), term);\n          }\n          for (var i = lv0_names.length - 1; i >= 0; --i) {\n            var term = (is_type ? All : Lam)(lv0_names[i], is_type ? (lv0_boxed[i] ? Box : (x=>x))(lv0_types[i]) : null, term, eras && lv0_erass[i]);\n          }\n          return term;\n        }\n\n        // Builds a non-recursive, non-boxed definition\n        if (!recur && !boxed) {\n          defs[file+\"/\"+name] = Ann(type, term, false);\n\n        // Builds a non-recursive, boxed definition\n        } else if (!recur && boxed) {\n          var type = lv0_headers(1, Box(type), true);\n          var term = lv0_headers(0, Put(term), true);\n          defs[file+\"/\"+name] = Ann(type, term, false);\n          unbx[file+\"/\"+name] = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length};\n\n        // Builds a recursive, non-boxed definition\n        } else if (!boxed && recur) {\n          error(\"Bounded-recursive (inductive) definition `\" + name + \"` must be boxed. Add a '!' before its name.\");\n\n        // Builds a recursive, boxed definition\n        } else if (boxed && recur) {\n          // Builds the motive\n          var moti_type = lv0_headers(1, All(rec_depth, base_ref(\"Ind\"), Typ(), false), false);\n          var moti_term = lv0_headers(0, Lam(rec_depth, null, type, false), false);\n\n          // Builds the step case\n          var step_typ0 = type;\n          var step_typ1 = shift(subst(shift(type, 1, 1), App(base_ref(\"step\"), Var(0), false), 0), 1, 0);\n          var step_type = lv0_headers(1, Box(All(rec_depth, base_ref(\"Ind\"), All(name, step_typ0, step_typ1, false), true)), true);\n          var step_term = lv0_headers(0, Put(Lam(rec_depth, null, Lam(name, null, term, false), true)), true);\n\n          // Builds the base case\n          var base_type = lv0_headers(1, Box(subst(type, base_ref(\"base\"), 0)), true);\n          var base_term = lv0_headers(0, Put(base), true);\n\n          // Builds the recursive function\n          var ind_moti = ref(name+\".moti\");\n          var ind_step = ref(name+\".step\");\n          var ind_base = ref(name+\".base\");\n          for (var i = 0, c = 0; i < lv0_names.length; ++i) {\n            if (lv0_boxed[i]) {\n              var vari = Put(Var(-1 + lv0_imp_n.length + lv0_dup_n.length - (c++)));\n            } else {\n              var vari = Var(-1 + lv0_imp_n.length + lv0_dup_n.length + lv0_names.length - i);\n            }\n            ind_moti = App(ind_moti, vari, false);\n            ind_step = App(ind_step, vari, lv0_erass[i]);\n            ind_base = App(ind_base, vari, lv0_erass[i]);\n          }\n          var type = All(rec_depth, base_ref(\"Ind\"), lv0_headers(1, Box(subst(type, Var(lv0_names.length + lv0_dup_n.length + lv0_imp_n.length), 0)), true), false);\n          var term = App(base_ref(\"ind\"), Var(lv0_names.length + lv0_dup_n.length + lv0_imp_n.length), false);\n          var term = App(term, ind_moti, true);\n          var term = App(term, ind_step, false);\n          var term = App(term, ind_base, false);\n          var term = Lam(rec_depth, null, lv0_headers(0, term, true), false);\n\n          defs[file+\"/\"+name+\".moti\"] = Ann(moti_type, moti_term, false);\n          defs[file+\"/\"+name+\".step\"] = Ann(step_type, step_term, false);\n          defs[file+\"/\"+name+\".base\"] = Ann(base_type, base_term, false);\n          defs[file+\"/\"+name]         = Ann(type, term, false);\n          unbx[file+\"/\"+name+\".moti\"] = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length};\n          unbx[file+\"/\"+name+\".step\"] = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length};\n          unbx[file+\"/\"+name+\".base\"] = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length};\n          unbx[file+\"/\"+name]         = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length + 1};\n        }\n\n      // Untyped definition\n      } else {\n        var term = await parse_term([]);\n        defs[file+\"/\"+name] = term;\n      }\n    }\n\n    next_char();\n  }\n\n  // When a reference to a boxed definiton is used inside a boxed definition,\n  // automatically unbox it by appending `dup ref = ref; ...` to the term\n  if (root) {\n    for (var path in unbx) {\n      var info = unbx[path];\n      var term = defs[path];\n      var lens = {term, field: \"expr\"};\n      for (var i = 0; i < info.depth; ++i) {\n        var lens = {term: lens.term[1][lens.field], field: \"body\"};\n      }\n      var unbox = [];\n      lens.term[1][lens.field] = rewrite(lens.term[1][lens.field], (term, scope, erased) => {\n        if (term[0] === \"Tak\" && !erased) {\n          for (var i = 0; i < scope.length; ++i) {\n            term = subst(term, Num(0), 0);\n          }\n          unbox.push([\"k\" + unbox.length, term[1].expr]);\n          return Ref(\"$TMP$\" + (unbox.length - 1));\n        }\n      });\n      for (var i = unbox.length - 1; i >= 0; --i) {\n        lens.term[1][lens.field] = Dup(unbox[i][0], unbox[i][1], shift(lens.term[1][lens.field], 1, 0));\n      }\n      lens.term[1][lens.field] = rewrite(lens.term[1][lens.field], (term, scope) => {\n        if (term[0] === \"Ref\" && term[1].name.slice(0,5) === \"$TMP$\") {\n          return Var(-1 + scope.length - Number(term[1].name.slice(5)));\n        }\n      });\n    }\n  }\n\n  return {defs, adts, unbx, tokens, local_imports, qual_imports, open_imports};\n}\n\n// :::::::::::\n// :: Utils ::\n// :::::::::::\n\n// Generates a name\nconst gen_name = (n) => {\n  var str = \"\";\n  ++n;\n  while (n > 0) {\n    --n;\n    str += String.fromCharCode(97 + n % 26);\n    n = Math.floor(n / 26);\n  }\n  return str;\n};\n\n// Maps defs\nconst replace_refs = ([ctor, term], renamer, depth = 0) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index);\n    case \"Typ\":\n      return Typ();\n    case \"Tid\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Tid(expr);\n    case \"All\":\n      var name = term.name;\n      var bind = replace_refs(term.bind, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 1);\n      var eras = term.eras;\n      return All(name, bind, body, eras);\n    case \"Lam\":\n      var name = term.name;\n      var bind = term.bind && replace_refs(term.bind, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 1);\n      var eras = term.eras;\n      return Lam(name, bind, body, eras);\n    case \"App\":\n      var func = replace_refs(term.func, renamer, depth);\n      var argm = replace_refs(term.argm, renamer, depth);\n      var eras = term.eras;\n      return App(func, argm, term.eras);\n    case \"Box\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Box(expr);\n    case \"Put\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Put(expr);\n    case \"Tak\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Tak(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = replace_refs(term.expr, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 1);\n      return Dup(name, expr, body);\n    case \"Wrd\":\n      return Wrd();\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = replace_refs(term.num0, renamer, depth);\n      var num1 = replace_refs(term.num1, renamer, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = replace_refs(term.cond, renamer, depth);\n      var pair = replace_refs(term.pair, renamer, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = replace_refs(term.numb, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 1);\n      return Cpy(name, numb, body);\n    case \"Sig\":\n      var name = term.name;\n      var typ0 = replace_refs(term.typ0, renamer, depth);\n      var typ1 = replace_refs(term.typ1, renamer, depth + 1);\n      var eras = term.eras;\n      return Sig(name, typ0, typ1, eras);\n    case \"Par\":\n      var val0 = replace_refs(term.val0, renamer, depth);\n      var val1 = replace_refs(term.val1, renamer, depth);\n      var eras = term.eras;\n      return Par(val0, val1, eras);\n    case \"Fst\":\n      var pair = replace_refs(term.pair, renamer, depth);\n      var eras = term.eras;\n      return Fst(pair, eras);\n    case \"Snd\":\n      var pair = replace_refs(term.pair, renamer, depth);\n      var eras = term.eras;\n      return Snd(pair, eras);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = replace_refs(term.pair, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 2);\n      var eras = term.eras;\n      return Prj(nam0, nam1, pair, body, eras);\n    case \"Eql\":\n      var val0 = replace_refs(term.val0, renamer, depth);\n      var val1 = replace_refs(term.val1, renamer, depth);\n      return Eql(val0, val1);\n    case \"Rfl\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Rfl(expr);\n    case \"Sym\":\n      var prof = replace_refs(term.prof, renamer, depth);\n      return Sym(prof);\n    case \"Rwt\":\n      var name = term.name;\n      var type = replace_refs(term.type, renamer, depth + 1);\n      var prof = replace_refs(term.prof, renamer, depth);\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Rwt(name, type, prof, expr);\n    case \"Slf\":\n      var name = term.name;\n      var type = replace_refs(term.type, renamer, depth + 1);\n      return Slf(name, type);\n    case \"New\":\n      var type = replace_refs(term.type, renamer, depth);\n      var expr = replace_refs(term.expr, renamer, depth);\n      return New(type, expr);\n    case \"Use\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Use(expr);\n    case \"Ann\":\n      var type = replace_refs(term.type, renamer, depth);\n      var expr = replace_refs(term.expr, renamer, depth);\n      var done = term.done;\n      return Ann(type, expr, done);\n    case \"Log\":\n      var msge = replace_refs(term.msge, renamer, depth);\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Log(msge, expr);\n    case \"Ref\":\n      var new_name = renamer(term.name, depth);\n      if (typeof new_name === \"string\") {\n        return Ref(new_name, term.eras, term.file);\n      } else if (typeof new_name === \"object\") {\n        return new_name;\n      } else {\n        return Ref(term.name, term.eras, term.file);\n      }\n  }\n}\n\nconst rewrite = ([ctor, term], rewriter, scope = [], erased = false, only_once = false) => {\n  var rewritten = rewriter([ctor, term], scope, erased);\n  if (rewritten) {\n    return only_once ? rewritten : rewrite(rewritten, rewriter, scope, erased, only_once);\n  } else {\n    switch (ctor) {\n      case \"Var\":\n        return Var(term.index);\n      case \"Typ\":\n        return Typ();\n      case \"Tid\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Tid(expr);\n      case \"All\":\n        var name = term.name;\n        var bind = rewrite(term.bind, rewriter, scope, true, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([name]), true, only_once);\n        var eras = term.eras;\n        return All(name, bind, body, eras);\n      case \"Lam\":\n        var name = term.name;\n        var bind = term.bind && rewrite(term.bind, rewriter, scope, true, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([name]), erased, only_once);\n        var eras = term.eras;\n        return Lam(name, bind, body, eras);\n      case \"App\":\n        var func = rewrite(term.func, rewriter, scope, erased, only_once);\n        var argm = rewrite(term.argm, rewriter, scope, term.eras || erased, only_once);\n        var eras = term.eras;\n        return App(func, argm, term.eras);\n      case \"Box\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Box(expr);\n      case \"Put\":\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return Put(expr);\n      case \"Tak\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Tak(expr);\n      case \"Dup\":\n        var name = term.name;\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([name]), erased, only_once);\n        return Dup(name, expr, body);\n      case \"Wrd\":\n        return Wrd();\n      case \"Num\":\n        var numb = term.numb;\n        return Num(numb);\n      case \"Op1\":\n      case \"Op2\":\n        var func = term.func;\n        var num0 = rewrite(term.num0, rewriter, scope, erased, only_once);\n        var num1 = rewrite(term.num1, rewriter, scope, erased, only_once);\n        return Op2(func, num0, num1);\n      case \"Ite\":\n        var cond = rewrite(term.cond, rewriter, scope, erased, only_once);\n        var pair = rewrite(term.pair, rewriter, scope, erased, only_once);\n        return Ite(cond, pair);\n      case \"Cpy\":\n        var name = term.name;\n        var numb = rewrite(term.numb, rewriter, scope, erased, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([name]), erased, only_once);\n        return Cpy(name, numb, body);\n      case \"Sig\":\n        var name = term.name;\n        var typ0 = rewrite(term.typ0, rewriter, scope, true, only_once);\n        var typ1 = rewrite(term.typ1, rewriter, scope.concat([name]), true, only_once);\n        var eras = term.eras;\n        return Sig(name, typ0, typ1, eras);\n      case \"Par\":\n        var val0 = rewrite(term.val0, rewriter, scope, term.eras === 1 || erased, only_once);\n        var val1 = rewrite(term.val1, rewriter, scope, term.eras === 1 || erased, only_once);\n        var eras = term.eras;\n        return Par(val0, val1, eras);\n      case \"Fst\":\n        var pair = rewrite(term.pair, rewriter, scope, erased, only_once);\n        var eras = term.eras;\n        return Fst(pair, eras);\n      case \"Snd\":\n        var pair = rewrite(term.pair, rewriter, scope, erased, only_once);\n        var eras = term.eras;\n        return Snd(pair, eras);\n      case \"Prj\":\n        var nam0 = term.nam0;\n        var nam1 = term.nam1;\n        var pair = rewrite(term.pair, rewriter, scope, erased, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([nam0, nam1]), erased, only_once);\n        var eras = term.eras;\n        return Prj(nam0, nam1, pair, body, eras);\n      case \"Eql\":\n        var val0 = rewrite(term.val0, rewriter, scope, true, only_once);\n        var val1 = rewrite(term.val1, rewriter, scope, true, only_once);\n        return Eql(val0, val1);\n      case \"Rfl\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Rfl(expr);\n      case \"Sym\":\n        var prof = rewrite(term.prof, rewriter, scope, true, only_once);\n        return Sym(prof);\n      case \"Rwt\":\n        var name = term.name;\n        var type = rewrite(term.type, rewriter, scope.concat([name]), true, only_once);\n        var prof = rewrite(term.prof, rewriter, scope, true, only_once);\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return Rwt(name, type, prof, expr);\n      case \"Slf\":\n        var name = term.name;\n        var type = rewrite(term.type, rewriter, scope.concat([name]), true, only_once);\n        return Slf(name, type);\n      case \"New\":\n        var type = rewrite(term.type, rewriter, scope, true, only_once);\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return New(type, expr);\n      case \"Use\":\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return Use(expr);\n      case \"Ann\":\n        var type = rewrite(term.type, rewriter, scope, true, only_once);\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        var done = term.done;\n        return Ann(type, expr, done);\n      case \"Log\":\n        var msge = rewrite(term.msge, rewriter, scope, true, only_once);\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return Log(msge, expr);\n      case \"Ref\":\n        var name = term.name;\n        var eras = term.eras;\n        var file = term.file;\n        return Ref(name, eras, eras || erased, file);\n    }\n  }\n}\n\nconst replace = (idx, val, term) => {\n  var term = shift(term, 1, idx);\n  var term = subst(term, val, idx + 1);\n  return term;\n}\n\n// :::::::::::::::::::\n// :: Syntax Sugars ::\n// :::::::::::::::::::\n\n// Syntax sugars for datatypes. They transform a statement like:\n// \n//   data ADT <p0 : Param0, p1 : Param1...> {i0 : Index0, i1 : Index1}\n//   | ctr0 {ctr_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} : Cr0Type \n//   | ctr1 {ctr_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} : Cr0Type \n//   | ...\n//\n// on its corresponding self-encoded datatype:\n//\n//   def ADT\n//   = {p0 : Param0, p1 : Param1, ..., i0 : Index0, i1 : Index1, ...} =>\n//     : Type\n//     $ self\n//     {~P   : {i0 : Index0, i1 : Index1, ..., wit : (ADT i0 i1...)} -> Type} ->\n//     {ctr0 : {ctr0_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} -> (Ctr0Type[ADT <- P] (ADT.ctr0 Param0 Param1... ctr0_fld0 ctr0_fld1 ...))} ->\n//     {ctr1 : {ctr1_fld0 : Ctr1_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} -> (Ctr0Type[ADT <- P] (ADT.ctr1 Param0 Param1... ctr1_fld1 ctr0_fld1 ...))} ->\n//     ... ->\n//     (P i0 i1... self)\n//  \n//   def ADT.ctr0\n//   = {~p0 : Param0, ~p1 : Param1, ..., ctr0_fld0 : Ctr0_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} =>\n//     : Ctr0Type\n//     @ Ctr0Type\n//       {~P, ctr0, ctr1, ...} => \n//       (ctr0 ctr0_fld0 ctr0_fld1 ...)\n//\n//   (...)\nconst derive_adt_type = (file, {adt_pram, adt_indx, adt_ctor, adt_name}) => {\n  return (function adt_arg(p, i) {\n    // ... {p0 : Param0, p1 : Param1...} ...\n    if (p < adt_pram.length) {\n      return Lam(adt_pram[p][0], adt_pram[p][1], adt_arg(p + 1, i), adt_pram[p][2]);\n    // ... {i0 : Index0, i1 : Index...} ...\n    } else if (i < adt_indx.length) {\n      var substs = [Ref(file+\"/\"+adt_name)];\n      for (var P = 0; P < p; ++P) {\n        substs.push(Var(-1 + i + p - P));\n      }\n      return Lam(adt_indx[i][0], subst_many(adt_indx[i][1], substs, i), adt_arg(p, i + 1), adt_indx[i][2]);\n    } else {\n      return (\n        // ... : Type ...\n        Ann(Typ(),\n        // ... $ self ...\n        Slf(\"self\",\n        // ... P : ...\n        All(\"P\",\n          (function motive(i) {\n            // ... {i0 : Index0, i1 : Index1...} ...\n            if (i < adt_indx.length) {\n              var substs = [Ref(file+\"/\"+adt_name)];\n              for (var P = 0; P < p; ++P) {\n                substs.push(Var(-1 + i + 1 + adt_indx.length + p - P));\n              }\n              return All(adt_indx[i][0], subst_many(adt_indx[i][1], substs, i), motive(i + 1), adt_indx[i][2]);\n            // ... {wit : (ADT i0 i1...)} -> Type ...\n            } else {\n              var wit_t = Ref(file+\"/\"+adt_name);\n              for (var P = 0; P < adt_pram.length; ++P) {\n                wit_t = App(wit_t, Var(-1 + i + 1 + i + adt_pram.length - P), adt_pram[P][2]); \n              }\n              for (var I = 0; I < i; ++I) {\n                wit_t = App(wit_t, Var(-1 + i - I), adt_indx[I][2]);\n              }\n              return All(\"wit\", wit_t, Typ(), false);\n            }\n          })(0),\n        (function ctor(i) {\n          if (i < adt_ctor.length) {\n            // ... ctrX : ...\n            return All(adt_ctor[i][0], (function field(j) {\n              var subst_prams = [];\n              for (var P = 0; P < adt_pram.length; ++P) {\n                subst_prams.push(Var(-1 + j + i + 1 + 1 + adt_indx.length + adt_pram.length - P));\n              }\n              // ... {ctrX_fldX : CtrX_FldX, ctrX_fld1 : CtrX_Fld1, ...} -> ...\n              if (j < adt_ctor[i][1].length) {\n                var sub = [Ref(file+\"/\"+adt_name)].concat(subst_prams);\n                var typ = subst_many(adt_ctor[i][1][j][1], sub, j);\n                return All(adt_ctor[i][1][j][0], typ, field(j + 1), adt_ctor[i][1][j][2]);\n              // ... (CtrXType[ADT <- P] (ADT.ctrX ParamX Param1... ctrX_fldX ctrX_fld1 ...)) -> ...\n              } else {\n                var typ = adt_ctor[i][2];\n                var sub = [Var(-1 + j + i + 1)].concat(subst_prams);\n                var typ = subst_many(adt_ctor[i][2], sub, j);\n                var rem = typ;\n                for (var I = 0; I < adt_indx.length; ++I) {\n                  rem = rem[1].func;\n                }\n                rem[0] = \"Var\";\n                rem[1] = {index: -1 + i + j + 1};\n                var wit = Ref(file+\"/\"+adt_ctor[i][0]);\n                for (var P = 0; P < adt_pram.length; ++P) {\n                  var wit = App(wit, Var(-1 + j + i + 1 + 1 + adt_indx.length + adt_pram.length - P), true);\n                }\n                for (var F = 0; F < adt_ctor[i][1].length; ++F) {\n                  var wit = App(wit, Var(-1 + j - F), adt_ctor[i][1][F][2]);\n                }\n                return App(typ, wit, false);\n              }\n            })(0),\n            ctor(i + 1),\n            false);\n          } else {\n            // ... (P i0 i1... self)\n            var ret = Var(adt_ctor.length + 1 - 1);\n            for (var i = 0; i < adt_indx.length; ++i) {\n              var ret = App(ret, Var(adt_ctor.length + 1 + 1 + adt_indx.length - i - 1), adt_indx[i][2]); \n            }\n            var ret = App(ret, Var(adt_ctor.length + 1 + 1 - 1), false);\n            return ret;\n          }\n        })(0),\n        true))));\n    }\n  })(0, 0);\n}\n\nconst derive_adt_ctor = (file, {adt_pram, adt_indx, adt_ctor, adt_name}, c) => {\n  return (function arg(p, i, f) {\n    var substs = [Ref(file+\"/\"+adt_name)];\n    for (var P = 0; P < p; ++P) {\n      substs.push(Var(-1 + f + p - P));\n    }\n    // {~p0 : Param0, ~p1 : Param1...} ...\n    if (p < adt_pram.length) {\n      return Lam(adt_pram[p][0], adt_pram[p][1], arg(p + 1, i, f), true);\n    // ... {ctr0_fld0 : Ctr0_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} ...\n    } else if (f < adt_ctor[c][1].length) {\n      return Lam(adt_ctor[c][1][f][0], subst_many(adt_ctor[c][1][f][1], substs, f), arg(p, i, f + 1), adt_ctor[c][1][f][2]);\n    } else {\n      var type = subst_many(adt_ctor[c][2], substs, f);\n      // ... : CtrXType {~P} ...\n      return Ann(type, New(type, Lam(\"P\", null, (function opt(k) {\n        // ... {ctr0, ctr1...} ...\n        if (k < adt_ctor.length) {\n          return Lam(adt_ctor[k][0], null, opt(k + 1), false);\n        // (ctrX ctrX_fld0 ctrX_fld1 ...)\n        } else {\n          var sel = Var(-1 + adt_ctor.length - c);\n          for (var F = 0; F < adt_ctor[c][1].length; ++F) {\n            var sel = App(sel, Var(-1 + adt_ctor.length + 1 + adt_ctor[c][1].length - F), adt_ctor[c][1][F][2]);\n          }\n          return sel;\n        }\n      })(0), true)), false);\n    }\n  })(0, adt_indx.length, 0);\n}\n\nconst post = (func, body) => {\n  return xhr(\"http://moonad.org/api/\" + func,\n    { method: \"POST\"\n    , json: true\n    , body})\n    .then(res => {\n      if (res[0] === \"ok\") {\n        return res[1];\n      } else {\n        throw res[1];\n      }\n    });\n};\n\nconst save_file = (file, code) => post(\"save_file\", {file, code});\nconst find_term = (term) => post(\"find_term\", {term});\nconst load_file = (() => {\n  var loading = {};\n  return (file) => {\n    if (!loading[file]) {\n      if (fs) {\n        var cache_dir_path = path.join(process.cwd(), \"fm_modules\");\n        var cached_file_path = path.join(cache_dir_path, file + \".fm\");\n        var local_file_path = path.join(process.cwd(), file + \".fm\");\n      }\n      var has_cached_fs = fs && fs.existsSync(cached_file_path);\n      var has_local_fs = fs && fs.existsSync(local_file_path);\n      if (has_cached_fs || has_local_fs) {\n        loading[file] = new Promise((resolve, reject) => {\n          fs.readFile(has_cached_fs ? cached_file_path : local_file_path, \"utf8\", (err, code) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(code);\n            }\n          })\n        });\n      } else {\n        var cached_ls = ls && ls.getItem(\"FPM@\" + version + \"/\" + file);\n        if (cached_ls) {\n          loading[file] = Promise.resolve(cached_ls);\n        } else {\n          loading[file] = post(\"load_file\", {file}).then(code => new Promise((resolve, reject) => {\n            if (code) {\n              if (fs && !fs.existsSync(cache_dir_path)) {\n                console.log(\"Downloading files to `fm_modules`. This may take a while...\");\n                fs.mkdirSync(cache_dir_path);\n                fs.writeFile(cached_file_path, code, (err, ok) => resolve(code));\n              } else if (fs && !fs.existsSync(cached_file_path)) {\n                fs.writeFile(cached_file_path, code, (err, ok) => resolve(code));\n              } else if (ls) {\n                ls.setItem(\"FPM@\" + version + \"/\" + file, code);\n                resolve(code);\n              } else {\n                resolve(code);\n              }\n            }\n          }));\n        }\n      }\n    }\n    return loading[file];\n  };\n})();\n\nmodule.exports = {\n  Var,\n  Typ,\n  All,\n  Lam,\n  App,\n  Box,\n  Put,\n  Tak,\n  Dup,\n  Wrd,\n  Num,\n  Op1,\n  Op2,\n  Ite,\n  Cpy,\n  Sig,\n  Par,\n  Fst,\n  Snd,\n  Prj,\n  Eql,\n  Rfl,\n  Sym,\n  Rwt,\n  Slf,\n  New,\n  Use,\n  Ann,\n  Log,\n  Ref,\n  shift,\n  subst,\n  subst_many,\n  norm,\n  erase,\n  equal,\n  boxcheck,\n  typecheck,\n  parse,\n  gen_name,\n  show,\n  replace_refs,\n  derive_adt_type,\n  derive_adt_ctor,\n  //derive_dependent_match,\n  save_file,\n  load_file,\n  find_term,\n  version,\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../Provit/node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///../Formality-JavaScript/src/fm-lang.js?");

/***/ }),

/***/ "../Formality-JavaScript/src/fm-net.js":
/*!*********************************************!*\
  !*** ../Formality-JavaScript/src/fm-net.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Interaction Net System ~~\n\nconst Pointer = (addr, port) => (addr << 2) + (port & 3);\nconst addr_of = (ptr) => ptr >>> 2;\nconst slot_of = (ptr) => ptr & 3;\nconst Numeric = (numb) => numb + 0x100000000;\nconst numb_of = (numb) => numb - 0x100000000;\nconst type_of = (ptrn) => ptrn >= 0x100000000 ? NUM : PTR;\n\n// PtrNum types\nconst PTR = 0;\nconst NUM = 1;\n\n// Node types\nconst NOD = 0;\nconst OP1 = 1;\nconst OP2 = 2;\nconst ITE = 3;\n\nclass Net {\n  // A net stores nodes (this.nodes), reclaimable memory addrs (this.freed) and active pairs (this.redex)\n  constructor() {\n    this.nodes = []; // nodes\n    this.freed = []; // integers\n    this.redex = []; // array of (integer, integer) tuples representing addrs\n    this.find_redex = true;\n  }\n\n  // Allocates a new node, return its addr\n  alloc_node(type, kind) {\n\n    // If there is reclaimable memory, use it\n    if (this.freed.length > 0) {\n      var addr = this.freed.pop();\n\n    // Otherwise, extend the array of nodes\n    } else {\n      var addr = this.nodes.length / 4;\n    }\n\n    // Fill the memory with an empty node without pointers\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = (kind << 6) + ((type & 0x7) << 3);\n    return addr;\n  }\n\n  // Deallocates a node, allowing its space to be reclaimed\n  free_node(addr) {\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = 0;\n    this.freed.push(addr);\n  }\n\n  is_free(addr) {\n    return this.nodes[addr * 4 + 0] === addr * 4 + 0\n        && this.nodes[addr * 4 + 1] === addr * 4 + 1\n        && this.nodes[addr * 4 + 2] === addr * 4 + 2\n        && this.nodes[addr * 4 + 3] === 0;\n  }\n\n  // Returns if given slot holds a number\n  is_numeric(addr, slot) {\n    return (this.nodes[addr * 4 + 3] >>> slot) & 1; \n  }\n\n  set_port(addr, slot, ptrn) {\n    if (type_of(ptrn) === NUM) {\n      this.nodes[addr * 4 + slot] = numb_of(ptrn);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] | (1 << slot);\n    } else {\n      this.nodes[addr * 4 + slot] = ptrn;\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] & ~(1 << slot);\n    }\n  }\n\n  get_port(addr, slot) {\n    return this.nodes[addr * 4 + slot] + (this.is_numeric(addr, slot) ? 0x100000000 : 0);\n  }\n\n  type_of(addr) {\n    return (this.nodes[addr * 4 + 3] >>> 3) & 0x7;\n  }\n\n  set_type(addr, type) {\n    this.nodes[addr * 4 + 3] = (this.nodes[addr * 4 + 3] & ~0b111000) | (type << 3);\n  }\n\n  kind_of(addr) {\n    return this.nodes[addr * 4 + 3] >>> 6;\n  }\n\n  // Given a pointer to a port, returns a pointer to the opposing port\n  enter_port(ptrn) {\n    if (type_of(ptrn) === NUM) { \n      throw \"Can't enter a numeric pointer.\";\n    } else {\n      return this.get_port(addr_of(ptrn), slot_of(ptrn));\n    }\n  }\n\n  // Connects two ports\n  link_ports(a_ptrn, b_ptrn) {\n    var a_numb = type_of(a_ptrn) === NUM;\n    var b_numb = type_of(b_ptrn) === NUM;\n\n    // Point ports to each-other\n    if (!a_numb) this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), b_ptrn);\n    if (!b_numb) this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), a_ptrn);\n\n    // If both are main ports, add this to the list of active pairs\n    if (this.find_redex && !(a_numb && b_numb) && (a_numb || slot_of(a_ptrn) === 0) && (b_numb || slot_of(b_ptrn) === 0)) {\n      this.redex.push(a_numb ? addr_of(b_ptrn) : addr_of(a_ptrn));\n    }\n  }\n\n  // Disconnects a port, causing both sides to point to themselves\n  unlink_port(a_ptrn) {\n    if (type_of(a_ptrn) === PTR) {\n      var b_ptrn = this.enter_port(a_ptrn);\n      if (type_of(b_ptrn) === PTR && this.enter_port(b_ptrn) === a_ptrn) {\n        this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), a_ptrn);\n        this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), b_ptrn);\n      }\n    }\n  }\n\n  // Rewrites an active pair\n  rewrite(a_addr) {\n    var a_ptrn = Pointer(a_addr, 0);\n    var b_ptrn = this.get_port(a_addr, 0);\n    if (type_of(b_ptrn) === NUM) {\n      var a_type = this.type_of(a_addr);\n      var a_kind = this.kind_of(a_addr);\n\n      // UnaryOperation\n      if (a_type === OP1) {\n        var dst = this.enter_port(Pointer(a_addr, 2));\n        var fst = numb_of(b_ptrn);\n        var snd = numb_of(this.enter_port(Pointer(a_addr, 1)));\n        switch (a_kind) {\n          case  0: var res = Numeric((fst + snd) >>> 0); break;\n          case  1: var res = Numeric((fst - snd) >>> 0); break;\n          case  2: var res = Numeric((fst * snd) >>> 0); break;\n          case  3: var res = Numeric((fst / snd) >>> 0); break;\n          case  4: var res = Numeric((fst % snd) >>> 0); break;\n          case  5: var res = Numeric((fst ** snd) >>> 0); break;\n          case  6: var res = Numeric((fst ** (snd / (2 ** 32)) >>> 0)); break;\n          case  7: var res = Numeric((fst & snd) >>> 0); break;\n          case  8: var res = Numeric((fst | snd) >>> 0); break;\n          case  9: var res = Numeric((fst ^ snd) >>> 0); break;\n          case 10: var res = Numeric((~snd) >>> 0); break;\n          case 11: var res = Numeric((fst >>> snd) >>> 0); break;\n          case 12: var res = Numeric((fst << snd) >>> 0); break;\n          case 13: var res = Numeric((fst > snd ? 1 : 0) >>> 0); break;\n          case 14: var res = Numeric((fst < snd ? 1 : 0) >>> 0); break;\n          case 15: var res = Numeric((fst == snd ? 1 : 0) >>> 0); break;\n          default: throw \"[ERROR]\\nInvalid interaction.\";\n        }\n        this.link_ports(dst, res);\n        this.unlink_port(Pointer(a_addr, 0));\n        this.unlink_port(Pointer(a_addr, 2));\n        this.free_node(a_addr);\n      \n      // BinaryOperation\n      } else if (a_type === OP2) {\n        this.set_type(a_addr, OP1);\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.unlink_port(Pointer(a_addr, 1));\n        this.link_ports(Pointer(a_addr, 1), b_ptrn);\n    \n      // NumberDuplication\n      } else if (a_type === NOD) {\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 2)));\n        this.free_node(a_addr);\n\n      // IfThenElse\n      } else if (a_type === ITE) {\n        var cond_val = numb_of(b_ptrn) === 0;\n        var pair_ptr = this.enter_port(Pointer(a_addr, 1));\n        this.set_type(a_addr, NOD);\n        this.link_ports(Pointer(a_addr, 0), pair_ptr);\n        this.unlink_port(Pointer(a_addr, 1));\n        var dest_ptr = this.enter_port(Pointer(a_addr, 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 2 : 1), dest_ptr);\n        if (!cond_val) this.unlink_port(Pointer(a_addr, 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 1 : 2), Pointer(a_addr, cond_val ? 1 : 2));\n\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n\n    } else {\n      var b_addr = addr_of(b_ptrn);\n      var a_type = this.type_of(a_addr);\n      var b_type = this.type_of(b_addr);\n      var a_kind = this.kind_of(a_addr);\n      var b_kind = this.kind_of(b_addr);\n\n      // NodeAnnihilation, UnaryAnnihilation, BinaryAnnihilation\n      if ( a_type === NOD && b_type === NOD && a_kind === b_kind\n        || a_type === OP1 && b_type === OP1\n        || a_type === OP2 && b_type === OP2\n        || a_type === ITE && b_type === ITE) {\n        var a_aux1_dest = this.enter_port(Pointer(a_addr, 1));\n        var b_aux1_dest = this.enter_port(Pointer(b_addr, 1));\n        this.link_ports(a_aux1_dest, b_aux1_dest);\n        var a_aux2_dest = this.enter_port(Pointer(a_addr, 2));\n        var b_aux2_dest = this.enter_port(Pointer(b_addr, 2));\n        this.link_ports(a_aux2_dest, b_aux2_dest);\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // NodeDuplication, BinaryDuplication\n      } else if\n        (  a_type === NOD && b_type === NOD && a_kind !== b_kind\n        || a_type === NOD && b_type === OP2\n        || a_type === NOD && b_type === ITE) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var r_addr = this.alloc_node(a_type, a_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(r_addr, 1), Pointer(p_addr, 1));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(r_addr, 2), Pointer(q_addr, 1));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(r_addr, 0), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // UnaryDuplication\n      } else if\n        (  a_type === NOD && b_type === OP1\n        || a_type === ITE && b_type === OP1) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(p_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(q_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n      \n      // Permutations\n      } else if (a_type === OP1 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === OP2 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === ITE && b_type === NOD) {\n        return this.rewrite(b_addr);\n\n      // InvalidInteraction\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This could be performed in parallel and doesn't need GC.\n  reduce_strict(stats) {\n    var rewrites = 0;\n    var loops = 0;\n    var max_len = 0;\n    while (this.redex.length > 0) {\n      for (var i = 0, l = this.redex.length; i < l; ++i) {\n        this.rewrite(this.redex.pop());\n        stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n        ++stats.rewrites;\n      }\n      ++stats.loops;\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This avoids unecessary computations, but is sequential and would need GC.\n  reduce_lazy(stats) {\n    this.find_redex = false;\n    var warp = [];\n    var back = [];\n    var prev = Pointer(0, 1);\n    var next = this.enter_port(prev);\n    var rwts = 0;\n    while (true) {\n      ++stats.loops;\n      if (type_of(next) === PTR && (addr_of(next) === 0 || this.is_free(addr_of(next)))) {\n        if (warp.length === 0) {\n          break;\n        } else {\n          prev = warp.pop();\n          next = this.enter_port(prev);\n        }\n      } else {\n        if (slot_of(prev) === 0 && (type_of(next) === NUM || slot_of(next) === 0)) {\n          this.rewrite(addr_of(prev));\n          stats.rewrites += 1;\n          stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n          do { prev = back.pop(); } while (type_of(prev) !== PTR);\n          next = this.enter_port(prev);\n          ++rwts;\n        } else if (type_of(next) === NUM) {\n          [prev,next] = [next,prev];\n        } else if (slot_of(next) === 0) {\n          if (this.type_of(addr_of(next)) !== OP1) {\n            warp.push(Pointer(addr_of(next), 1));\n          }\n          prev = Pointer(addr_of(next), 2);\n          next = this.enter_port(prev);\n        } else {\n          back.push(prev);\n          prev = Pointer(addr_of(next), 0);\n          next = this.enter_port(prev);\n        }\n      }\n    }\n    this.find_redex = true;\n  }\n\n  // Returns a string that is preserved on reduction, good for debugging\n  denote(ptrn = this.enter_port(Pointer(0, 1)), exit = []) {\n    function path_to_string(path) {\n      var str = \"<\";\n      while (path) {\n        str += path.head === 1 ? \"a\" : \"b\";\n        path = path.tail; \n      }\n      str += \">\";\n      return str;\n    }\n    while (true) {\n      if (type_of(ptrn) === PTR) {\n        var ai = addr_of(ptrn);\n        var as = slot_of(ptrn)\n        var ak = this.kind_of(ai);\n        switch (this.type_of(ai)) {\n          case NOD:\n            if (slot_of(ptrn) === 0) {\n              if (exit[ak]) {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = new_exit[ak].tail;\n                ptrn = this.enter_port(Pointer(ai, Number(exit[ak].head)));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              } else {\n                var lft = this.denote(this.enter_port(Pointer(ai, 1)), exit);\n                var rgt = this.denote(this.enter_port(Pointer(ai, 2)), exit);\n                return \"(\" + ak + \" \" + lft + \" \" + rgt + \")\";\n              }\n            } else {\n              if (ai === 0) {\n                while (exit[exit.length - 1] === null) exit.pop();\n                return exit.map(path_to_string).join(\":\");\n              } else {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = {head: as, tail: new_exit[ak] || null};\n                ptrn = this.enter_port(Pointer(ai, 0));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              }\n            }\n            break;\n          default:\n            return \"<TODO>\";\n        }\n      } else {\n        return \"#\" + numb_of(ptrn);\n      }\n    }\n  }\n\n  to_string() {\n    const pointer = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return \"#\" + numb_of(ptrn);\n      } else {\n        return addr_of(ptrn) + \"abc\"[slot_of(ptrn)];\n      }\n    };\n    var text = '';\n    for (var i = 0; i < this.nodes.length / 4; i++) {\n      if (this.is_free(i)) {\n        text += i + \": ~\\n\";\n      } else {\n        var type = this.type_of(i);\n        var kind = this.kind_of(i);\n        text += i + ': ';\n        text += \"[\" + type + \":\" + kind + \"| \";\n        text += pointer(this.get_port(i, 0)) + \" \";\n        text += pointer(this.get_port(i, 1)) + \" \";\n        text += pointer(this.get_port(i, 2)) + \"]\";\n        text += \"...\" + this.is_numeric(i,0) + \" \" + this.is_numeric(i,1) + \" \" + this.is_numeric(i,2);\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n}\n\nmodule.exports = {Pointer, addr_of, slot_of, Numeric, numb_of, type_of, Net, NUM, PTR, NOD, OP1, OP2, ITE};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/src/fm-net.js?");

/***/ }),

/***/ "../Formality-JavaScript/src/fm-to-js.js":
/*!***********************************************!*\
  !*** ../Formality-JavaScript/src/fm-to-js.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fmc = __webpack_require__(/*! ./fm-lang.js */ \"../Formality-JavaScript/src/fm-lang.js\");\n\n// Converts a Formality-Core Term to a native JavaScript function\nconst compile = (term, defs, vars) => {\n  var [ctor, term] = term();\n  switch (ctor) {\n    case \"Var\":\n      for (var i = 0; i < term.index; ++i) {\n        vars = vars[1];\n      }\n      return vars[0];\n    case \"Lam\":\n      return x => compile(term.body, defs, [x, vars]);\n    case \"App\":\n      var func = compile(term.func, defs, vars);\n      var argm = compile(term.argm, defs, vars);\n      return func(argm);\n    case \"Put\":\n      return compile(term.expr, defs, vars);\n    case \"Dup\": \n      var expr = compile(term.expr, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(expr);\n    case \"Num\":\n      return term.numb;\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = compile(term.num0, defs, vars);\n      var num1 = compile(term.num1, defs, vars);\n      switch (func) {\n        case \"+\"  : return (num0 + num1) >>> 0;\n        case \"-\"  : return (num0 - num1) >>> 0;\n        case \"*\"  : return (num0 * num1) >>> 0;\n        case \"/\"  : return (num0 / num1) >>> 0;\n        case \"%\"  : return (num0 % num1) >>> 0;\n        case \"^\"  : return (num0 ** num1) >>> 0;\n        case \"**\" : return (num0 ** (num1 / (2 ** 32))) >>> 0;\n        case \".&\" : return (num0 & num1) >>> 0;\n        case \".|\" : return (num0 | num1) >>> 0;\n        case \".^\" : return (num0 ^ num1) >>> 0;\n        case \".!\" : return (~ num1) >>> 0;\n        case \".>>\": return (num0 >>> num1) >>> 0;\n        case \".<<\": return (num0 << num1) >>> 0;\n        case \".>\" : return (num0 > num1) >>> 0;\n        case \".<\" : return (num0 < num1) >>> 0;\n        case \".=\" : return (num0 === num1) >>> 0;\n      }\n    case \"Ite\":\n      var cond = compile(term.cond, defs, vars);\n      var pair = compile(term.pair, defs, vars);\n      return cond ? pair[0] : pair[1];\n    case \"Cpy\":\n      var numb = compile(term.numb, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(numb);\n    case \"Par\":\n      var val0 = compile(term.val0, defs, vars);\n      var val1 = compile(term.val1, defs, vars);\n      return [val0, val1];\n    case \"Fst\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[0];\n    case \"Snd\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[1];\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = compile(term.pair, defs, vars);\n      var body = (x,y) => compile(term.body, defs, [y,[x,vars]]);\n      return body(pair[0], pair[1]);\n    case \"Log\":\n      return compile(term.expr, defs, vars);\n    case \"Ref\":\n      return compile(fmc.erase(defs[term.name]), defs, vars);\n  }\n};\n\n// Converts a native JavaScript function back to a Formality-Core term\nconst decompile = (func) => {\n  return (function go(term, depth) {\n    function APP(variable) {\n      return function FMC_DECOMPILE_GET(arg){\n        if (arg === null) {\n          return variable;\n        } else {\n          return APP(d => fmc.App(variable(d), go(arg, d)));\n        }\n      };\n    };\n    function VAR(d) {\n      return fmc.Var(d - 1 - depth);\n    };\n    if (typeof term === \"function\" && term.name === \"FMC_DECOMPILE_GET\") {\n      return term(null)(depth);\n    } else if (typeof term === \"object\") {\n      var val0 = go(term[0], depth);\n      var val1 = go(term[1], depth);\n      return fmc.Par(val0, val1);\n    } else if (typeof term === \"number\") {\n      return fmc.Num(term);\n    } else if (typeof term === \"function\") {\n      var body = go(term(APP(VAR)), depth + 1);\n      return fmc.Lam(fmc.gen_name(depth), body);\n    } else if (typeof term === \"string\") {\n      throw \"[ERROR]\\nThis native JS function can't be decompiled to FMC:\\n\\n\"\n        + func.toString()\n        + \"\\n\\nIt possibly uses numeric operators on free variables, which can't be decompiled yet.\";\n    } else {\n      return term;\n    }\n  })(func, 0);\n};\n\nmodule.exports = {compile, decompile};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/src/fm-to-js.js?");

/***/ }),

/***/ "../Formality-JavaScript/src/fm-to-net.js":
/*!************************************************!*\
  !*** ../Formality-JavaScript/src/fm-to-net.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ~~ Compiles Formality Core to Formality Net ~~\n\nconst {Var, App, Lam, Num, Op1, Op2, Ite, Par, Fst, Snd, gen_name, erase} = __webpack_require__(/*! ./fm-lang.js */ \"../Formality-JavaScript/src/fm-lang.js\");\nconst {Net, Pointer, Numeric, addr_of, slot_of, type_of, numb_of, NOD, OP1, OP2, NUM, ITE, PTR, FOR} = __webpack_require__(/*! ./fm-net.js */ \"../Formality-JavaScript/src/fm-net.js\");\n\nconst op_kind = {\n   0 : \"+\"   , \"+\"   : 0  ,\n   1 : \"-\"   , \"-\"   : 1  ,\n   2 : \"*\"   , \"*\"   : 2  ,\n   3 : \"/\"   , \"/\"   : 3  ,\n   4 : \"%\"   , \"%\"   : 4  ,\n   5 : \"^\"   , \"^\"   : 5  ,\n   6 : \"**\"  , \"**\"  : 6  ,\n   7 : \".&\"  , \".&\"  : 7  ,\n   8 : \".|\"  , \".|\"  : 8  ,\n   9 : \".^\"  , \".^\"  : 9  ,\n  10 : \".!\"  , \".!\"  : 10 ,\n  11 : \".>>\" , \".>>\" : 11 ,\n  12 : \".<<\" , \".<<\" : 12 ,\n  13 : \".>\"  , \".>\"  : 13 ,\n  14 : \".<\"  , \".<\"  : 14 ,\n  15 : \".=\"  , \".=\"  : 15 ,\n};\n\nconst compile = (term, defs = {}) => {\n  const build_net = (term, net, var_ptrs, level) => {\n    const get_var = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return ptrn;\n      } else {\n        if (net.enter_port(ptrn) === ptrn) {\n          return ptrn;\n        } else {\n          var dups_ptrn = net.enter_port(ptrn);\n          var dup_addr = net.alloc_node(NOD, level_of[ptrn] + 1);\n          net.link_ports(Pointer(dup_addr, 0), ptrn);\n          net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n          return Pointer(dup_addr, 2);\n        }\n      }\n    };\n    switch (term[0]) {\n      case \"Dup\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level);\n        level_of[expr_ptr] = level;\n        var_ptrs.push(expr_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Put\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level + 1);\n        return expr_ptr;\n      case \"Lam\":\n        var lam_addr = net.alloc_node(NOD, 0);\n        net.link_ports(Pointer(lam_addr, 1), Pointer(lam_addr, 1));\n        level_of[Pointer(lam_addr, 1)] = level;\n        var_ptrs.push(Pointer(lam_addr, 1));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        net.link_ports(Pointer(lam_addr, 2), body_ptr);\n        return Pointer(lam_addr, 0);\n      case \"App\":\n        var app_addr = net.alloc_node(NOD, 0);\n        var func_ptr = build_net(term[1].func, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 0), func_ptr);\n        var argm_ptr = build_net(term[1].argm, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 1), argm_ptr)\n        return Pointer(app_addr, 2);\n      case \"Num\":\n        return Numeric(term[1].numb >>> 0);\n      case \"Op1\":\n        var op1_addr = net.alloc_node(OP1, op_kind[term[1].func]);\n        net.link_ports(Numeric(term[1].num1()[1].numb), Pointer(op1_addr, 1));\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(num0_ptr, Pointer(op1_addr, 0));\n        return Pointer(op1_addr, 2);\n      case \"Op2\":\n        var op2_addr = net.alloc_node(OP2, op_kind[term[1].func]);\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 1), num0_ptr);\n        var num1_ptr = build_net(term[1].num1, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 0), num1_ptr);\n        return Pointer(op2_addr, 2);\n      case \"Par\":\n        var par_addr = net.alloc_node(NOD, 0xFFFF);\n        var val0_ptr = build_net(term[1].val0, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 1), val0_ptr);\n        var val1_ptr = build_net(term[1].val1, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 2), val1_ptr);\n        return Pointer(par_addr, 0);\n      case \"Fst\":\n        var fst_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(fst_addr, 0), pair_ptr);\n        net.link_ports(Pointer(fst_addr, 2), Pointer(fst_addr, 2));\n        return Pointer(fst_addr, 1);\n      case \"Snd\":\n        var snd_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(snd_addr, 0), pair_ptr);\n        net.link_ports(Pointer(snd_addr, 1), Pointer(snd_addr, 1));\n        return Pointer(snd_addr, 2);\n      case \"Prj\":\n        var prj_addr = net.alloc_node(NOD, 0xFFFF);\n        level_of[Pointer(prj_addr, 1)] = level;\n        level_of[Pointer(prj_addr, 2)] = level;\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        var_ptrs.push(Pointer(prj_addr, 1));\n        var_ptrs.push(Pointer(prj_addr, 2));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        var_ptrs.pop();\n        net.link_ports(Pointer(prj_addr, 0), pair_ptr);\n        return body_ptr;\n      case \"Ite\":\n        var ite_addr = net.alloc_node(ITE, 0xFFFF);\n        var cond_ptr = build_net(term[1].cond, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 0), cond_ptr);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 1), pair_ptr);\n        return Pointer(ite_addr, 2);\n      case \"Cpy\":\n        var numb_ptr = build_net(term[1].numb, net, var_ptrs, level);\n        level_of[numb_ptr] = 0xFFFE;\n        var_ptrs.push(numb_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Log\":\n        return build_net(term[1].expr, net, var_ptrs, level);\n      case \"Var\":\n        return get_var(var_ptrs[var_ptrs.length - term[1].index - 1]);\n      case \"Ref\":\n        return build_net(defs[term[1].name] ? erase(defs[term[1].name]) : Num(0), net, var_ptrs, level);\n      default:\n        return build_net(Lam(\"\", null, Var(0), false), net, var_ptrs, level);\n    }\n  };\n  var level_of = {};\n  var net = new Net();\n  var root_addr = net.alloc_node(NOD, 0);\n  var term_ptr = build_net(term, net, [], 0);\n  net.link_ports(Pointer(root_addr, 0), Pointer(root_addr, 2));\n  net.link_ports(Pointer(root_addr, 1), term_ptr);\n  // Removes invalid redexes. They can be created by the\n  // compiler when duplicating variables more than once.\n  net.redex = net.redex.filter((a_addr) => {\n    var b_ptrn = net.enter_port(Pointer(a_addr, 0));\n    if (type_of(b_ptrn) !== NUM) {\n      var b_addr = addr_of(b_ptrn);\n      var a_p0 = Pointer(a_addr, 0);\n      var b_p0 = Pointer(b_addr, 0);\n      var a_ok = net.enter_port(a_p0) === b_p0;\n      var b_ok = net.enter_port(b_p0) === a_p0;\n      return a_ok && b_ok;\n    } else {\n      return true;\n    }\n  });\n  return net;\n};\n\nconst decompile = (net) => {\n  const build_term = (net, ptrn, var_ptrs, dup_exit) => {\n    if (type_of(ptrn) === NUM) {\n      return Num(numb_of(ptrn));\n    } else {\n      var addr = addr_of(ptrn);\n      var type = net.type_of(addr);\n      var kind = net.kind_of(addr);\n      if (type === NOD) {\n        if (kind === 0) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var_ptrs.push(Pointer(addr, 1));\n              var body = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              var_ptrs.pop();\n              return Lam(gen_name(var_ptrs.length), null, body, false);\n            case 1:\n              for (var index = 0; index < var_ptrs.length; ++index) {\n                if (var_ptrs[var_ptrs.length - index - 1] === ptrn) {\n                  return Var(index);\n                }\n              }\n            case 2:\n              var argm = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var func = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return App(func, argm, false);\n          }\n        } else if (kind === 0xFFFF) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var val0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var val1 = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              return Par(val0, val1);\n            case 1:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Fst(pair);\n            case 2:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Snd(pair);\n          }\n        } else {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var exit = dup_exit.pop();\n              var term = build_term(net, net.enter_port(Pointer(addr, exit)), var_ptrs, dup_exit);\n              dup_exit.push(exit);\n              return term;\n            default:\n              dup_exit.push(slot_of(ptrn));\n              var term = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              dup_exit.pop();\n              return term;\n          }\n        }\n      } else if (type === OP1) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var num1 = Num(numb_of(net.enter_port(Pointer(addr, 1))));\n        return Op1(op_kind[kind], num0, num1);\n      } else if (type === OP2) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        var num1 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        return Op2(op_kind[kind], num0, num1);\n      } else if (type === ITE) {\n        var cond = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var pair = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        return Ite(cond, pair);\n      }\n    }\n  };\n  return build_term(net, net.enter_port(Pointer(0, 1)), [], []);\n};\n\nconst norm_with_stats = (term, defs = {}, lazy = true) => {\n  var net = compile(term, defs);\n  var stats = lazy ? net.reduce_lazy() : net.reduce();\n  var norm = decompile(net);\n  return {norm, stats};\n};\n\nconst norm = (term, defs, lazy) => {\n  return norm_with_stats(term, defs, lazy).norm;\n};\n\nmodule.exports = {compile, decompile, norm_with_stats, norm};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/src/fm-to-net.js?");

/***/ }),

/***/ "./node_modules/inferno-hyperscript/dist/index.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/inferno-hyperscript/dist/index.esm.js ***!
  \************************************************************/
/*! exports provided: h */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony import */ var inferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\n\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\n\nvar classIdSplit = /([.#]?[a-zA-Z0-9_:-]+)/;\nvar notClassId = /^\\.|#/;\nfunction parseTag(tag, props) {\n    if (!tag) {\n        return 'div';\n    }\n    if (tag === inferno__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"]) {\n        return tag;\n    }\n    var noId = props && isUndefined(props.id);\n    var tagParts = tag.split(classIdSplit);\n    var tagName = null;\n    if (notClassId.test(tagParts[1])) {\n        tagName = 'div';\n    }\n    var classes;\n    for (var i = 0, len = tagParts.length; i < len; ++i) {\n        var part = tagParts[i];\n        if (!part) {\n            continue;\n        }\n        var type = part.charAt(0);\n        if (!tagName) {\n            tagName = part;\n        }\n        else if (type === '.') {\n            if (classes === void 0) {\n                classes = [];\n            }\n            classes.push(part.substring(1, part.length));\n        }\n        else if (type === '#' && noId) {\n            props.id = part.substring(1, part.length);\n        }\n    }\n    if (classes) {\n        if (props.className) {\n            classes.push(props.className);\n        }\n        props.className = classes.join(' ');\n    }\n    return tagName || 'div';\n}\nfunction isChildren(x) {\n    return isStringOrNumber(x) || (x && isArray(x));\n}\n/**\n * Creates virtual node\n * @param {string|VNode|Function} _tag Name for virtual node\n * @param {object=} _props Additional properties for virtual node\n * @param {string|number|VNode|Array<string|number|VNode>|null=} _children Optional children for virtual node\n * @returns {VNode} returns new virtual node\n */\nfunction h(_tag, _props, _children) {\n    // If a child array or text node are passed as the second argument, shift them\n    if (!_children && isChildren(_props)) {\n        _children = _props;\n        _props = {};\n    }\n    var isElement = isString(_tag);\n    _props = _props || {};\n    var tag = isElement ? parseTag(_tag, _props) : _tag;\n    var newProps = {};\n    var key = null;\n    var ref = null;\n    var children = null;\n    var className = null;\n    for (var prop in _props) {\n        if (isElement && (prop === 'className' || prop === 'class')) {\n            className = _props[prop];\n        }\n        else if (prop === 'key') {\n            key = _props[prop];\n        }\n        else if (prop === 'ref') {\n            ref = _props[prop];\n        }\n        else if (prop === 'hooks') {\n            ref = _props[prop];\n        }\n        else if (prop === 'children') {\n            children = _props[prop];\n        }\n        else if (!isElement && prop.substr(0, 11) === 'onComponent') {\n            if (!ref) {\n                ref = {};\n            }\n            ref[prop] = _props[prop];\n        }\n        else {\n            newProps[prop] = _props[prop];\n        }\n    }\n    if (isElement) {\n        var flags = Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"])(tag);\n        if (flags & 8192 /* Fragment */) {\n            return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createFragment\"])(_children || children, 0 /* UnknownChildren */, key);\n        }\n        if (newProps.contenteditable !== void 0) {\n            flags |= 4096 /* ContentEditable */;\n        }\n        return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"])(flags, tag, className, _children || children, 0 /* UnknownChildren */, newProps, key, ref);\n    }\n    if (children || _children) {\n        newProps.children = children || _children;\n    }\n    return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"])(2 /* ComponentUnknown */, tag, newProps, key, ref);\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno-hyperscript/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/inferno/dist/index.esm.js ***!
  \************************************************/
/*! exports provided: Component, Fragment, EMPTY_OBJ, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, forwardRef, directClone, findDOMfromVNode, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version, _CI, _HI, _M, _MCCC, _ME, _MFCC, _MR, _MT, _MP, __render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return Fragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return EMPTY_OBJ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return createComponentVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createFragment\", function() { return createFragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return createPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return createRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return createRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return createTextVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return createVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardRef\", function() { return forwardRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return directClone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findDOMfromVNode\", function() { return findDOMfromVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return getFlagsForElementVnode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return linkEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return normalizeProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return options; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rerender\", function() { return rerender; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_CI\", function() { return createClassComponentInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_HI\", function() { return handleComponentInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_M\", function() { return mount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MCCC\", function() { return mountClassComponentCallbacks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_ME\", function() { return mountElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MFCC\", function() { return mountFunctionalComponentCallbacks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MR\", function() { return mountRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MT\", function() { return mountText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MP\", function() { return mountProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__render\", function() { return __render; });\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return isUndefined(o) || isNull(o);\n}\nfunction isInvalid(o) {\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isTrue(o) {\n    return o === true;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction isObject(o) {\n    return typeof o === 'object';\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n    parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n    if (isNull(nextNode)) {\n        appendChild(parentDOM, newNode);\n    }\n    else {\n        parentDOM.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n    parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n    parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n    var listener;\n    while ((listener = arrayFn.shift()) !== undefined) {\n        listener();\n    }\n}\nfunction findDOMfromVNode(vNode, start) {\n    var flags;\n    var children;\n    while (vNode) {\n        flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            return vNode.dom;\n        }\n        children = vNode.children;\n        if (flags & 8192 /* Fragment */) {\n            vNode = vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[start ? 0 : children.length - 1];\n        }\n        else if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        else {\n            vNode = children;\n        }\n    }\n    return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n    var flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n        removeChild(parentDOM, vNode.dom);\n    }\n    else {\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            removeVNodeDOM(children.$LI, parentDOM);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            removeVNodeDOM(children, parentDOM);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                removeVNodeDOM(children, parentDOM);\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    removeVNodeDOM(children[i], parentDOM);\n                }\n            }\n        }\n    }\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n    var flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n        insertOrAppend(parentDOM, vNode.dom, nextNode);\n    }\n    else {\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            moveVNodeDOM(children.$LI, parentDOM, nextNode);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            moveVNodeDOM(children, parentDOM, nextNode);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                moveVNodeDOM(children, parentDOM, nextNode);\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    moveVNodeDOM(children[i], parentDOM, nextNode);\n                }\n            }\n        }\n    }\n}\nfunction createDerivedState(instance, nextProps, state) {\n    if (instance.constructor.getDerivedStateFromProps) {\n        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n    }\n    return state;\n}\nvar renderCheck = {\n    v: false\n};\nvar options = {\n    componentComparator: null,\n    createVNode: null,\n    renderComplete: null\n};\nfunction setTextContent(dom, children) {\n    dom.textContent = children;\n}\nfunction isSameLinkEvent(lastValue, nextValue) {\n    return (lastValue &&\n        nextValue &&\n        isObject(lastValue) &&\n        isObject(nextValue) &&\n        lastValue.event === nextValue.event &&\n        lastValue.data === nextValue.data);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n    this.childFlags = childFlags;\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key === void 0 ? null : key;\n    this.props = props === void 0 ? null : props;\n    this.ref = ref === void 0 ? null : ref;\n    this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n    var optsVNode = options.createVNode;\n    if (isFunction(optsVNode)) {\n        optsVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    if ((flags & 2 /* ComponentUnknown */) !== 0) {\n        if (type.prototype && type.prototype.render) {\n            flags = 4 /* ComponentClass */;\n        }\n        else if (type.render) {\n            flags = 32776 /* ForwardRefComponent */;\n            type = type.render;\n        }\n        else {\n            flags = 8 /* ComponentFunction */;\n        }\n    }\n    // set default props\n    var defaultProps = type.defaultProps;\n    if (!isNullOrUndef(defaultProps)) {\n        if (!props) {\n            props = {}; // Props can be referenced and modified at application level so always create new object\n        }\n        for (var prop in defaultProps) {\n            if (isUndefined(props[prop])) {\n                props[prop] = defaultProps[prop];\n            }\n        }\n    }\n    if ((flags & 8 /* ComponentFunction */) > 0 && (flags & 32768 /* ForwardRef */) === 0) {\n        var defaultHooks = type.defaultHooks;\n        if (!isNullOrUndef(defaultHooks)) {\n            if (!ref) {\n                // As ref cannot be referenced from application level, we can use the same refs object\n                ref = defaultHooks;\n            }\n            else {\n                for (var prop$1 in defaultHooks) {\n                    if (isUndefined(ref[prop$1])) {\n                        ref[prop$1] = defaultHooks[prop$1];\n                    }\n                }\n            }\n        }\n    }\n    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, props, ref, type);\n    var optsVNode = options.createVNode;\n    if (isFunction(optsVNode)) {\n        optsVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n    switch (fragment.childFlags) {\n        case 1 /* HasInvalidChildren */:\n            fragment.children = createVoidVNode();\n            fragment.childFlags = 2 /* HasVNodeChildren */;\n            break;\n        case 16 /* HasTextChildren */:\n            fragment.children = [createTextVNode(children)];\n            fragment.childFlags = 4 /* HasNonKeyedChildren */;\n            break;\n        default:\n            break;\n    }\n    return fragment;\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                vNode.className = props.className || null;\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n    var clonedChildren;\n    var oldChildren = vNodeToClone.children;\n    var childFlags = vNodeToClone.childFlags;\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        clonedChildren = directClone(oldChildren);\n    }\n    else if (childFlags & 12 /* MultipleChildren */) {\n        clonedChildren = [];\n        for (var i = 0, len = oldChildren.length; i < len; ++i) {\n            clonedChildren.push(directClone(oldChildren[i]));\n        }\n    }\n    return createFragment(clonedChildren, childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n    var props = vNodeToClone.props;\n    if (flags & 14 /* Component */) {\n        if (!isNull(props)) {\n            var propsToClone = props;\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n    }\n    if ((flags & 8192 /* Fragment */) === 0) {\n        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n    }\n    return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, children, 0 /* UnknownChildren */, null, isInvalid(children) ? null : children.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    n.flags |= 65536 /* Normalized */;\n                    if (!isPrefixedKey) {\n                        if (isNull(oldKey)) {\n                            n.key = newKey;\n                        }\n                        else {\n                            n.key = currentKey + oldKey;\n                        }\n                    }\n                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    switch (type) {\n        case 'svg':\n            return 32 /* SvgElement */;\n        case 'input':\n            return 64 /* InputElement */;\n        case 'select':\n            return 256 /* SelectElement */;\n        case 'textarea':\n            return 128 /* TextareaElement */;\n        case Fragment:\n            return 8192 /* Fragment */;\n        default:\n            return 1 /* HtmlElement */;\n    }\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isStringOrNumber(children)) {\n        newChildFlags = 16 /* HasTextChildren */;\n        newChildren = children;\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        for (var i = 0; i < len; ++i) {\n            var n = children[i];\n            if (isInvalid(n) || isArray(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                _normalizeVNodes(children, newChildren, i, '');\n                break;\n            }\n            else if (isStringOrNumber(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                newChildren.push(createTextVNode(n, keyPrefix + i));\n            }\n            else {\n                var key = n.key;\n                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n                var isNullKey = isNull(key);\n                var isPrefixed = isString(key) && key[0] === keyPrefix;\n                if (needsCloning || isNullKey || isPrefixed) {\n                    newChildren = newChildren || children.slice(0, i);\n                    if (needsCloning || isPrefixed) {\n                        n = directClone(n);\n                    }\n                    if (isNullKey || isPrefixed) {\n                        n.key = keyPrefix + i;\n                    }\n                    newChildren.push(n);\n                }\n                else if (newChildren) {\n                    newChildren.push(n);\n                }\n                n.flags |= 65536 /* Normalized */;\n            }\n        }\n        newChildren = newChildren || children;\n        if (newChildren.length === 0) {\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            newChildFlags = 8 /* HasKeyedChildren */;\n        }\n    }\n    else {\n        newChildren = children;\n        newChildren.flags |= 65536 /* Normalized */;\n        if (children.flags & 81920 /* InUseOrNormalized */) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n    return {\n        onClick: v,\n        onDblClick: v,\n        onFocusIn: v,\n        onFocusOut: v,\n        onKeyDown: v,\n        onKeyPress: v,\n        onKeyUp: v,\n        onMouseDown: v,\n        onMouseMove: v,\n        onMouseUp: v,\n        onSubmit: v,\n        onTouchEnd: v,\n        onTouchMove: v,\n        onTouchStart: v\n    };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar delegatedEvents = getDelegatedEventObject(true);\nfunction handleEvent(name, nextEvent, dom) {\n    var eventsObject = dom.$EV;\n    if (nextEvent) {\n        if (attachedEventCounts[name] === 0) {\n            attachedEvents[name] = attachEventToDocument(name);\n        }\n        if (!eventsObject) {\n            eventsObject = dom.$EV = getDelegatedEventObject(null);\n        }\n        if (!eventsObject[name]) {\n            ++attachedEventCounts[name];\n        }\n        eventsObject[name] = nextEvent;\n    }\n    else if (eventsObject && eventsObject[name]) {\n        if (--attachedEventCounts[name] === 0) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = null;\n    }\n}\nfunction dispatchEvents(event, target, isClick, name, eventData) {\n    var dom = target;\n    while (!isNull(dom)) {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                if (currentEvent.event) {\n                    currentEvent.event(currentEvent.data, event);\n                }\n                else {\n                    currentEvent(event);\n                }\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    }\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction isDefaultPrevented() {\n    return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n    return this.cancelBubble;\n}\nfunction attachEventToDocument(name) {\n    var docEvent = function (event) {\n        var isClick = name === 'onClick' || name === 'onDblClick';\n        if (isClick && event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 12 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return;\n        }\n        event.isDefaultPrevented = isDefaultPrevented;\n        event.isPropagationStopped = isPropagationStopped;\n        event.stopPropagation = stopPropagation;\n        // Event data needs to be object to save reference to currentTarget getter\n        var eventData = {\n            dom: document\n        };\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            get: function get() {\n                return eventData.dom;\n            }\n        });\n        dispatchEvents(event, event.target, isClick, name, eventData);\n    };\n    document.addEventListener(normalizeEventName(name), docEvent);\n    return docEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; ++i) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction attachEvent(dom, event, handler) {\n    var previousKey = \"$\" + event;\n    var previousArgs = dom[previousKey];\n    if (previousArgs && previousArgs[1].wrapped) {\n        return;\n    }\n    if (previousArgs) {\n        dom.removeEventListener.apply(dom, previousArgs);\n        dom[previousKey] = null;\n    }\n    if (isFunction(handler)) {\n        dom.addEventListener(event, handler);\n        dom[previousKey] = [event, handler];\n    }\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        attachEvent(dom, 'change', wrappedOnChange);\n        attachEvent(dom, 'click', emptywrapper);\n    }\n    else {\n        attachEvent(dom, 'input', onTextInputChange);\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptions(vNode, value) {\n    if (vNode.type === 'option') {\n        updateChildOption(vNode, value);\n    }\n    else {\n        var children = vNode.children;\n        var flags = vNode.flags;\n        if (flags & 4 /* ComponentClass */) {\n            updateChildOptions(children.$LI, value);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; ++i) {\n                updateChildOptions(children[i], value);\n            }\n        }\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var index = nextPropsOrEmpty.selectedIndex;\n    if (index === -1) {\n        dom.selectedIndex = -1;\n    }\n    var childFlags = vNode.childFlags;\n    if (childFlags !== 1 /* HasInvalidChildren */) {\n        var value = nextPropsOrEmpty.value;\n        if (isNumber(index) && index > -1 && dom.options[index]) {\n            value = dom.options[index].value;\n        }\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        updateChildOptions(vNode, value);\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    attachEvent(dom, 'input', onTextareaInputChange);\n    if (nextPropsOrEmpty.onChange) {\n        attachEvent(dom, 'change', wrappedOnChange$1);\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\n/**\n * There is currently no support for switching same input between controlled and nonControlled\n * If that ever becomes a real issue, then re design controlled elements\n * Currently user must choose either controlled or non-controlled and stick with that\n */\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n    return {\n        current: null\n    };\n}\nvar forwardRef = function (render) {\n        return {\n            render: render\n        };\n    };\nfunction pushRef(dom, value, lifecycle) {\n    lifecycle.push(function () {\n        value(dom);\n    });\n}\nfunction unmountRef(ref) {\n    if (ref) {\n        if (isFunction(ref)) {\n            ref(null);\n        }\n        else if (ref.current) {\n            ref.current = null;\n        }\n    }\n}\nfunction mountRef(ref, value, lifecycle) {\n    if (ref) {\n        if (isFunction(ref)) {\n            pushRef(value, ref, lifecycle);\n        }\n        else if (ref.current !== void 0) {\n            ref.current = value;\n        }\n    }\n}\n\nfunction remove(vNode, parentDOM) {\n    unmount(vNode);\n    if (parentDOM) {\n        removeVNodeDOM(vNode, parentDOM);\n    }\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var ref;\n    if (flags & 481 /* Element */) {\n        ref = vNode.ref;\n        var props = vNode.props;\n        unmountRef(ref);\n        var childFlags = vNode.childFlags;\n        if (!isNull(props)) {\n            var keys = Object.keys(props);\n            for (var i = 0, len = keys.length; i < len; i++) {\n                var key = keys[i];\n                if (delegatedEvents[key]) {\n                    handleEvent(key, null, vNode.dom);\n                }\n            }\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n    }\n    else if (children) {\n        if (flags & 4 /* ComponentClass */) {\n            if (isFunction(children.componentWillUnmount)) {\n                children.componentWillUnmount();\n            }\n            unmountRef(vNode.ref);\n            children.$UN = true;\n            unmount(children.$LI);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            ref = vNode.ref;\n            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n            }\n            unmount(children);\n        }\n        else if (flags & 1024 /* Portal */) {\n            remove(children, vNode.ref);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags & 12 /* MultipleChildren */) {\n                unmountAllChildren(children);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        unmount(children[i]);\n    }\n}\nfunction clearDOM(dom) {\n    // Optimization for clearing dom\n    dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n    unmountAllChildren(children);\n    if (vNode.flags & 8192 /* Fragment */) {\n        removeVNodeDOM(vNode, dom);\n    }\n    else {\n        clearDOM(dom);\n    }\n}\n\nfunction createLinkEvent(linkEvent, nextValue) {\n    return function (e) {\n        linkEvent(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    var event = normalizeEventName(name);\n    if (isObject(nextValue) && !isNull(nextValue)) {\n        var linkEvent = nextValue.event;\n        if (!isSameLinkEvent(lastValue, nextValue)) {\n            attachEvent(dom, event, createLinkEvent(linkEvent, nextValue));\n        }\n    }\n    else {\n        attachEvent(dom, event, nextValue);\n    }\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isNullOrUndef(nextAttrValue)) {\n        dom.removeAttribute('style');\n        return;\n    }\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle.setProperty(style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle.removeProperty(style);\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle.setProperty(style, value);\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                break;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'style':\n            patchStyle(lastValue, nextValue, dom);\n            break;\n        case 'dangerouslySetInnerHTML':\n            var lastHtml = (lastValue && lastValue.__html) || '';\n            var nextHtml = (nextValue && nextValue.__html) || '';\n            if (lastHtml !== nextHtml) {\n                if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n                    if (!isNull(lastVNode)) {\n                        if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                            unmountAllChildren(lastVNode.children);\n                        }\n                        else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                            unmount(lastVNode.children);\n                        }\n                        lastVNode.children = null;\n                        lastVNode.childFlags = 1 /* HasInvalidChildren */;\n                    }\n                    dom.innerHTML = nextHtml;\n                }\n            }\n            break;\n        default:\n            if (delegatedEvents[prop]) {\n                if (!isSameLinkEvent(lastValue, nextValue)) {\n                    handleEvent(prop, nextValue, dom);\n                }\n            }\n            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n                patchEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction renderNewInput(instance, props, context) {\n    var nextInput = handleComponentInput(instance.render(props, instance.state, context));\n    var childContext = context;\n    if (isFunction(instance.getChildContext)) {\n        childContext = combineFrom(context, instance.getChildContext());\n    }\n    instance.$CX = childContext;\n    return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    var instance = new Component(props, context);\n    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));\n    instance.$SVG = isSVG;\n    instance.$L = lifecycle;\n    vNode.children = instance;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    if (!usesNewAPI) {\n        if (isFunction(instance.componentWillMount)) {\n            instance.$BR = true;\n            instance.componentWillMount();\n            var pending = instance.$PS;\n            if (!isNull(pending)) {\n                var state = instance.state;\n                if (isNull(state)) {\n                    instance.state = pending;\n                }\n                else {\n                    for (var key in pending) {\n                        state[key] = pending[key];\n                    }\n                }\n                instance.$PS = null;\n            }\n            instance.$BR = false;\n        }\n    }\n    else {\n        instance.state = createDerivedState(instance, props, instance.state);\n    }\n    instance.$LI = renderNewInput(instance, props, context);\n    return instance;\n}\nfunction handleComponentInput(input) {\n    if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input, null);\n    }\n    else if (isArray(input)) {\n        input = createFragment(input, 0 /* UnknownChildren */, null);\n    }\n    else if (input.flags & 16384 /* InUse */) {\n        input = directClone(input);\n    }\n    return input;\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = (vNode.flags |= 16384 /* InUse */);\n    if (flags & 481 /* Element */) {\n        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 4 /* ComponentClass */) {\n        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 8 /* ComponentFunction */) {\n        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        mountText(vNode, parentDOM, nextNode);\n    }\n    else if (flags & 8192 /* Fragment */) {\n        mountFragment(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 1024 /* Portal */) {\n        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n    }\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n    mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n    var placeHolderVNode = createVoidVNode();\n    mountText(placeHolderVNode, parentDOM, nextNode);\n    vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n        children = vNode.children = createVoidVNode();\n    }\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        mount(children, parentDOM, nextNode, isSVG, nextNode, lifecycle);\n    }\n    else {\n        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = vNode.flags;\n    var props = vNode.props;\n    var className = vNode.className;\n    var ref = vNode.ref;\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;\n    var dom = documentCreateElement(vNode.type, isSVG);\n    vNode.dom = dom;\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (childFlags === 16 /* HasTextChildren */) {\n        setTextContent(dom, children);\n    }\n    else if (childFlags !== 1 /* HasInvalidChildren */) {\n        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            if (children.flags & 16384 /* InUse */) {\n                vNode.children = children = directClone(children);\n            }\n            mount(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n    }\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    mountRef(ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        var child = children[i];\n        if (child.flags & 16384 /* InUse */) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var ref = vNode.ref;\n    var input = handleComponentInput(vNode.flags & 32768 /* ForwardRef */ ? type(props, ref, context) : type(props, context));\n    vNode.children = input;\n    mount(input, parentDOM, context, isSVG, nextNode, lifecycle);\n    mountFunctionalComponentCallbacks(props, ref, vNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.componentDidMount();\n    };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n    mountRef(ref, instance, lifecycle);\n    if (isFunction(instance.componentDidMount)) {\n        lifecycle.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, vNode, props) {\n    return function () {\n        ref.onComponentDidMount(findDOMfromVNode(vNode, true), props);\n    };\n}\nfunction mountFunctionalComponentCallbacks(props, ref, vNode, lifecycle) {\n    if (!isNullOrUndef(ref)) {\n        if (isFunction(ref.onComponentWillMount)) {\n            ref.onComponentWillMount(props);\n        }\n        if (isFunction(ref.onComponentDidMount)) {\n            lifecycle.push(createOnMountCallback(ref, vNode, props));\n        }\n    }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastVNode);\n    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n        // Single DOM operation, when we have dom references available\n        mount(nextVNode, null, context, isSVG, null, lifecycle);\n        // Single DOM operation, when we have dom references available\n        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n    }\n    else {\n        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n        removeVNodeDOM(lastVNode, parentDOM);\n    }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);\n    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || (nextFlags & 2048 /* ReCreate */) !== 0) {\n        if (lastVNode.flags & 16384 /* InUse */) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n        }\n        else {\n            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n    }\n    else if (nextFlags & 4 /* ComponentClass */) {\n        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 8 /* ComponentFunction */) {\n        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else if (nextFlags & 8192 /* Fragment */) {\n        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context, lifecycle);\n    }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n    if (lastChildren !== nextChildren) {\n        if (lastChildren !== '') {\n            parentDOM.firstChild.nodeValue = nextChildren;\n        }\n        else {\n            setTextContent(parentDOM, nextChildren);\n        }\n    }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n    if (dom.textContent !== nextChildren) {\n        dom.textContent = nextChildren;\n    }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    var lastChildren = lastVNode.children;\n    var nextChildren = nextVNode.children;\n    var lastChildFlags = lastVNode.childFlags;\n    var nextChildFlags = nextVNode.childFlags;\n    var nextNode = null;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n        nextChildren = nextVNode.children = createVoidVNode();\n    }\n    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n    if (lastChildFlags & 12 /* MultipleChildren */) {\n        var lastLen = lastChildren.length;\n        // We need to know Fragment's edge node when\n        if (\n        // It uses keyed algorithm\n        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||\n            // It transforms from many to single\n            nextIsSingle ||\n            // It will append more nodes\n            (!nextIsSingle && nextChildren.length > lastLen)) {\n            // When fragment has multiple children there is always at least one vNode\n            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n        }\n    }\n    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n    var lastContainer = lastVNode.ref;\n    var nextContainer = nextVNode.ref;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        removeChild(lastContainer, node);\n        appendChild(nextContainer, node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n    var dom = lastVNode.dom;\n    var lastProps = lastVNode.props;\n    var nextProps = nextVNode.props;\n    var isFormElement = false;\n    var hasControlledValue = false;\n    var nextPropsOrEmpty;\n    nextVNode.dom = dom;\n    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n    // inlined patchProps  -- starts --\n    if (lastProps !== nextProps) {\n        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n        nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n        if (nextPropsOrEmpty !== EMPTY_OBJ) {\n            isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n            if (isFormElement) {\n                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n            }\n            for (var prop in nextPropsOrEmpty) {\n                var lastValue = lastPropsOrEmpty[prop];\n                var nextValue = nextPropsOrEmpty[prop];\n                if (lastValue !== nextValue) {\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n        if (lastPropsOrEmpty !== EMPTY_OBJ) {\n            for (var prop$1 in lastPropsOrEmpty) {\n                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n    }\n    var nextChildren = nextVNode.children;\n    var nextClassName = nextVNode.className;\n    // inlined patchProps  -- ends --\n    if (lastVNode.className !== nextClassName) {\n        if (isNullOrUndef(nextClassName)) {\n            dom.removeAttribute('class');\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', nextClassName);\n        }\n        else {\n            dom.className = nextClassName;\n        }\n    }\n    if (nextFlags & 4096 /* ContentEditable */) {\n        patchContentEditableChildren(dom, nextChildren);\n    }\n    else {\n        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n    }\n    if (isFormElement) {\n        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n    }\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, dom, lifecycle);\n    }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastChildren);\n    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n    removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                case 16 /* HasTextChildren */:\n                    unmount(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                case 16 /* HasTextChildren */:\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        case 16 /* HasTextChildren */:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    clearDOM(parentDOM);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    clearDOM(parentDOM);\n                    break;\n                default:\n                    clearDOM(parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        default:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    unmountAllChildren(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    break;\n                default:\n                    var lastLength = lastChildren.length | 0;\n                    var nextLength = nextChildren.length | 0;\n                    // Fast path's for both algorithms\n                    if (lastLength === 0) {\n                        if (nextLength > 0) {\n                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                        }\n                    }\n                    else if (nextLength === 0) {\n                        removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    }\n                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n                    }\n                    else {\n                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n                    }\n                    break;\n            }\n            break;\n    }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n    lifecycle.push(function () {\n        instance.componentDidUpdate(lastProps, lastState, snapshot);\n    });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    var usesNewAPI = Boolean(instance.$N);\n    var hasSCU = isFunction(instance.shouldComponentUpdate);\n    if (usesNewAPI) {\n        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n    }\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n            instance.componentWillUpdate(nextProps, nextState, context);\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        var snapshot = null;\n        var nextInput = renderNewInput(instance, nextProps, context);\n        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n        }\n        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n        // Dont update Last input, until patch has been succesfully executed\n        instance.$LI = nextInput;\n        if (isFunction(instance.componentDidUpdate)) {\n            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = (nextVNode.children = lastVNode.children);\n    // If Component has crashed, ignore it to stay functional\n    if (isNull(instance)) {\n        return;\n    }\n    instance.$L = lifecycle;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    var nextState = instance.state;\n    if (!instance.$N) {\n        if (isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (!isNull(instance.$PS)) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PS = null;\n        }\n    }\n    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, instance, lifecycle);\n    }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var shouldUpdate = true;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastProps = lastVNode.props;\n    var nextHooksDefined = !isNullOrUndef(nextRef);\n    var lastInput = lastVNode.children;\n    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n    }\n    if (shouldUpdate !== false) {\n        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n            nextRef.onComponentWillUpdate(lastProps, nextProps);\n        }\n        var type = nextVNode.type;\n        var nextInput = handleComponentInput(nextVNode.flags & 32768 /* ForwardRef */ ? type(nextProps, nextRef, context) : type(nextProps, context));\n        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n        nextVNode.children = nextInput;\n        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n            nextRef.onComponentDidUpdate(lastProps, nextProps);\n        }\n    }\n    else {\n        nextVNode.children = lastInput;\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = lastVNode.dom;\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n    nextVNode.dom = dom;\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; ++i) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.flags & 16384 /* InUse */) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; ++i) {\n            nextChild = nextChildren[i];\n            if (nextChild.flags & 16384 /* InUse */) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; ++i) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var i = 0;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    var nextNode;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[j] = bNode;\n            ++j;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                ++j;\n                mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        var aStart = j;\n        var bStart = j;\n        var aLeft = aEnd - j + 1;\n        var bLeft = bEnd - j + 1;\n        var sources = new Int32Array(bLeft - i + 1);\n        i = bLeft + 2;\n        // Keep track if its possible to remove whole DOM using textContent = '';\n        var canRemoveWholeContent = aLeft === aLength;\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        // When sizes are small, just loop them through\n        if (bLength < 4 || (aLeft | bLeft) < 32) {\n            for (i = aStart; i <= aEnd; ++i) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i + 1;\n                            if (canRemoveWholeContent) {\n                                canRemoveWholeContent = false;\n                                while (aStart < i) {\n                                    remove(a[aStart++], dom);\n                                }\n                            }\n                            if (pos > j) {\n                                moved = true;\n                            }\n                            else {\n                                pos = j;\n                            }\n                            if (bNode.flags & 16384 /* InUse */) {\n                                b[j] = bNode = directClone(bNode);\n                            }\n                            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                            ++patched;\n                            break;\n                        }\n                    }\n                    if (!canRemoveWholeContent && j > bEnd) {\n                        remove(aNode, dom);\n                    }\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n        }\n        else {\n            var keyIndex = {};\n            // Map keys by their index\n            for (i = bStart; i <= bEnd; ++i) {\n                keyIndex[b[i].key] = i;\n            }\n            // Try to patch same keys\n            for (i = aStart; i <= aEnd; ++i) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    j = keyIndex[aNode.key];\n                    if (j !== void 0) {\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (i > aStart) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        bNode = b[j];\n                        sources[j - bStart] = i + 1;\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.flags & 16384 /* InUse */) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                        ++patched;\n                    }\n                    else if (!canRemoveWholeContent) {\n                        remove(aNode, dom);\n                    }\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n        }\n        // fast-path: if nothing patched remove all old and add all new\n        if (canRemoveWholeContent) {\n            removeAllChildren(dom, parentVNode, a);\n            mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n        }\n        else if (moved) {\n            var seq = lis_algorithm(sources);\n            j = seq.length - 1;\n            for (i = bLeft - 1; i >= 0; i--) {\n                if (sources[i] === 0) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[pos] = bNode = directClone(bNode);\n                    }\n                    nextPos = pos + 1;\n                    mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n                }\n                else if (j < 0 || i !== seq[j]) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    nextPos = pos + 1;\n                    moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n                }\n                else {\n                    j--;\n                }\n            }\n        }\n        else if (patched !== bLeft) {\n            // when patched count doesn't match b length we need to insert those new ones\n            // loop backwards so we can use insertBefore\n            for (i = bLeft - 1; i >= 0; i--) {\n                if (sources[i] === 0) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[pos] = bNode = directClone(bNode);\n                    }\n                    nextPos = pos + 1;\n                    mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n                }\n            }\n        }\n    }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var arrI = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var u = 0;\n    var v = 0;\n    var c = 0;\n    var len = arr.length;\n    if (len > maxLen) {\n        maxLen = len;\n        result = new Int32Array(len);\n        p = new Int32Array(len);\n    }\n    for (; i < len; ++i) {\n        arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[k];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result[++k] = i;\n                continue;\n            }\n            u = 0;\n            v = k;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = i = k + 1;\n    var seq = new Int32Array(u);\n    v = result[u - 1];\n    while (u-- > 0) {\n        seq[u] = v;\n        v = p[v];\n    }\n    while (i-- > 0) {\n        result[i] = 0;\n    }\n    return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nvar documentBody = null;\nif (hasDocumentAvailable) {\n    documentBody = document.body;\n    /*\n     * Defining $EV and $V properties on Node.prototype\n     * fixes v8 \"wrong map\" de-optimization\n     */\n    Node.prototype.$EV = null;\n    Node.prototype.$V = null;\n}\nfunction __render(input, parentDOM, callback, context) {\n    var lifecycle = [];\n    var rootInput = parentDOM.$V;\n    renderCheck.v = true;\n    if (isNullOrUndef(rootInput)) {\n        if (!isNullOrUndef(input)) {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            mount(input, parentDOM, context, false, null, lifecycle);\n            parentDOM.$V = input;\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDOM);\n            parentDOM.$V = null;\n        }\n        else {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n            rootInput = parentDOM.$V = input;\n        }\n    }\n    if (lifecycle.length > 0) {\n        callAll(lifecycle);\n    }\n    renderCheck.v = false;\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput, parentDOM);\n    }\n}\nfunction render(input, parentDOM, callback, context) {\n    if ( callback === void 0 ) callback = null;\n    if ( context === void 0 ) context = EMPTY_OBJ;\n\n    __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n    return function renderer(lastInput, nextInput, callback, context) {\n        if (!parentDOM) {\n            parentDOM = lastInput;\n        }\n        render(nextInput, parentDOM, callback, context);\n    };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout.bind(window);\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n    var pending = component.$PS;\n    if (isFunction(newState)) {\n        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n    }\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$BR) {\n        if (!renderCheck.v) {\n            if (QUEUE.length === 0) {\n                applyState(component, force, callback);\n                return;\n            }\n        }\n        if (QUEUE.indexOf(component) === -1) {\n            QUEUE.push(component);\n        }\n        if (!microTaskPending) {\n            microTaskPending = true;\n            nextTick(rerender);\n        }\n        if (isFunction(callback)) {\n            var QU = component.$QU;\n            if (!QU) {\n                QU = component.$QU = [];\n            }\n            QU.push(callback);\n        }\n    }\n    else if (isFunction(callback)) {\n        component.$L.push(callback.bind(component));\n    }\n}\nfunction callSetStateCallbacks(component) {\n    var queue = component.$QU;\n    for (var i = 0, len = queue.length; i < len; ++i) {\n        queue[i].call(component);\n    }\n    component.$QU = null;\n}\nfunction rerender() {\n    var component;\n    microTaskPending = false;\n    while ((component = QUEUE.pop())) {\n        var queue = component.$QU;\n        applyState(component, false, queue ? callSetStateCallbacks.bind(null, component) : null);\n    }\n}\nfunction applyState(component, force, callback) {\n    if (component.$UN) {\n        return;\n    }\n    if (force || !component.$BR) {\n        var pendingState = component.$PS;\n        component.$PS = null;\n        var lifecycle = [];\n        renderCheck.v = true;\n        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n        if (lifecycle.length > 0) {\n            callAll(lifecycle);\n        }\n        renderCheck.v = false;\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n    if (isFunction(callback)) {\n        callback.call(component);\n    }\n}\nvar Component = function Component(props, context) {\n    // Public\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$QU = null; // QUEUE\n    this.$N = false; // Uses new lifecycle API Flag\n    this.$L = null; // Current lifecycle of this component\n    this.$SVG = false; // Flag to keep track if component is inside SVG tree\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n    else {\n        return;\n    }\n};\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) {\n    return null;\n};\n\nvar version = \"7.1.10\";\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/index.esm.js":
/*!*******************************************!*\
  !*** ./node_modules/inferno/index.esm.js ***!
  \*******************************************/
/*! exports provided: Component, Fragment, EMPTY_OBJ, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, forwardRef, directClone, findDOMfromVNode, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version, _CI, _HI, _M, _MCCC, _ME, _MFCC, _MR, _MT, _MP, __render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.esm.js */ \"./node_modules/inferno/dist/index.esm.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"EMPTY_OBJ\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createFragment\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createFragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createPortal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createRenderer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createTextVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"forwardRef\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"forwardRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"directClone\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"findDOMfromVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"findDOMfromVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"linkEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"normalizeProps\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"options\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rerender\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"rerender\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"version\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_CI\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_CI\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_HI\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_HI\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_M\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_M\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MCCC\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MCCC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_ME\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_ME\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MFCC\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MFCC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MR\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MR\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MT\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MT\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MP\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MP\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__render\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"__render\"]; });\n\n\n\nif (true) {\n  console.warn('You are running production build of Inferno in development mode. Use dev:module entry point.');\n}\n\n\n//# sourceURL=webpack:///./node_modules/inferno/index.esm.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/CodeBrowser.js":
/*!****************************!*\
  !*** ./src/CodeBrowser.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// A simple browser for Formality Code\n\nconst {Component, render} = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\nconst h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\nconst fm = __webpack_require__(/*! ./../../Formality-JavaScript */ \"../Formality-JavaScript/src/exports.js\");\n\nclass Code extends Component {\n\n  constructor(props) {\n    super(props);\n\n    this.file = null;   // String           -- name of the loaded file\n    this.code = null;   // String           -- the loaded code\n    this.defs = null;   // {[String]: Term} -- the defs inside that code\n    this.tokens = null; // [[String, Info]] -- chunks of code with syntax highlight info\n\n    if (props.code) this.load_code(props.code);\n    if (props.file) this.load_file(props.file);\n  }\n\n  // Loads a file (ex: \"Data.Bool@0\")\n  async load_file(file) {\n    await this.load_code(await fm.lang.load_file(file));\n    this.file = file;\n  }\n\n  // Loads a code\n  async load_code(code) {\n    this.file = null;\n    this.code = code;\n    var {defs, tokens} = await fm.lang.parse(\"test_file\", this.code, true);\n    this.defs = defs;\n    this.tokens = tokens;\n    this.forceUpdate();\n  }\n\n  // Loads file/code from propps\n  componentWillReceiveProps(props) {\n    if (props.code) this.load_code(props.code);\n    if (props.file) this.load_file(props.file);\n  }\n\n  // Type-checks a definition \n  typecheck(name) {\n    try {\n      var type = fm.lang.show(fm.lang.norm(this.defs[name], this.defs, \"TYPE\", {}));\n      var good = true;\n    } catch (e) {\n      var type = e.toString().replace(/\\[[0-9]m/g, \"\").replace(/\\[[0-9][0-9]m/g, \"\");\n      var good = false;\n    }\n    var text = \"\";\n    if (good) {\n      text += \"✓ \" + name + \" : \" + type + \"\\n\\nTerm checked successfully!\";\n    } else {\n      text += \"✗ \" + name + \"\\n\\n\" + type;\n    }\n    alert(text);\n  }\n\n  // Normalizes a definition\n  normalize(name) {\n    try {\n      var norm = fm.lang.show(fm.lang.norm(this.defs[name], this.defs, \"DEBUG\", {}));\n    } catch (e) {\n      var norm = \"<unable_to_normalize>\";\n    };\n    alert(norm);\n  }\n\n  async componentDidMount() {\n  }\n\n  // Event when user clicks a definition \n  onClickDef(path) {\n    return e => {\n      if (!e.shiftKey) {\n        return this.typecheck(path);\n      } else {\n        return this.normalize(path);\n      }\n    }\n  }\n\n  // Event when user clicks a reference\n  onClickRef(path) {\n    return e => {\n      console.log(\"...\", path);\n      this.load_file(path.slice(0, path.indexOf(\"/\")));\n    }\n  }\n\n  // Renders the interface\n  render() {\n    if (!this.tokens) {\n      return h(\"div\", {}, \"Loading code...\");\n    }\n\n    var code_chunks = [];\n    for (var i = 0; i < this.tokens.length; ++i) {\n      var attrs = (() => {\n        switch (this.tokens[i][0]) {\n          case \"txt\" : return {style: {\"color\": \"black\"}};\n          case \"sym\" : return {style: {\"color\": \"#15568f\"}};\n          case \"cmm\" : return {style: {\"color\": \"#A2A8D3\"}};\n          case \"num\" : return {style: {\"color\": \"green\"}};\n          case \"var\" : return {style: {\"color\": \"black\"}};\n          case \"ref\" : return {style: {\"color\": \"#38598B\", \"text-decoration\": \"underline\", \"font-weight\": \"bold\", \"cursor\": \"pointer\"}, onClick: this.onClickRef(this.tokens[i][2])};\n          case \"def\" : return {style: {\"color\": \"#4384e6\", \"text-decoration\": \"underline\", \"font-weight\": \"bold\", \"cursor\": \"pointer\"}, onClick: this.onClickDef(this.tokens[i][2])}; \n          default    : return {};\n        }\n      })();\n      code_chunks.push(h(\"span\", attrs, (this.tokens[i][1])));\n    }\n\n    return h(\"code\", {}, h(\"pre\", {}, code_chunks));\n  }\n\n}\n\nmodule.exports = Code;\n\n\n//# sourceURL=webpack:///./src/CodeBrowser.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Component, render} = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\nconst h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\nconst fm = __webpack_require__(/*! ./../../Formality-JavaScript */ \"../Formality-JavaScript/src/exports.js\");\nconst CodeBrowser = __webpack_require__(/*! ./CodeBrowser.js */ \"./src/CodeBrowser.js\");\n\nclass Main extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {defs: null};\n    this.elems = [];\n  }\n\n  render() {\n    return h(\"div\", {style: {\"font-family\": \"Gotham Book\"}}, [\n      h(\"div\", {style: {\n        \"background\": \"white\",\n        \"margin-bottom\": \"24px\",\n        \"border-bottom\": \"1px solid gray\",\n        \"display\": \"flex\",\n        \"flex-flow\": \"row nowrap\",\n        \"align-items\": \"center\",\n        \"height\": \"44px\"\n        }}, [\n          h(\"img\", {style: {\"width\": \"42px\"}, src: \"assets/fm-logo.png\"}),\n          h(\"span\", {style: {\n            \"padding-top\": \"6px\",\n            \"font-family\": \"Gotham Book\"}},\n            \"Provit!\")\n        ]),\n      h(\"div\", {style: {\n        \"display\": \"flex\",\n        \"flex-flow\": \"column nowrap\",\n        \"align-items\": \"center\",\n        }}, [\n          h(\"div\", {style: {\n            \"background\": \"white\",\n            \"padding\": \"8px\",\n            \"border-radius\": \"6px\",\n            \"box-shadow\": \"0px 0px 6px 0px rgba(0,0,0,0.5)\"\n          }}, h(CodeBrowser, {file: \"SimpleProofExample@0\"}))])\n    ]);\n  }\n}\n\nwindow.onload = () => {\n  render(h(Main), document.getElementById(\"main\"));\n};\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });