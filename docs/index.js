/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../Formality-JavaScript/FM-Core/exports.js":
/*!**************************************************!*\
  !*** ../Formality-JavaScript/FM-Core/exports.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var fm = module.exports = {\n  core: __webpack_require__(/*! ./fm-core.js */ \"../Formality-JavaScript/FM-Core/fm-core.js\"),\n  lang: __webpack_require__(/*! ./fm-lang.js */ \"../Formality-JavaScript/FM-Core/fm-lang.js\"),\n  net: __webpack_require__(/*! formality-net */ \"../Formality-JavaScript/FM-Core/node_modules/formality-net/fm-net.js\"),\n  to_net: __webpack_require__(/*! ./fm-to-net.js */ \"../Formality-JavaScript/FM-Core/fm-to-net.js\"),\n  to_js: __webpack_require__(/*! ./fm-to-js.js */ \"../Formality-JavaScript/FM-Core/fm-to-js.js\"),\n  norm,\n  check,\n  exec\n};\n\nfunction norm(term, defs, mode = \"OPTIMAL_LAZY\", stats = {}) {\n  switch (mode) {\n    case \"DEBUG\":\n      return fm.lang.norm(fm.lang.erase(term, defs), defs, false);\n    case \"INTERPRETED\":\n      return fm.lang.norm(fm.lang.erase(term, defs), defs, true);\n    case \"JAVASCRIPT\":\n      return fm.to_js.decompile(fm.to_js.compile(fm.lang.erase(term, defs), defs));\n    case \"OPTIMAL_STRICT\":\n    case \"OPTIMAL_LAZY\":\n      var net = fm.to_net.compile(fm.lang.erase(term, defs), defs);\n      if (stats && stats.input_net === null) {\n        stats.input_net = JSON.parse(JSON.stringify(net));\n      }\n      if (mode === \"OPTIMAL_LAZY\") {\n        var new_stats = net.reduce_lazy(stats || {});\n      } else {\n        var new_stats = net.reduce_strict(stats || {});\n      }\n      if (stats && stats.output_net !== undefined) {\n        stats.output_net = JSON.parse(JSON.stringify(net));\n      }\n      return fm.to_net.decompile(net);\n    case \"TYPE\":\n      return fm.lang.norm(fm.lang.typecheck(term, null, defs), {}, false);\n  }\n}\n\nfunction exec(name, defs, infs, mode = \"OPTIMAL_LAZY\", bipass = false, stats = {}) {\n  if (defs[name] && defs[name][0] === \"Ref\" && !defs[defs[name][1].name]) {\n    name = defs[name][1].name;\n  }\n  if (defs[name]) {\n    var checked = check(defs[name], defs, bipass);\n    var result = fm.norm(checked, defs, mode, stats);\n    return result;\n  } else {\n    throw \"Definition '\" + name + \"' not found.\";\n  }\n}\n\nfunction check(term, defs, bipass = false) {\n  if (!bipass) {\n    try {\n      fm.lang.boxcheck(term, defs);\n      return term;\n    } catch (e) {\n      console.log(e);\n      process.exit();\n    }\n  } else {\n    return term;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../Formality-Lab/node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///../Formality-JavaScript/FM-Core/exports.js?");

/***/ }),

/***/ "../Formality-JavaScript/FM-Core/fm-core.js":
/*!**************************************************!*\
  !*** ../Formality-JavaScript/FM-Core/fm-core.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Core Language ~~\n\n// ::::::::::\n// :: Term ::\n// ::::::::::\n\n// An FM-Lang term is an ADT represented as a JSON.\n// - Var: a variable\n// - Typ: the type of types, `Type`\n// - All: the dependent function type, `{x : A} -> B`, optionally erased\n// - Lam: a lambda, `{x} => B`, optionally erased/annotated\n// - App: an application `(f a)`, optionally erased\n// - Box: a boxed type, `!A`\n// - Put: a boxed value, `#a`\n// - Dup: copies a boxed value, `dup x = a; b`\n// - U32: type of a native number\n// - Num: value of a native number\n// - Op1: partially applied binary numeric operation, `|n + k|`, with `k` fixed\n// - Op2: binary numeric operation, `|x + y|`\n// - Ite: if-then-else, `if n p`,  with a numeric conditional `n`, and two branches in a pair `p`\n// - Cpy: copies a number, `cpy x = a; b`\n// - Sig: type of a dependent pair, `[x : A, (B x)]`, or of a dependent intersection, `[x : A ~ (B x)]`\n// - Par: value of a dependent pair, `[a, b]`, or of a dependent intersection `[a ~ b]`\n// - Fst: extracts 1st value of a dependent pair, `fst p`, or of a dependent intersection, `~fst p`\n// - Snd: extracts 2nd value of a dependent pair, `snd p`, or of a dependent intersection, `~snd p`\n// - Prj: projects a dependent pair, `get [x , y] = a; b`, or a dependent intersection, `get [x ~ y] = a; b`\n// - Eql: erased untyped equality type, `<a = b>`\n// - Rfl: reflexivity, i.e., a proof that a value is equal to itself, `$a`\n// - Sym: symmetry of equality, `sym e`\n// - Rwt: rewrite equal terms in types, `rwt e <x @ (P x)> a`\n// - Cst: casts a value to the type of another value equal to it, `cst e a b`\n// - Ann: an explicit type annotaion, `: A a`\n// - Ref: a reference to a global def\nconst Var = (index)                        => [\"Var\", {index}];\nconst Typ = ()                             => [\"Typ\", {}];\nconst All = (name, bind, body, eras)       => [\"All\", {name, bind, body, eras}];\nconst Lam = (name, bind, body, eras)       => [\"Lam\", {name, bind, body, eras}];\nconst App = (func, argm, eras)             => [\"App\", {func, argm, eras}];\nconst Box = (expr)                         => [\"Box\", {expr}];\nconst Put = (expr)                         => [\"Put\", {expr}];\nconst Dup = (name, expr, body)             => [\"Dup\", {name, expr, body}];\nconst U32 = ()                             => [\"U32\", {}];\nconst Num = (numb)                         => [\"Num\", {numb}];\nconst Op1 = (func, num0, num1)             => [\"Op1\", {func, num0, num1}];\nconst Op2 = (func, num0, num1)             => [\"Op2\", {func, num0, num1}];\nconst Ite = (cond, pair)                   => [\"Ite\", {cond, pair}];\nconst Cpy = (name, numb, body)             => [\"Cpy\", {name, numb, body}];\nconst Sig = (name, typ0, typ1, eras)       => [\"Sig\", {name, typ0, typ1, eras}];\nconst Par = (val0, val1, eras)             => [\"Par\", {val0, val1, eras}];\nconst Fst = (pair, eras)                   => [\"Fst\", {pair, eras}];\nconst Snd = (pair, eras)                   => [\"Snd\", {pair, eras}];\nconst Prj = (nam0, nam1, pair, body, eras) => [\"Prj\", {nam0, nam1, pair, body, eras}];\nconst Eql = (val0, val1)                   => [\"Eql\", {val0, val1}];\nconst Rfl = (expr)                         => [\"Rfl\", {expr}];\nconst Sym = (prof)                         => [\"Sym\", {prof}];\nconst Rwt = (prof, name, type, expr)       => [\"Rwt\", {prof, name, type, expr}];\nconst Cst = (prof, val0, val1)             => [\"Cst\", {prof, val0, val1}];\nconst Slf = (name, type)                   => [\"Slf\", {name, type}];\nconst New = (type, expr)                   => [\"New\", {type, expr}];\nconst Use = (expr)                         => [\"Use\", {expr}];\nconst Ann = (type, expr, done)             => [\"Ann\", {type, expr, done}];\nconst Ref = (name, eras)                   => [\"Ref\", {name, eras}];\n\n// ::::::::::::::::::\n// :: Substitution ::\n// ::::::::::::::::::\n\n// Shifts a term\nconst shift = ([ctor, term], inc, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index < depth ? term.index : term.index + inc);\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var name = term.name;\n      var bind = shift(term.bind, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      var eras = term.eras;\n      return All(name, bind, body, eras);\n    case \"Lam\":\n      var name = term.name;\n      var bind = term.bind && shift(term.bind, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      var eras = term.eras;\n      return Lam(name, bind, body, eras);\n    case \"App\":\n      var func = shift(term.func, inc, depth);\n      var argm = shift(term.argm, inc, depth);\n      var eras = term.eras;\n      return App(func, argm, term.eras);\n    case \"Box\":\n      var expr = shift(term.expr, inc, depth);\n      return Box(expr);\n    case \"Put\":\n      var expr = shift(term.expr, inc, depth);\n      return Put(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = shift(term.expr, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Dup(name, expr, body);\n    case \"U32\":\n      return U32();\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = shift(term.num0, inc, depth);\n      var num1 = shift(term.num1, inc, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = shift(term.cond, inc, depth);\n      var pair = shift(term.pair, inc, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = shift(term.numb, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Cpy(name, numb, body);\n    case \"Sig\":\n      var name = term.name;\n      var typ0 = shift(term.typ0, inc, depth);\n      var typ1 = shift(term.typ1, inc, depth + 1);\n      var eras = term.eras;\n      return Sig(name, typ0, typ1, eras);\n    case \"Par\":\n      var val0 = shift(term.val0, inc, depth);\n      var val1 = shift(term.val1, inc, depth);\n      var eras = term.eras;\n      return Par(val0, val1, eras);\n    case \"Fst\":\n      var pair = shift(term.pair, inc, depth);\n      var eras = term.eras;\n      return Fst(pair, eras);\n    case \"Snd\":\n      var pair = shift(term.pair, inc, depth);\n      var eras = term.eras;\n      return Snd(pair, eras);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = shift(term.pair, inc, depth);\n      var body = shift(term.body, inc, depth + 2);\n      var eras = term.eras;\n      return Prj(nam0, nam1, pair, body, eras);\n    case \"Eql\":\n      var val0 = shift(term.val0, inc, depth);\n      var val1 = shift(term.val1, inc, depth);\n      return Eql(val0, val1);\n    case \"Rfl\":\n      var expr = shift(term.expr, inc, depth);\n      return Rfl(expr);\n    case \"Sym\":\n      var prof = shift(term.prof, inc, depth);\n      return Sym(prof);\n    case \"Rwt\":\n      var prof = shift(term.prof, inc, depth);\n      var name = term.name;\n      var type = shift(term.type, inc, depth + 1);\n      var expr = shift(term.expr, inc, depth);\n      return Rwt(prof, name, type, expr);\n    case \"Cst\":\n      var prof = shift(term.prof, inc, depth);\n      var val0 = shift(term.val0, inc, depth);\n      var val1 = shift(term.val1, inc, depth);\n      return Cst(prof, val0, val1);\n    case \"Slf\":\n      var name = term.name;\n      var type = shift(term.type, inc, depth + 1);\n      return Slf(name, type);\n    case \"New\":\n      var type = shift(term.type, inc, depth);\n      var expr = shift(term.expr, inc, depth);\n      return New(type, expr);\n    case \"Use\":\n      var expr = shift(term.expr, inc, depth);\n      return Use(expr);\n    case \"Ann\":\n      var type = shift(term.type, inc, depth);\n      var expr = shift(term.expr, inc, depth);\n      var done = term.done;\n      return Ann(type, expr, done);\n    case \"Ref\":\n      return Ref(term.name, term.eras);\n  }\n}\n\n// Substitution\nconst subst = ([ctor, term], val, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return depth === term.index ? val : Var(term.index - (term.index > depth ? 1 : 0));\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var name = term.name;\n      var bind = subst(term.bind, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      var eras = term.eras;\n      return All(name, bind, body, eras);\n    case \"Lam\":\n      var name = term.name;\n      var bind = term.bind && subst(term.bind, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      var eras = term.eras;\n      return Lam(name, bind, body, eras);\n    case \"App\":\n      var func = subst(term.func, val, depth);\n      var argm = subst(term.argm, val, depth);\n      var eras = term.eras;\n      return App(func, argm, eras);\n    case \"Box\":\n      var expr = subst(term.expr, val, depth);\n      return Box(expr);\n    case \"Put\":\n      var expr = subst(term.expr, val, depth);\n      return Put(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = subst(term.expr, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Dup(name, expr, body);\n    case \"U32\":\n      return U32();\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = subst(term.num0, val, depth);\n      var num1 = subst(term.num1, val, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = subst(term.cond, val, depth);\n      var pair = subst(term.pair, val, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = subst(term.numb, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Cpy(name, numb, body);\n    case \"Sig\":\n      var name = term.name;\n      var typ0 = subst(term.typ0, val, depth);\n      var typ1 = subst(term.typ1, val && shift(val, 1, 0), depth + 1);\n      var eras = term.eras;\n      return Sig(name, typ0, typ1, eras);\n    case \"Par\":\n      var val0 = subst(term.val0, val, depth);\n      var val1 = subst(term.val1, val, depth);\n      var eras = term.eras;\n      return Par(val0, val1, eras);\n    case \"Fst\":\n      var pair = subst(term.pair, val, depth);\n      var eras = term.eras;\n      return Fst(pair, eras);\n    case \"Snd\":\n      var pair = subst(term.pair, val, depth);\n      var eras = term.eras;\n      return Snd(pair, eras);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = subst(term.pair, val, depth);\n      var body = subst(term.body, val && shift(val, 2, 0), depth + 2);\n      var eras = term.eras;\n      return Prj(nam0, nam1, pair, body, eras);\n    case \"Eql\":\n      var val0 = subst(term.val0, val, depth);\n      var val1 = subst(term.val1, val, depth);\n      return Eql(val0, val1);\n    case \"Rfl\":\n      var expr = subst(term.expr, val, depth);\n      return Rfl(expr);\n    case \"Sym\":\n      var prof = subst(term.prof, val, depth);\n      return Sym(prof);\n    case \"Rwt\":\n      var prof = subst(term.prof, val, depth);\n      var name = term.name;\n      var type = subst(term.type, val && shift(val, 1, 0), depth + 1);\n      var expr = subst(term.expr, val, depth);\n      return Rwt(prof, name, type, expr);\n    case \"Cst\":\n      var prof = subst(term.prof, val, depth);\n      var val0 = subst(term.val0, val, depth);\n      var val1 = subst(term.val1, val, depth);\n      return Cst(prof, val0, val1);\n    case \"Slf\":\n      var name = term.name;\n      var type = subst(term.type, val && shift(val, 1, 0), depth + 1);\n      return Slf(name, type);\n    case \"New\":\n      var type = subst(term.type, val, depth);\n      var expr = subst(term.expr, val, depth);\n      return New(type, expr);\n    case \"Use\":\n      var expr = subst(term.expr, val, depth);\n      return Use(expr);\n    case \"Ann\":\n      var type = subst(term.type, val, depth);\n      var expr = subst(term.expr, val, depth);\n      var done = term.done;\n      return Ann(type, expr, done);\n    case \"Ref\":\n      var name = term.name;\n      return Ref(name, term.eras);\n  }\n}\n\nconst subst_many = (term, vals, depth) => {\n  for (var i = 0; i < vals.length; ++i) {\n    term = subst(term, shift(vals[i], vals.length - i - 1, 0), depth + vals.length - i - 1);\n  }\n  return term;\n}\n\n// ::::::::::::::::\n// :: Evaluation ::\n// ::::::::::::::::\n\n// Reduces a term to normal form or head normal form\nconst norm = (term, defs = {}, weak = false) => {\n  const apply = (func, argm, eras) => {\n    var func = reduce(func);\n    // ([x]a b) ~> [b/x]a\n    if (func[0] === \"Lam\") {\n      return reduce(func[1].body(argm));\n    // ((dup x = a; b) c) ~> dup x = a; (b c)\n    } else if (func[0] === \"Dup\") {\n      return Dup(func[1].name, func[1].expr, x => weak_reduce(App(func[1].body(x), argm, eras)));\n    // (|a b) ~> ⊥\n    } else if (func[0] === \"Put\") {\n      throw \"[RUNTIME-ERROR]\\nCan't apply a boxed value.\";\n    } else {\n      return App(func, weak_reduce(argm), eras);\n    }\n  }\n  const duplicate = (name, expr, body) => {\n    var expr = reduce(expr);\n    // [x = |a] b ~> [a/x]b\n    if (expr[0] === \"Put\") {\n      return reduce(body(expr[1].expr));\n    // dup x = (dup y = a; b); c ~> dup y = a; dup x = b; c\n    } else if (expr[0] === \"Dup\") {\n      return Dup(expr[1].name, expr[1].expr, x => weak_reduce(Dup(name, expr[1].body(x), x => body(x))));\n    // dup x = {y} b; c ~> ⊥\n    } else if (expr[0] === \"Lam\") {\n      throw \"[RUNTIME-ERROR]\\nCan't duplicate a lambda.\";\n    } else {\n      return Dup(name, expr, x => weak_reduce(body(x)));\n    }\n  }\n  const dereference = (name, eras) => {\n    if (defs[name]) {\n      return reduce(unquote(eras ? erase(defs[name], defs) : defs[name], []));\n    } else {\n      return Ref(name, eras);\n    }\n  }\n  const op1 = (func, num0, num1) => {\n    var num0 = reduce(num0);\n    if (num0[0] === \"Num\") {\n      switch (func) {\n        case \"+\"  : return Num((num0[1].numb + num1[1].numb) >>> 0);\n        case \"-\"  : return Num((num0[1].numb - num1[1].numb) >>> 0);\n        case \"*\"  : return Num((num0[1].numb * num1[1].numb) >>> 0);\n        case \"/\"  : return Num((num0[1].numb / num1[1].numb) >>> 0);\n        case \"%\"  : return Num((num0[1].numb % num1[1].numb) >>> 0);\n        case \"**\" : return Num((num0[1].numb ** num1[1].numb) >>> 0);\n        case \"^^\" : return Num((num0[1].numb ** (num1[1].numb / (2 ** 32))) >>> 0);\n        case \"&\"  : return Num((num0[1].numb & num1[1].numb) >>> 0);\n        case \"|\"  : return Num((num0[1].numb | num1[1].numb) >>> 0);\n        case \"^\"  : return Num((num0[1].numb ^ num1[1].numb) >>> 0);\n        case \"~\"  : return Num((~ num1[1].numb) >>> 0);\n        case \">>\" : return Num((num0[1].numb >>> num1[1].numb) >>> 0);\n        case \"<<\" : return Num((num0[1].numb << num1[1].numb) >>> 0);\n        case \">\"  : return Num((num0[1].numb > num1[1].numb ? 1 : 0) >>> 0);\n        case \"<\"  : return Num((num0[1].numb < num1[1].numb ? 1 : 0) >>> 0);\n        case \"==\" : return Num((num0[1].numb === num1[1].numb ? 1 : 0) >>> 0);\n        default   : throw \"[RUNTIME-ERROR]\\nUnknown primitive: \" + func + \".\";\n      }\n    } else {\n      return Op1(func, num0, num1);\n    }\n  }\n  const op2 = (func, num0, num1) => {\n    var num1 = reduce(num1);\n    if (num1[0] === \"Num\") {\n      return reduce(Op1(func, num0, num1, null));\n    } else {\n      return Op2(func, weak_reduce(num0), num1);\n    }\n  }\n  const if_then_else = (cond, pair) => {\n    var cond = reduce(cond);\n    if (cond[0] === \"num\") {\n      return cond[1].numb > 0 ? reduce(Fst(pair, false, null)) : reduce(Snd(pair, false, null));\n    } else {\n      return Ite(cond, weak_reduce(pair));\n    }\n  }\n  const copy = (name, numb, body) => {\n    var numb = reduce(numb);\n    if (numb[0] === \"Num\") {\n      return reduce(body(numb));\n    } else {\n      return Cpy(name, numb, weak_reduce(body));\n    }\n  }\n  const first = (pair, eras) => {\n    var pair = reduce(pair);\n    if (pair[0] === \"Par\") {\n      return pair[1].val0;\n    } else {\n      return Fst(pair, eras);\n    }\n  }\n  const second = (pair, eras) => {\n    var pair = reduce(pair);\n    if (pair[0] === \"Par\") {\n      return pair[1].val1;\n    } else {\n      return Snd(pair, eras);\n    }\n  }\n  const project = (nam0, nam1, pair, body, eras) => {\n    var pair = reduce(pair);\n    if (pair[0] === \"Par\") {\n      return reduce(body(pair[1].val0, pair[1].val1));\n    } else {\n      return Prj(nam0, nam1, pair, (x,y) => weak_reduce(body(x,y)), eras);\n    }\n  }\n  const unquote = (term, vars) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return vars[term.index] || Var(vars.length - term.index - 1);\n      case \"Typ\": return Typ();\n      case \"All\": return All(term.name, unquote(term.bind, vars), x => unquote(term.body, [x].concat(vars)), term.eras);\n      case \"Lam\": return Lam(term.name, term.bind && unquote(term.bind, vars), x => unquote(term.body, [x].concat(vars)), term.eras);\n      case \"App\": return App(unquote(term.func, vars), unquote(term.argm, vars), term.eras);\n      case \"Box\": return Box(unquote(term.expr, vars));\n      case \"Put\": return Put(unquote(term.expr, vars));\n      case \"Dup\": return Dup(term.name, unquote(term.expr, vars), x => unquote(term.body, [x].concat(vars)));\n      case \"U32\": return U32();\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return Op1(term.func, unquote(term.num0, vars), unquote(term.num1, vars));\n      case \"Op2\": return Op2(term.func, unquote(term.num0, vars), unquote(term.num1, vars));\n      case \"Ite\": return Ite(unquote(term.cond, vars), unquote(term.pair, vars));\n      case \"Cpy\": return Cpy(term.name, unquote(term.numb, vars), x => unquote(term.body, [x].concat(vars)));\n      case \"Sig\": return Sig(term.name, unquote(term.typ0, vars), x => unquote(term.typ1, [x].concat(vars)), term.eras);\n      case \"Par\": return Par(unquote(term.val0, vars), unquote(term.val1, vars), term.eras);\n      case \"Fst\": return Fst(unquote(term.pair, vars), term.eras);\n      case \"Snd\": return Snd(unquote(term.pair, vars), term.eras);\n      case \"Prj\": return Prj(term.nam0, term.nam1, unquote(term.pair, vars), (x,y) => unquote(term.body, [y,x].concat(vars)), term.eras);\n      case \"Eql\": return Eql(unquote(term.val0, vars), unquote(term.val1, vars));\n      case \"Rfl\": return Rfl(unquote(term.expr, vars));\n      case \"Sym\": return Sym(unquote(term.prof, vars));\n      case \"Rwt\": return Rwt(unquote(term.prof, vars), term.name, unquote(term.type, vars), unquote(term.expr, vars));\n      case \"Cst\": return Cst(unquote(term.prof, vars), unquote(term.val1, vars), unquote(term.val1, vars));\n      case \"Slf\": return Slf(term.name, x => unquote(term.type, [x].concat(vars)));\n      case \"New\": return New(unquote(term.type, vars), unquote(term.expr, vars));\n      case \"Use\": return Use(unquote(term.expr, vars));\n      case \"Ann\": return Ann(unquote(term.type, vars), unquote(term.expr, vars), term.done);\n      case \"Ref\": return Ref(term.name, term.eras);\n    }\n  };\n  const reduce = (term) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return Var(term.index);\n      case \"Typ\": return Typ();\n      case \"All\": return All(term.name, term.bind, term.body, term.eras);\n      case \"Lam\": return Lam(term.name, term.bind, x => weak_reduce(term.body(x)), term.eras);\n      case \"App\": return apply(term.func, term.argm, term.eras);\n      case \"Box\": return Box(weak_reduce(term.expr));\n      case \"Put\": return Put(weak_reduce(term.expr));\n      case \"Dup\": return duplicate(term.name, term.expr, term.body);\n      case \"U32\": return U32();\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return op1(term.func, term.num0, term.num1);\n      case \"Op2\": return op2(term.func, term.num0, term.num1);\n      case \"Ite\": return if_then_else(term.cond, term.pair);\n      case \"Cpy\": return copy(term.name, term.numb, term.body);\n      case \"Sig\": return Sig(term.name, term.typ0, term.typ1, term.eras);\n      case \"Par\": return Par(weak_reduce(term.val0), weak_reduce(term.val1), term.eras);\n      case \"Fst\": return first(term.pair, term.eras);\n      case \"Snd\": return second(term.pair, term.eras);\n      case \"Prj\": return project(term.nam0, term.nam1, term.pair, term.body, term.eras);\n      case \"Eql\": return Eql(term.val0, term.val1);\n      case \"Rfl\": return Rfl(weak_reduce(term.expr));\n      case \"Sym\": return reduce(term.prof);\n      case \"Rwt\": return reduce(term.expr);\n      case \"Cst\": return reduce(term.val1);\n      case \"Slf\": return Slf(term.name, x => weak_reduce(term.type(x)));\n      case \"New\": return reduce(term.expr);\n      case \"Use\": return reduce(term.expr);\n      case \"Ann\": return reduce(term.expr);\n      case \"Ref\": return dereference(term.name, term.eras);\n    }\n  };\n  const weak_reduce = (term) => {\n    return weak ? term : reduce(term);\n  };\n  const quote = (term, depth) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return Var(depth - 1 - term.index);\n      case \"Typ\": return Typ();\n      case \"All\": return All(term.name, quote(term.bind, depth), quote(term.body(Var(depth)), depth + 1), term.eras);\n      case \"Lam\": return Lam(term.name, term.bind && quote(term.bind, depth), quote(term.body(Var(depth)), depth + 1), term.eras);\n      case \"App\": return App(quote(term.func, depth), quote(term.argm, depth), term.eras);\n      case \"Box\": return Box(quote(term.expr, depth));\n      case \"Put\": return Put(quote(term.expr, depth));\n      case \"Dup\": return Dup(term.name, quote(term.expr, depth), quote(term.body(Var(depth)), depth + 1));\n      case \"U32\": return U32();\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return Op1(term.func, quote(term.num0, depth), quote(term.num1, depth));\n      case \"Op2\": return Op2(term.func, quote(term.num0, depth), quote(term.num1, depth));\n      case \"Ite\": return Ite(quote(term.cond, depth), quote(term.pair, depth));\n      case \"Cpy\": return Cpy(term.name, quote(term.numb, depth), quote(term.body(Var(depth)), depth + 1));\n      case \"Sig\": return Sig(term.name, quote(term.typ0, depth), quote(term.typ1(Var(depth)), depth + 1), term.eras);\n      case \"Par\": return Par(quote(term.val0, depth), quote(term.val1, depth), term.eras);\n      case \"Fst\": return Fst(quote(term.pair, depth), term.eras);\n      case \"Snd\": return Snd(quote(term.pair, depth), term.eras);\n      case \"Prj\": return Prj(term.nam0, term.nam1, quote(term.pair, depth), quote(term.body(Var(depth), Var(depth + 1)), depth + 2), term.eras);\n      case \"Eql\": return Eql(quote(term.val0, depth), quote(term.val1, depth));\n      case \"Rfl\": return Rfl(quote(term.expr, depth));\n      case \"Sym\": return Sym(quote(term.prof, depth));\n      case \"Rwt\": return Rwt(quote(term.prof, depth), term.name, quote(term.type, depth + 1), quote(term.expr, depth));\n      case \"Cst\": return Cst(quote(term.prof, depth), quote(term.val0, depth), quote(term.val1, depth));\n      case \"Slf\": return Slf(term.name, quote(term.type(Var(depth)), depth + 1));\n      case \"New\": return New(quote(term.type, depth), quote(term.expr, depth));\n      case \"Use\": return Use(quote(term.expr, depth));\n      case \"Ann\": return Ann(quote(term.type, depth), quote(term.expr, depth), term.done);\n      case \"Ref\": return Ref(term.name, term.eras);\n    }\n  };\n  var unquoted = unquote(term, []);\n  var reduced = reduce(unquoted);\n  var quoted = quote(reduced, 0);\n  return quoted;\n}\n\nconst erase = (term) => {\n  var [ctor, term] = term;\n  switch (ctor) {\n    case \"Var\": return Var(term.index);\n    case \"Typ\": return Typ();\n    case \"All\": return All(term.name, erase(term.bind), erase(term.body), term.eras);\n    case \"Lam\": return term.eras ? erase(subst(term.body, Num(0), 0)) : Lam(term.name, null, erase(term.body), term.eras);\n    case \"App\": return term.eras ? erase(term.func) : App(erase(term.func), erase(term.argm), term.eras);\n    case \"Box\": return Box(erase(term.expr));\n    case \"Put\": return erase(term.expr);\n    case \"Dup\": return erase(subst(term.body, term.expr, 0));\n    case \"U32\": return U32();\n    case \"Num\": return Num(term.numb);\n    case \"Op1\": return Op1(term.func, erase(term.num0), erase(term.num1));\n    case \"Op2\": return Op2(term.func, erase(term.num0), erase(term.num1));\n    case \"Ite\": return Ite(erase(term.cond), erase(term.pair));\n    case \"Cpy\": return Cpy(term.name, erase(term.numb), erase(term.body));\n    case \"Sig\": return Sig(term.name, erase(term.typ0), erase(term.typ1), term.eras);\n    case \"Par\": return term.eras ? erase(term.val0) : Par(erase(term.val0), erase(term.val1), term.eras);\n    case \"Fst\": return term.eras ? erase(term.pair) : Fst(erase(term.pair), term.eras);\n    case \"Snd\": return term.eras ? erase(term.pair) : Snd(erase(term.pair), term.eras);\n    case \"Prj\": return term.eras ? subst(subst(term.body, Num(0), 0), erase(term.pair), 0) : Prj(term.nam0, term.nam1, erase(term.pair), erase(term.body), term.eras);\n    case \"Eql\": return Eql(erase(term.val0), erase(term.val1));\n    case \"Rfl\": return erase(term.expr);\n    case \"Sym\": return erase(term.prof);\n    case \"Rwt\": return erase(term.expr);\n    case \"Cst\": return erase(term.val1);\n    case \"Slf\": return Slf(term.name, erase(term.type));\n    case \"New\": return erase(term.expr);\n    case \"Use\": return erase(term.expr);\n    case \"Ann\": return erase(term.expr);\n    case \"Ref\": return Ref(term.name, true);\n  }\n}\n\n// ::::::::::::::\n// :: Equality ::\n// ::::::::::::::\n\nconst equal = (a, b, defs) => {\n  const Eqs = (a, b)    => [\"Eqs\", {a, b}];\n  const Bop = (v, x, y) => [\"Bop\", {v, x, y}];\n  const And = (x,y)     => Bop(false, x, y);\n  const Or  = (x,y)     => Bop(true, x, y);\n  const Val = (v)       => [\"Val\", {v}];\n\n  const step = (node) => {\n    switch (node[0]) {\n      // An equality test\n      case \"Eqs\":\n        var {a, b} = node[1];\n\n        // Gets whnfs with and without dereferencing\n        var ax = norm(a, {}, true);\n        var bx = norm(b, {}, true);\n        var ay = norm(a, defs, true);\n        var by = norm(b, defs, true);\n\n        // If non-deref whnfs are app and fields are equal, then a == b\n        var x = null;\n        if (ax[0] === \"Ref\" && bx[0] === \"Ref\" && ax[1].name === bx[1].name) {\n          x = Val(true);\n        } else if (ax[0] === \"App\" && bx[0] === \"App\") {\n          var func = Eqs(ax[1].func, bx[1].func);\n          var argm = Eqs(ax[1].argm, bx[1].argm);\n          x = Bop(false, func, argm);\n        }\n\n        // If whnfs are equal and fields are equal, then a == b\n        var y = null;\n        switch (ay[0] + \"-\" + by[0]) {\n          case \"Var-Var\": y = Val(ay[1].index === by[1].index); break;\n          case \"Typ-Typ\": y = Val(true); break;\n          case \"All-All\": y = And(And(Eqs(ay[1].bind, by[1].bind), Eqs(ay[1].body, by[1].body)), Val(ay[1].eras === by[1].eras)); break;\n          case \"Lam-Lam\": y = And(Eqs(ay[1].body, by[1].body), Val(ay[1].eras === by[1].eras)); break;\n          case \"App-App\": y = And(And(Eqs(ay[1].func, by[1].func), Eqs(ay[1].argm, by[1].argm)), Val(ay[1].eras === by[1].eras)); break;\n          case \"Box-Box\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Put-Put\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Dup-Dup\": y = And(Eqs(ay[1].expr, by[1].expr), Eqs(ay[1].body, by[1].body)); break;\n          case \"U32-U32\": y = Val(true); break;\n          case \"Num-Num\": y = Val(ay[1].numb === by[1].numb); break;\n          case \"Op1-Op1\": y = And(Val(ay[1].func === by[1].func), And(Eqs(ay[1].num0, by[1].num0), Val(ay[1].num1[1].numb === ay[1].num1[1].numb))); break;\n          case \"Op2-Op2\": y = And(Val(ay[1].func === by[1].func), And(Eqs(ay[1].num0, by[1].num0), Eqs(ay[1].num1, by[1].num1))); break;\n          case \"Ite-Ite\": y = And(Eqs(ay[1].cond, by[1].cond), Eqs(ay[1].pair, by[1].pair)); break;\n          case \"Cpy-Cpy\": y = And(Eqs(ay[1].numb, by[1].numb), Eqs(ay[1].body, by[1].body)); break;\n          case \"Sig-Sig\": y = And(Eqs(ay[1].typ0, by[1].typ0), Eqs(ay[1].typ1, by[1].typ1)); break;\n          case \"Par-Par\": y = And(Eqs(ay[1].val0, by[1].val0), Eqs(ay[1].val1, by[1].val1)); break;\n          case \"Fst-Fst\": y = And(Eqs(ay[1].pair, by[1].pair), Val(ay[1].eras === by[1].eras)); break;\n          case \"Snd-Snd\": y = And(Eqs(ay[1].pair, by[1].pair), ay[1].eras === by[1].eras); break;\n          case \"Prj-Prj\": y = And(Eqs(ay[1].pair, by[1].pair), Eqs(ay[1].body, by[1].body)); break;\n          case \"Eql-Eql\": y = And(Eqs(ay[1].val0, by[1].val0), Eqs(ay[1].val1, by[1].val1)); break;\n          case \"Rfl-Rfl\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Sym-Sym\": y = Eqs(ay[1].prof, by[1].prof); break;\n          case \"Rwt-Rwt\": y = And(And(Eqs(ay[1].prof, by[1].prof), Eqs(ay[1].type, by[1].type)), Eqs(ay[1].expr, by[1].expr)); break;\n          case \"Cst-Cst\": y = And(And(Eqs(ay[1].prof, by[1].prof), Eqs(ay[1].val0, by[1].val0)), Eqs(ay[1].val1, by[1].val1)); break;\n          case \"Slf-Slf\": y = Eqs(ay[1].type, by[1].type); break;\n          case \"New-New\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Use-Use\": y = Eqs(ay[1].expr, by[1].expr); break;\n          case \"Ann-Ann\": y = Eqs(ay[1].expr, by[1].expr); break;\n          default:        y = Val(false); break;\n        }\n\n        return x ? Bop(true, x, y) : y;\n\n      // A binary operation (or / and)\n      case \"Bop\":\n        var {v, x, y} = node[1];\n        if (x[0] === \"Val\") {\n          return x[1].v === v ? Val(v) : y;\n        } else if (y[0] === \"Val\") {\n          return y[1].v === v ? Val(v) : x;\n        } else {\n          var X = step(x);\n          var Y = step(y);\n          return Bop(v, X, Y);\n        }\n\n      // A result value (true / false)\n      case \"Val\":\n        return node;\n    }\n  }\n\n  // Expands the search tree until it finds an answer\n  var tree = Eqs(norm(erase(a, defs), defs), norm(erase(b, defs), defs));\n  while (tree[0] !== \"Val\") {\n    var tree = step(tree);\n  }\n  return tree[1].v;\n}\n\n\n// ::::::::::::::::::::\n// :: Stratification ::\n// ::::::::::::::::::::\n\n// How many times a variable was used in computational positions\nconst uses = ([ctor, term], depth = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index === depth ? 1 : 0;\n    case \"Typ\": return 0;\n    case \"All\": return 0;\n    case \"Lam\": return uses(term.body, depth + 1);\n    case \"App\": return uses(term.func, depth) + (term.eras ? 0 : uses(term.argm, depth));\n    case \"Box\": return 0;\n    case \"Put\": return uses(term.expr, depth);\n    case \"Dup\": return uses(term.expr, depth) + uses(term.body, depth + 1);\n    case \"U32\": return 0;\n    case \"Num\": return 0;\n    case \"Op1\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Op2\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Ite\": return uses(term.cond, depth) + uses(term.pair, depth);\n    case \"Cpy\": return uses(term.numb, depth) + uses(term.body, depth + 1);\n    case \"Sig\": return 0;\n    case \"Par\": return uses(term.val0, depth) + (term.eras ? 0 : uses(term.val1, depth));\n    case \"Fst\": return uses(term.pair, depth);\n    case \"Snd\": return uses(term.pair, depth);\n    case \"Prj\": return uses(term.pair, depth) + uses(term.body, depth + 2);\n    case \"Eql\": return 0;\n    case \"Rfl\": return uses(term.expr, depth);\n    case \"Sym\": return 0;\n    case \"Rwt\": return 0;\n    case \"Cst\": return 0;\n    case \"Slf\": return 0;\n    case \"New\": return uses(term.expr, depth);\n    case \"Use\": return uses(term.expr, depth);\n    case \"Ann\": return uses(term.expr, depth);\n    case \"Ref\": return 0;\n  }\n}\n\n// Checks if variable only occurs at a specific relative level\nconst is_at_level = ([ctor, term], at_level, depth = 0, level = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index !== depth || level === at_level;\n    case \"Typ\": return true;\n    case \"All\": return true;\n    case \"Lam\": return is_at_level(term.body, at_level, depth + 1, level);\n    case \"App\": return is_at_level(term.func, at_level, depth, level) && (term.eras ? true : is_at_level(term.argm, at_level, depth, level));\n    case \"Box\": return true;\n    case \"Put\": return is_at_level(term.expr, at_level, depth, level + 1);\n    case \"Dup\": return is_at_level(term.expr, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"U32\": return true;\n    case \"Num\": return true;\n    case \"Op1\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Op2\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Ite\": return is_at_level(term.cond, at_level, depth, level) && is_at_level(term.pair, at_level, depth, level);\n    case \"Cpy\": return is_at_level(term.numb, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Sig\": return true;\n    case \"Par\": return is_at_level(term.val0, at_level, depth, level) && is_at_level(term.val1, at_level, depth, level);\n    case \"Fst\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Snd\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Prj\": return is_at_level(term.pair, at_level, depth, level) && is_at_level(term.body, at_level, depth + 2, level);\n    case \"Ann\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Pri\": return is_at_level(term.argm, at_level, depth, level);\n    case \"Eql\": return true;\n    case \"Rfl\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Sym\": return true;\n    case \"Rwt\": return true;\n    case \"Cst\": return true;\n    case \"Slf\": return true;\n    case \"New\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Use\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Ref\": return true;\n  }\n}\n\n// Checks if a term is stratified\nconst boxcheck = show => ([ctor, term], defs = {}, ctx = []) => {\n  switch (ctor) {\n    case \"All\":\n      break;\n    case \"Lam\":\n      if (uses(term.body) > 1) {\n        throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used more than once in:\\n\" + show([ctor, term], ctx);\n      }\n      if (!is_at_level(term.body, 0)) {\n        throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used inside a box in:\\n\" + show([ctor, term], ctx);\n      }\n      boxcheck(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"App\":\n      boxcheck(term.func, defs, ctx);\n      if (!term.eras) {\n        boxcheck(term.argm, defs, ctx);\n      }\n      break;\n    case \"Box\":\n      break;\n    case \"Put\":\n      boxcheck(term.expr, defs, ctx);\n      break;\n    case \"Dup\":\n      if (!is_at_level(term.body, 1)) {\n        throw \"[ERROR]\\nDuplication variable `\" + term.name + \"` must always have exactly 1 enclosing box on the body of:\\n\" + show([ctor, term], ctx);\n      }\n      boxcheck(term.expr, defs, ctx);\n      boxcheck(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"Op1\":\n    case \"Op2\":\n      boxcheck(term.num0, defs, ctx);\n      boxcheck(term.num1, defs, ctx);\n      break;\n    case \"Ite\":\n      boxcheck(term.cond, defs, ctx);\n      boxcheck(term.pair, defs, ctx);\n      break;\n    case \"Cpy\":\n      boxcheck(term.numb, defs, ctx);\n      boxcheck(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"Sig\":\n      break;\n    case \"Par\":\n      boxcheck(term.val0, defs, ctx);\n      if (!term.eras) {\n        boxcheck(term.val1, defs, ctx);\n      }\n      break;\n    case \"Fst\":\n      boxcheck(term.pair, defs, ctx);\n      break;\n    case \"Snd\":\n      boxcheck(term.pair, defs, ctx);\n      break;\n    case \"Prj\":\n      var uses0 = uses(term.body, 1);\n      var uses1 = uses(term.body, 0);\n      var isat0 = is_at_level(term.body, 0, 1);\n      var isat1 = is_at_level(term.body, 0, 0);\n      if (uses0 > 1 || uses1 > 1) {\n        throw \"[ERROR]\\nProjection variable `\" + (uses0 > 1 ? term.nam0 : term.nam1) + \"` used more than once in:\\n\" + show([ctor, term], ctx);\n      }\n      if (!isat0 || !isat1) {\n        throw \"[ERROR]\\nProjection variable `\" + (!isat0 ? term.nam0 : term.nam1) + \"` used inside a box in:\\n\" + show([ctor, term], ctx);\n      }\n      boxcheck(term.pair, defs, ctx);\n      boxcheck(term.body, defs, ctx.concat([term.nam0, term.nam1]));\n      break;\n    case \"Eql\":\n      break;\n    case \"Rfl\":\n      boxcheck(term.expr, defs, ctx);\n      break;\n    case \"Sym\":\n      break;\n    case \"Rwt\":\n      break;\n    case \"Cst\":\n      break;\n    case \"Ann\":\n      boxcheck(term.expr, defs, ctx);\n      break;\n    case \"Slf\":\n      break;\n    case \"New\":\n      boxcheck(term.expr, defs, ctx);\n      break;\n    case \"Use\":\n      boxcheck(term.expr, defs, ctx);\n      break;\n    case \"Ref\":\n      if (!defs[term.name]) {\n        throw \"[ERROR]\\nUndefined reference: \" + term.name;\n      } else {\n        boxcheck(defs[term.name], defs, ctx);\n        break;\n      }\n  }\n}\n\n// :::::::::::::::::::\n// :: Type Checking ::\n// :::::::::::::::::::\n\nconst typecheck = (show) => {\n\n  const PADR = (len, chr, str) => {\n    while (str.length < len) {\n      str += chr;\n    }\n    return str;\n  };\n\n  const CODE = (str)  => {\n    return \"\\x1b[2m\" + str + \"\\x1b[0m\";\n  };\n\n  const DENON = (a, defs) => {\n    return norm(erase(a), defs, false);\n  };\n\n  const ctx_new = null;\n\n  const ctx_ext = (name, type, ctx) => {\n    return {name, type, rest: ctx};\n  };\n\n  const ctx_get = (i, ctx) => {\n    for (var k = 0; k < i; ++k) {\n      ctx = ctx.rest;\n    }\n    return [ctx.name, shift(ctx.type, i + 1, 0)];\n  };\n\n  const ctx_str = (ctx, defs) => {\n    var txt = [];\n    var idx = 0;\n    var max_len = 0;\n    for (var c = ctx; c !== null; c = c.rest) {\n      max_len = Math.max(c.name.length, max_len);\n    }\n    for (var c = ctx; c !== null; c = c.rest) {\n      var name = c.name;\n      var type = c.type;\n      txt.push(\"- \" + PADR(max_len, \" \", c.name) + \" : \" + show(norm(type, {}, true), ctx_names(c.rest)));\n    }\n    return txt.reverse().join(\"\\n\");\n  };\n\n  const ctx_names = (ctx) => {\n    var names = [];\n    while (ctx !== null) {\n      names.push(ctx.name);\n      ctx = ctx.rest;\n    }\n    return names.reverse();\n  };\n\n  const typecheck = (term, expect, defs, ctx = ctx_new, inside = null) => {\n    const TERM = (term) => {\n      return CODE(show(term, ctx_names(ctx)));\n    };\n\n    const ERROR = (str)  => {\n      throw \"[ERROR]\\n\" + str\n        + \"\\n- When checking \" + TERM(term)\n        + (inside ? \"\\n- On expression \" + CODE(show(inside[0], ctx_names(inside[1]))) : \"\")\n        //+ (inside ? \"\\n- On expression \" + JSON.stringify(inside[0]) + \" | \" + JSON.stringify(ctx_names(inside[1])) : \"\")\n        + (ctx !== null ? \"\\n- With the following context:\\n\" + ctx_str(ctx, defs) : \"\");\n    };\n\n    const MATCH = (a, b) => {\n      if (!equal(a, b, defs)) {\n        throw ERROR(\"Type mismatch.\"\n          + \"\\n- Found type... \" + TERM(norm(a, {}, false))\n          + \"\\n- Instead of... \" + TERM(norm(b, {}, false)));\n      }\n    };\n\n    var expect_nf = expect ? norm(expect, defs, true) : null;\n    var type;\n    switch (term[0]) {\n      case \"Var\":\n        type = ctx_get(term[1].index, ctx)[1];\n        break;\n      case \"All\":\n        if (expect_nf && expect_nf[0] !== \"Typ\") {\n          ERROR(\"The annotated type of a forall (\" + TERM(All(\"x\", Ref(\"A\"), Ref(\"B\"), false)) +\") isn't \" + TERM(Typ()) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var bind_t = typecheck(term[1].bind, null, defs, ctx, [term, ctx]);\n        var ex_ctx = ctx_ext(term[1].name, term[1].bind, ctx);\n        var body_t = typecheck(term[1].body, null, defs, ex_ctx, [term, ctx]);\n        MATCH(bind_t, Typ());\n        MATCH(body_t, Typ());\n        type = Typ();\n        break;\n      case \"Typ\":\n        type = Typ();\n        break;\n      case \"Lam\":\n        var bind_v = expect_nf && expect_nf[0] === \"All\" ? expect_nf[1].bind : term[1].bind;\n        if (bind_v === null && expect_nf === null) {\n          ERROR(\"Can't infer non-annotated lambda.\");\n        }\n        if (bind_v === null && expect_nf !== null) {\n          ERROR(\"The annotated type of a lambda (\" + TERM(Lam(\"x\",null,Ref(\"f\"),false)) + \") isn't forall (\" + TERM(All(\"x\", Ref(\"A\"), Ref(\"B\"), false)) + \").\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var ex_ctx = ctx_ext(term[1].name, bind_v, ctx);\n        var body_t = typecheck(term[1].body, expect_nf && expect_nf[0] === \"All\" ? expect_nf[1].body : null, defs, ex_ctx, [term, ctx]);\n        var term_t = All(term[1].name, bind_v, body_t, term[1].eras);\n        if (term_t[1].eras !== term[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        typecheck(term_t, Typ(), defs, ctx, [term, ctx]);\n        type = term_t;\n        break;\n      case \"App\":\n        var func_t = norm(typecheck(term[1].func, null, defs, ctx, [term, ctx]), defs, true);\n        if (func_t[0] !== \"All\") {\n          ERROR(\"Attempted to apply a value that isn't a function.\");\n        }\n        typecheck(term[1].argm, func_t[1].bind, defs, ctx, [term, ctx]);\n        if (func_t[1].eras !== term[1].eras) {\n          ERROR(\"Erasure doesn't match.\");\n        }\n        type = subst(func_t[1].body, Ann(func_t[1].bind, term[1].argm, false), 0);\n        break;\n      case \"Box\":\n        if (expect_nf !== null && expect_nf[0] !== \"Typ\") {\n          ERROR(\"The annotated type of a box (\" + TERM(Box(Ref(\"A\"))) + \") isn't \" + TERM(Typ()) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var expr_t = norm(typecheck(term[1].expr, null, defs, ctx, [term, ctx]), defs, true);\n        MATCH(expr_t, Typ());\n        type = Typ();\n        break;\n      case \"Put\":\n        if (expect_nf !== null && expect_nf[0] !== \"Box\") {\n          ERROR(\"The annotated type of a put (\" + TERM(Put(Ref(\"x\"))) + \") isn't a box (\" + TERM(Box(Ref(\"A\"))) + \").\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var expr_t = expect_nf && expect_nf[0] === \"Box\" ? expect_nf[1].expr : null;\n        var term_t = typecheck(term[1].expr, expr_t, defs, ctx, [term, ctx]);\n        type = Box(term_t);\n        break;\n      case \"Dup\":\n        var expr_t = norm(typecheck(term[1].expr, null, defs, ctx, [term, ctx]), defs, true);\n        if (expr_t[0] !== \"Box\") {\n          ERROR(\"Unboxed duplication.\");\n        }\n        var ex_ctx = ctx_ext(term[1].name, expr_t[1].expr, ctx);\n        var body_t = typecheck(term[1].body, expect_nf && shift(expect_nf, 1, 0), defs, ex_ctx, [term, ctx]);\n        type = subst(body_t, Dup(term[1].name, term[1].expr, Var(0)), 0);\n        break;\n      case \"U32\":\n        type = Typ();\n        break;\n      case \"Num\":\n        type = U32();\n        break;\n      case \"Op1\":\n      case \"Op2\":\n        if (expect_nf !== null && expect_nf[0] !== \"U32\") {\n          ERROR(\"The annotated type of a numeric operation (\" + TERM(Op2(term[1].func, Ref(\"x\"), Ref(\"y\"))) + \") isn't \" + TERM(U32()) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        typecheck(term[1].num0, U32(), defs, ctx, [term, ctx]);\n        typecheck(term[1].num1, U32(), defs, ctx, [term, ctx]);\n        type = U32();\n        break;\n      case \"Ite\":\n        var cond_t = norm(typecheck(term[1].cond, null, defs, ctx, [term, ctx]), defs, true);\n        if (cond_t[0] !== \"U32\") {\n          ERROR(\"Attempted to use if on a non-numeric value.\");\n        }\n        var pair_t = expect_nf ? Sig(\"x\", expect_nf, shift(expect_nf, 1, 0), false) : null;\n        var pair_t = norm(typecheck(term[1].pair, pair_t, defs, ctx, [term, ctx]), defs, true);\n        if (pair_t[0] !== \"Sig\") {\n          ERROR(\"The body of an if must be a pair.\");\n        }\n        var typ0_v = pair_t[1].typ0;\n        var typ1_v = subst(pair_t[1].typ1, Typ(), 0);\n        if (!equal(typ0_v, typ1_v, defs)) {\n          ERROR(\"Both branches of if must have the same type.\");\n        }\n        type = expect_nf || typ0_v;\n        break;\n      case \"Cpy\":\n        var numb_t = norm(typecheck(term[1].numb, null, defs, ctx, [term, ctx]), defs, true);\n        if (numb_t[0] !== \"U32\") {\n          ERROR(\"Attempted to use cpy on a non-numeric value.\");\n        }\n        var ex_ctx = ctx_ext(term[1].name, U32(), ctx);\n        type = typecheck(term[1].body, null, defs, ex_ctx, [term, ctx]);\n        break;\n      case \"Sig\":\n        if (expect_nf && expect_nf[0] !== \"Typ\") {\n          ERROR(\"The annotated type of a sigma (\" + TERM(Sig(\"x\", Ref(\"A\"), Ref(\"B\"))) + \") isn't \" + TERM(Typ()) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        var typ0_t = typecheck(term[1].typ0, null, defs, ctx, [term, ctx]);\n        var ex_ctx = ctx_ext(term[1].name, term[1].typ0, ctx);\n        var typ1_t = typecheck(term[1].typ1, null, defs, ex_ctx, [term, ctx]);\n        MATCH(typ0_t, Typ());\n        MATCH(typ1_t, Typ());\n        type = Typ();\n        break;\n      case \"Par\":\n        if (expect_nf && expect_nf[0] !== \"Sig\") {\n          ERROR(\"Annotated type of a pair (\" + TERM(Pair(Ref(\"a\"),Ref(\"b\"))) + \") isn't \" + TERM(Sig(\"x\", Ref(\"A\"), Ref(\"B\"))) + \".\\n- Annotated type is \" + TERM(expect_nf));\n        }\n        if (expect_nf && expect_nf[1].eras !== term[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        var val0_t = typecheck(term[1].val0, expect_nf && expect_nf[1].typ0, defs, ctx, [term, ctx]);\n        var val1_t = typecheck(term[1].val1, expect_nf && subst(expect_nf[1].typ1, term[1].val0, 0), defs, ctx, [term, ctx]);\n        if (term[1].eras && !equal(term[1].val0, term[1].val1, defs)) {\n          ERROR(\"Dependent interesction values must have same erasure.\"\n            + \"\\n- Erasure 0 is \" + TERM(DENON(term[1].val0, defs))\n            + \"\\n- Erasure 1 is \" + TERM(DENON(term[1].val1, defs)));\n        }\n        type = expect_nf || Sig(\"x\", val0_t, val1_t, term[1].eras);\n        break;\n      case \"Fst\":\n        var pair_t = norm(typecheck(term[1].pair, null, defs, ctx, [term, ctx]), defs, true);\n        if (pair_t[0] !== \"Sig\") {\n          ERROR(\"Attempted to extract the first element of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        type = pair_t[1].typ0;\n        break;\n      case \"Snd\":\n        var pair_t = norm(typecheck(term[1].pair, null, defs, ctx, [term, ctx]), defs, true);\n        if (pair_t[0] !== \"Sig\") {\n          ERROR(\"Attempted to extract the second element of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        type = subst(pair_t[1].typ1, Fst(term[1].pair, term[1].eras), 0);\n        break;\n      case \"Prj\":\n        var pair_t = norm(typecheck(term[1].pair, null, defs, ctx, [term, ctx]), defs, true);\n        if (pair_t[0] !== \"Sig\") {\n          ERROR(\"Attempted to project the elements of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          ERROR(\"Mismatched erasure.\");\n        }\n        var ex_ctx = ctx_ext(term[1].nam0, pair_t[1].typ0, ctx);\n        var ex_ctx = ctx_ext(term[1].nam1, pair_t[1].typ1, ex_ctx);\n        type = typecheck(term[1].body, null, defs, ex_ctx, [term, ctx]);\n        type = subst(type, Snd(shift(term[1].pair, 1, 0), term[1].eras), 0);\n        type = subst(type, Fst(term[1].pair, term[1].eras), 0);\n        break;\n      case \"Eql\":\n        type = Typ();\n        break;\n      case \"Rfl\":\n        type = Eql(term[1].expr, term[1].expr);\n        break;\n      case \"Sym\":\n        var prof_t = norm(typecheck(term[1].prof, null, defs, ctx, [term, ctx]), defs, true);\n        if (prof_t[0] !== \"Eql\") {\n          ERROR(\"Attempted to use sym with an invalid equality proof.\");\n        }\n        type = Eql(prof_t[1].val1, prof_t[1].val0);\n        break;\n      case \"Rwt\":\n        var prof_t = norm(typecheck(term[1].prof, null, defs, ctx, [term, ctx]), defs, true);\n        if (prof_t[0] !== \"Eql\") {\n          ERROR(\"Attempted to use rwt with an invalid equality proof.\");\n        }\n        var expr_t0 = subst(term[1].type, prof_t[1].val0, 0);\n        var expr_t1 = typecheck(term[1].expr, null, defs, ctx, [term, ctx]);\n        MATCH(expr_t1, expr_t0);\n        type = subst(term[1].type, prof_t[1].val1, 0);\n        break;\n      case \"Cst\":\n        var prof_t = norm(typecheck(term[1].prof, null, defs, ctx, [term, ctx]), defs, true);\n        if (prof_t[0] !== \"Eql\") {\n          ERROR(\"Attempted to use rwt with an invalid equality proof.\");\n        }\n        if (!equal(term[1].val0, prof_t[1].val0, defs)) {\n          ERROR(\"Cast failed because \" + TERM(term[1].val0) + \" != \" + TERM(prof_t[1].val0));\n        }\n        if (!equal(term[1].val0, prof_t[1].val0, defs)) {\n          ERROR(\"Cast failed because \" + TERM(term[1].val1) + \" != \" + TERM(prof_t[1].val1));\n        }\n        type = typecheck(term[1].val0, expect_nf, defs, ctx, [term, ctx]);\n        break;\n      case \"Slf\":\n        var ex_ctx = ctx_ext(term[1].name, term, ctx);\n        var type_t = typecheck(term[1].type, null, defs, ex_ctx, [term, ctx]);\n        MATCH(type_t, Typ());\n        return Typ();\n      case \"New\":\n        var type = norm(term[1].type, defs, true);\n        if (type[0] !== \"Slf\") {\n          ERROR(\"Attempted to make an instance of a type that isn't self.\");\n        }\n        typecheck(type, null, defs, ctx, [term, ctx]);\n        typecheck(term[1].expr, subst(type[1].type, Ann(type, term, true), 0), defs, ctx, [term, ctx]);\n        type = term[1].type;\n        break;\n      case \"Use\":\n        var expr_t = norm(typecheck(term[1].expr, null, defs, ctx, [term, ctx]), defs, true);\n        if (expr_t[0] !== \"Slf\") {\n          ERROR(\"Attempted to use a value that isn't a self type.\");\n        }\n        type = subst(expr_t[1].type, term[1].expr, 0);\n        break;\n      case \"Ann\":\n        if (!term[1].done) {\n          term[1].done = true;\n          typecheck(term[1].expr, term[1].type, defs, ctx, [term, ctx]);\n        }\n        type = term[1].type;\n        break;\n      case \"Ref\":\n        if (!defs[term[1].name]) {\n          ERROR(\"Undefined reference.\");\n        } else {\n          type = typecheck(defs[term[1].name], null, defs, ctx, [term, ctx]);\n        }\n        break;\n      default:\n        throw \"TODO: type checker for \" + term[0] + \".\";\n    }\n    if (expect) {\n      MATCH(type, expect);\n    }\n    return type;\n  };\n\n  return typecheck;\n};\n\nmodule.exports = {\n  Var,\n  Typ,\n  All,\n  Lam,\n  App,\n  Box,\n  Put,\n  Dup,\n  U32,\n  Num,\n  Op1,\n  Op2,\n  Ite,\n  Cpy,\n  Sig,\n  Par,\n  Fst,\n  Snd,\n  Prj,\n  Eql,\n  Rfl,\n  Sym,\n  Rwt,\n  Cst,\n  Slf,\n  New,\n  Use,\n  Ann,\n  Ref,\n  shift,\n  subst,\n  subst_many,\n  norm,\n  erase,\n  equal,\n  boxcheck,\n  typecheck,\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/FM-Core/fm-core.js?");

/***/ }),

/***/ "../Formality-JavaScript/FM-Core/fm-lang.js":
/*!**************************************************!*\
  !*** ../Formality-JavaScript/FM-Core/fm-lang.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  Var,\n  Typ,\n  All,\n  Lam,\n  App,\n  Box,\n  Put,\n  Dup,\n  U32,\n  Num,\n  Op1,\n  Op2,\n  Ite,\n  Cpy,\n  Sig,\n  Par,\n  Fst,\n  Snd,\n  Prj,\n  Eql,\n  Rfl,\n  Sym,\n  Rwt,\n  Cst,\n  Slf,\n  New,\n  Use,\n  Ann,\n  Ref,\n  shift,\n  subst,\n  subst_many,\n  norm,\n  erase,\n  equal,\n  boxcheck,\n  typecheck,\n} = __webpack_require__(/*! ./fm-core.js */ \"../Formality-JavaScript/FM-Core/fm-core.js\");\n\n// :::::::::::::\n// :: Parsing ::\n// :::::::::::::\n\n// Converts a string to a term\nconst parse = (code, tokenify) => {\n  function is_space(char) {\n    return char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\" || char === \";\";\n  }\n\n  function is_newline(char) {\n    return char === \"\\n\";\n  }\n\n  function is_name_char(char) {\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-\".indexOf(char) !== -1;\n  }\n\n  function next() {\n    if (tokens) tokens[tokens.length - 1][1] += code[idx];\n    if (is_newline(code[idx])) {\n      row += 1;\n      col = 0;\n    } else {\n      col += 1;\n    }\n    idx += 1;\n  }\n\n  function skip_spaces() {\n    while (idx < code.length && is_space(code[idx])) {\n      next();\n    }\n  }\n\n  function next_char() {\n    skip_spaces();\n    while (code.slice(idx, idx + 2) === \"//\") {\n      if (tokens) tokens.push([\"cmm\", \"\"]);\n      while (code[idx] !== \"\\n\" && idx < code.length) {\n        next();\n      }\n      if (tokens) tokens.push([\"txt\", \"\"]);\n      skip_spaces();\n    }\n  }\n\n  function match_here(string) {\n    var sliced = code.slice(idx, idx + string.length);\n    if (sliced === string) {\n      if (tokens) tokens.push([\"sym\", \"\"]);\n      for (var i = 0; i < string.length; ++i) {\n        next();\n      }\n      if (tokens) tokens.push([\"txt\", \"\"]);\n      return true;\n    }\n    return false;\n  }\n\n  function match(string) {\n    next_char();\n    return match_here(string);\n  }\n\n  function is_sigma(string) {\n    var i = idx;\n    while (i < code.length && is_name_char(code[i])) { ++i; }\n    while (i < code.length && is_space(code[i])) { ++i; }\n    return code[i] === \":\";\n  }\n\n  function parse_exact(string) {\n    if (!match(string)) {\n      var text = \"\";\n      var part = \"\";\n      text += \"Parse error: expected '\" + string + \"' \";\n      text += \"on line \" + (row+1) + \", col \" + col + \", but found '\" + (code[idx] || \"(end of file)\") + \"' instead. Relevant code:\\n\";\n      for (var ini = idx, il = 0; il < 2 && ini >=          0; --ini) if (code[ini] === \"\\n\") ++il;\n      for (var end = idx, el = 0; el < 6 && end < code.length; ++end) if (code[end] === \"\\n\") ++el;\n      part += code.slice(ini+1, idx) + \"<HERE>\" + code.slice(idx, end);\n      text += part.split(\"\\n\").map((line,i) => (\"    \" + (row-il+i+1)).slice(-4) + \"| \" + line).join(\"\\n\");\n      throw text;\n    }\n  }\n\n  function parse_string(fn = is_name_char) {\n    next_char();\n    var name = \"\";\n    while (idx < code.length && fn(code[idx])) {\n      name = name + code[idx];\n      next();\n    }\n    return name;\n  }\n\n  function parse_term(ctx) {\n    var parsed;\n\n    // Parenthesis\n    if (match(\"(\")) {\n      var term = parse_term(ctx);\n      var skip = parse_exact(\")\");\n      parsed = term;\n    }\n\n    // Type\n    else if (match(\"Type\")) {\n      parsed = Typ();\n    }\n\n    // Lambdas and Forall\n    else if (match(\"{\")) {\n      var erase = [];\n      var names = [];\n      var types = [];\n      while (idx < code.length) {\n        erase.push(match(\"~\"));\n        names.push(parse_string());\n        types.push(match(\":\") ? parse_term(ctx.concat(names.slice(0,-1))) : null);\n        if (match(\"}\")) break; else parse_exact(\",\");\n      }\n      var isall = match(\"->\");\n      var islam = match(\"=>\");\n      if (!isall && !islam) {\n        // TODO: error\n      }\n      var term = parse_term(ctx.concat(names));\n      for (var i = names.length - 1; i >= 0; --i) {\n        var ctr = isall ? All : Lam;\n        term = ctr(names[i], types[i], term, erase[i]);\n        if (isall && !types[i]) {\n          throw \"Parse error: invalid forall on line \" + (row+1) + \", col \" + col + \".\";\n        }\n      }\n      parsed = term;\n    }\n\n    // Duplication\n    else if (match(\"dup \")) {\n      var name = parse_string();\n      var expr = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      parsed = Dup(name, expr, body);\n    }\n\n    // Box\n    else if (match(\"!\")) {\n      var expr = parse_term(ctx);\n      parsed = Box(expr);\n    }\n\n    // Put\n    else if (match(\"#\")) {\n      var expr = parse_term(ctx);\n      parsed = Put(expr);\n    }\n\n    // Let\n    else if (match(\"let \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var copy = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      parsed = subst(body, copy, 0);\n    }\n\n    // U32\n    else if (match(\"U32\")) {\n      parsed = U32();\n    }\n\n    // Operation\n    else if (match(\"|\")) {\n      var num0 = parse_term(ctx);\n      var func = parse_string(c => !is_space(c));\n      var num1 = parse_term(ctx);\n      var skip = parse_exact(\"|\");\n      parsed = Op2(func, num0, num1);\n    }\n\n    // String\n    else if (match(\"\\\"\")) {\n      // Parses text\n      var text = \"\";\n      while (code[idx] !== \"\\\"\") {\n        text += code[idx];\n        next();\n      }\n      next();\n      parsed = text_to_term(text);\n    }\n\n    // Nat\n    //else if (match(\"^\")) {\n      //var name = parse_string();\n      //var numb = Number(name);\n      //parsed = numb_to_term(numb);\n    //}\n\n    // PBT\n    //else if (match(\"&\")) {\n      //var name = parse_string();\n      //var numb = Number(name);\n      //parsed = numb_to_tree_term(numb);\n    //}\n\n    // If-Then-Else\n    else if (match(\"if \")) {\n      var cond = parse_term(ctx);\n      var pair = parse_term(ctx);\n      parsed = Ite(cond, pair);\n    }\n\n    // Copy\n    else if (match(\"cpy \")) {\n      var name = parse_string();\n      let skip = parse_exact(\"=\");\n      var numb = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      parsed = Cpy(name, numb, body);\n    }\n\n    // Sigma / Pair\n    else if (match(\"[\")) {\n      // Sigma\n      if (is_sigma()) {\n        var name = parse_string();\n        var skip = parse_exact(\":\");\n        var typ0 = parse_term(ctx);\n        var eras = match(\"~\");\n        var skip = eras ? null : parse_exact(\",\");\n        var typ1 = parse_term(ctx.concat([name]));\n        var skip = parse_exact(\"]\");\n        parsed = Sig(name, typ0, typ1, eras);\n      // Pair\n      } else {\n        var val0 = parse_term(ctx);\n        var eras = match(\"~\");\n        var skip = eras ? null : parse_exact(\",\");\n        var val1 = parse_term(ctx);\n        var skip = parse_exact(\"]\");\n        parsed = Par(val0, val1, eras);\n      }\n    }\n\n    // Pair (If-Then-Else sugar)\n    else if (match(\"then:\")) {\n      var val0 = parse_term(ctx);\n      var skip = parse_exact(\"else:\");\n      var val1 = parse_term(ctx);\n      parsed = Par(val0, val1, false);\n    }\n\n    // First\n    else if (match(\"fst \")) {\n      var pair = parse_term(ctx);\n      parsed = Fst(pair, false);\n    }\n\n    // First (erased)\n    else if (match(\"~fst \")) {\n      var pair = parse_term(ctx);\n      parsed = Fst(pair, true);\n    }\n\n    // Second\n    else if (match(\"snd \")) {\n      var pair = parse_term(ctx);\n      parsed = Snd(pair, false);\n    }\n\n    // Second (erased)\n    else if (match(\"~snd \")) {\n      var pair = parse_term(ctx);\n      parsed = Snd(pair, true);\n    }\n\n    // Projection\n    else if (match(\"get \")) {\n      var skip = parse_exact(\"[\");\n      var nam0 = parse_string();\n      var skip = parse_exact(\",\");\n      var eras = match(\"~\");\n      var nam1 = parse_string();\n      var skip = parse_exact(\"]\");\n      var pair = parse_term(ctx);\n      var body = parse_term(ctx.concat([nam0, nam1]));\n      parsed = Prj(nam0, nam1, pair, body, eras);\n    }\n\n    // Equality\n    else if (match(\"<\")) {\n      var val0 = parse_term(ctx);\n      var skip = parse_exact(\"==\");\n      var val1 = parse_term(ctx);\n      var skip = parse_exact(\">\");\n      parsed = Eql(val0, val1);\n    }\n\n    // Reflexivity\n    else if (match(\"rfl \")) {\n      var expr = parse_term(ctx);\n      parsed = Rfl(expr);\n    }\n\n    // Symmetry\n    else if (match(\"sym \")) {\n      var prof = parse_term(ctx);\n      parsed = Sym(prof);\n    }\n\n    // Rewrite\n    else if (match(\"rwt \")) {\n      var prof = parse_term(ctx);\n      var skip = parse_exact(\"<\");\n      var name = parse_string();\n      var skip = parse_exact(\"@\");\n      var type = parse_term(ctx.concat([name]));\n      var skip = parse_exact(\">\");\n      var expr = parse_term(ctx);\n      parsed = Rwt(prof, name, type, expr);\n    }\n\n    // Cast\n    else if (match(\"cst \")) {\n      var prof = parse_term(ctx);\n      var val0 = parse_term(ctx);\n      var val1 = parse_term(ctx);\n      parsed = Cst(prof, val0, val1);\n    }\n\n    // Annotation\n    else if (match(\":\")) {\n      var type = parse_term(ctx);\n      var expr = parse_term(ctx);\n      parsed = Ann(type, expr, false);\n    }\n\n    // Identiy\n    else if (match(\"=\")) {\n      var expr = parse_term(ctx);\n      parsed = expr;\n    }\n\n    // Slf\n    else if (match(\"$\")) {\n      var name = parse_string();\n      var type = parse_term(ctx.concat([name]));\n      parsed = Slf(name, type);\n    }\n\n    // New\n    else if (match(\"&\")) {\n      var type = parse_term(ctx);\n      var expr = parse_term(ctx);\n      parsed = New(type, expr);\n    }\n\n    // Use\n    else if (match(\"%\")) {\n      var expr = parse_term(ctx);\n      parsed = Use(expr);\n    }\n\n    // Case syntax sugar\n    else if (match(\"case<\")) {\n      // ? ADT val -> motive\n      // | \n      var adt_name = parse_string();\n      var skip = parse_exact(\">\");\n      if (!adts[adt_name]) {\n        throw \"Parse error: used case-syntax on undefined type `\" + adt_name + \"`.\";\n      }\n      var {adt_name, adt_pram, adt_indx, adt_ctor} = adts[adt_name];\n      var term = parse_term(ctx);\n      var cses = [];\n      for (var c = 0; c < adt_ctor.length; ++c) {\n        var skip = parse_exact(\"|\");\n        var skip = parse_exact(adt_ctor[c][0]);\n        var skip = parse_exact(\"=>\");\n        var ctors = adt_ctor[c][1];\n        cses[c] = parse_term(ctx.concat(adt_ctor[c][1].map(([name,type]) => name)));\n        for (var i = 0; i < ctors.length; ++i) {\n          cses[c] = Lam(ctors[ctors.length - i - 1][0], null, cses[c], ctors[ctors.length - i - 1][2]);\n        }\n      }\n      var skip = parse_exact(\":\");\n      var moti = parse_term(ctx.concat(adt_indx.map(([name,type]) => name)).concat([\"self\"]));\n      for (var i = 0; i < adt_indx.length; ++i) {\n        var moti = Lam(adt_indx[i][adt_indx.length - i - 1], null, moti, false);\n      }\n      var moti = Lam(\"self\", null, moti, false);\n      var term = Use(term);\n      var term = App(term, moti, true);\n      for (var i = 0; i < cses.length; ++i) {\n        var term = App(term, cses[i], false);\n      }\n      return term;\n    }\n\n    // Variable / Reference\n    else {\n      if (tokens) tokens.push([\"???\", \"\"]);\n      var name = parse_string();\n      var numb = Number(name);\n      if (!isNaN(numb)) {\n        parsed = Num(numb >>> 0);\n        if (tokens) tokens[tokens.length - 1][0] = \"num\";\n      } else {\n        var skip = 0;\n        while (match_here(\"'\")) {\n          skip += 1;\n        }\n        for (var i = ctx.length - 1; i >= 0; --i) {\n          if (ctx[i] === name) {\n            if (skip === 0) break;\n            else skip -= 1;\n          }\n        }\n        if (i === -1) {\n          for (var mini in enlarge) {\n            if (name.slice(0, mini.length) === mini) {\n              var name = enlarge[mini] + name.slice(mini.length);\n              break;\n            }\n          }\n          parsed = Ref(name, false);\n          if (tokens) tokens[tokens.length - 1][0] = \"ref\";\n        } else {\n          parsed = Var(ctx.length - i - 1);\n          if (tokens) tokens[tokens.length - 1][0] = \"var\";\n        }\n      }\n      if (tokens) tokens.push([\"txt\", \"\"]);\n    }\n\n    var erased = false;\n    while (match_here(\"(\") || (erased = match_here(\"<\"))) {\n      var term = parsed;\n      while (idx < code.length) {\n        var eras = erased || match(\"~\");\n        var argm = parse_term(ctx);\n        var term = App(term, argm, eras);\n        if (erased && match(\">\") || match(\")\")) break;\n        else parse_exact(\",\");\n      }\n      parsed = term;\n      erased = false;\n    }\n\n    return parsed;\n  }\n\n  var tokens = tokenify ? [[\"txt\",\"\"]] : null;\n  var idx = 0;\n  var row = 0;\n  var col = 0;\n  var defs = {};\n  var adts = {};\n  var enlarge = {};\n  while (idx < code.length) {\n    next_char();\n\n    // Shorten\n    if (match(\"shorten\")) {\n      var full = parse_string();\n      var skip = parse_exact(\"as\");\n      var mini = parse_string();\n      enlarge[mini] = full;\n\n    // Datatypes\n    } else if (match(\"T \")) {\n      var adt_pram = [];\n      var adt_indx = [];\n      var adt_ctor = [];\n      var adt_name = parse_string();\n      var adt_ctx = [adt_name];\n\n      // Datatype parameters\n      if (match(\"<\")) {\n        while (idx < code.length) {\n          var eras = false;\n          var name = parse_string(); \n          var skip = parse_exact(\":\");\n          var type = parse_term(adt_pram.map((([name,type]) => name)));\n          adt_pram.push([name, type, eras]);\n          if (match(\">\")) break; else parse_exact(\",\");\n        }\n      }\n\n      // Datatype indices\n      var adt_ctx = adt_ctx.concat(adt_pram.map(([name,type]) => name));\n      if (match(\"{\")) {\n        while (idx < code.length) {\n          //var eras = match(\"~\");\n          var eras = false;\n          var name = parse_string(); \n          var skip = parse_exact(\":\");\n          var type = parse_term(adt_ctx.concat(adt_indx.map((([name,type]) => name))));\n          adt_indx.push([name, type, eras]);\n          if (match(\"}\")) break; else parse_exact(\",\");\n        }\n      }\n\n      // Datatype constructors\n      while (match(\"|\")) {\n        // Constructor name\n        var ctor_name = parse_string();\n        // Constructor fields\n        var ctor_flds = [];\n        if (match(\"{\")) {\n          while (idx < code.length) {\n            var eras = match(\"~\");\n            var name = parse_string();\n            var skip = parse_exact(\":\");\n            var type = parse_term(adt_ctx.concat(ctor_flds.map(([name,type]) => name)));\n            ctor_flds.push([name, type, eras]);\n            if (match(\"}\")) break; else parse_exact(\",\");\n          }\n        }\n        // Constructor type (written)\n        if (match(\":\")) {\n          var ctor_type = parse_term(adt_ctx.concat(ctor_flds.map(([name,type]) => name)));\n        // Constructor type (auto-filled)\n        } else {\n          var ctor_indx = [];\n          while (match(\"&\")) {\n            ctor_indx.push(parse_term(adt_ctx.concat(ctor_flds.map(([name,type]) => name))));\n          }\n          var ctor_type = Var(-1 + ctor_flds.length + adt_pram.length + 1);\n          for (var p = 0; p < adt_pram.length; ++p) {\n            ctor_type = App(ctor_type, Var(-1 + ctor_flds.length + adt_pram.length + p), false);\n          }\n          for (var i = 0; i < ctor_indx.length; ++i) {\n            ctor_type = App(ctor_type, ctor_indx[i], false);\n          }\n        }\n        adt_ctor.push([ctor_name, ctor_flds, ctor_type]);\n      }\n      var adt = {adt_pram, adt_indx, adt_ctor, adt_name};\n      defs[adt_name] = derive_adt_type(adt);\n      for (var c = 0; c < adt_ctor.length; ++c) {\n        defs[adt_name + \".\" + adt_ctor[c][0]] = derive_adt_ctor(adt, c);\n      }\n      adts[adt_name] = adt;\n\n    // Definitions or end-of-fiile\n    } else {\n      if (tokens) tokens.push([\"def\", \"\"]);\n      var name = parse_string();\n      if (tokens) tokens.push([\"txt\", \"\"]);\n\n      // Definition\n      if (name.length > 0) {\n\n        // Typed definition\n        if (match(\":\")) {\n          var cased = [];\n          var erase = [];\n          var names = [];\n          var types = [];\n          if (match(\"{\")) {\n            while (idx < code.length) {\n              cased.push(match(\"|\"));\n              erase.push(match(\"~\"));\n              names.push(parse_string());\n              parse_exact(\":\");\n              types.push(parse_term(names.slice(0,-1)));\n              if (match(\"}\")) break; else parse_exact(\",\");\n            }\n            var skip = parse_exact(\"->\");\n          }\n          var type = parse_term(names);\n\n          // Typed definition without patterns\n          if (cased.filter(x => x).length === 0) {\n            var term = parse_term(names);\n\n          // Typed definition with patterns\n          } else {\n\n            // Typed definition with patterns: finds matched datatypes\n            var cadts = [];\n            for (var i = 0; i < cased.length; ++i) {\n              if (cased[i]) {\n                // Right now, we can only build the compact case-analysis syntax\n                // if all the types on the annotation are refs to ADTs in scope.\n                // This could be improved if the parser kept track of ctx types.\n                var adt_ref = types.map(function go(x) { return x[0] === \"App\" ? go(x[1].func) : x; });\n                if (adt_ref[i][0] !== \"Ref\" || !adts[adt_ref[i][1].name]) {\n                  throw \"Couldn't find the ADT for the `\" + names[i] + \"` case of `\" + name + \"`.\";\n                }\n                cadts[i] = adts[adt_ref[i][1].name]; \n              } else {\n                cadts[i] = null;\n              }\n            }\n\n            // Typed definition with patterns: parses case-tree\n            var case_tree = {};\n            (function parse_case_tree(ctx, a, branch) {\n              if (a < cadts.length) {\n                if (cadts[a] === null) {\n                  return parse_case_tree(ctx, a + 1, branch);\n                } else {\n                  var {adt_name, adt_pram, adt_indx, adt_ctor} = cadts[a];\n                  for (var c = 0; c < adt_ctor.length; ++c) {\n                    var skip = parse_exact(\"|\");\n                    var skip = parse_exact(adt_ctor[c][0]);\n                    var vars = adt_ctor[c][1].map((([name,type,eras]) => names[a] + \".\" + name));\n                    parse_case_tree(ctx.concat(vars), a + 1, branch.concat([adt_ctor[c][0]]));\n                  }\n                }\n              } else {\n                //console.log(\"building branch: \", branch, \"with ctx: \", JSON.stringify(ctx));\n                var skip = parse_exact(\"=\");\n                var term = parse_term(ctx);\n                case_tree[branch.join(\"_\")] = term;\n              }\n            })(names, 0, []);\n\n            // Typed definition with patterns: derives matchinig term\n            var term = derive_dependent_match({names, types, cased, erase, cadts}, type, case_tree);\n          }\n\n          // Typed definition: auto-fills foralls and lambdas\n          for (var i = names.length - 1; i >= 0; --i) {\n            type = All(names[i], types[i], type, erase[i]);\n            term = Lam(names[i], types[i], term, erase[i]);\n          }\n\n          defs[name] = Ann(type, term);\n\n        // Untyped definition\n        } else {\n          var term = parse_term([]);\n          defs[name] = term;\n        }\n      }\n    }\n\n    next_char();\n  }\n\n  return tokenify ? {defs, tokens} : defs;\n}\n\n// :::::::::::::::::::::\n// :: Stringification ::\n// :::::::::::::::::::::\n\n// Generates a name\nconst gen_name = (n) => {\n  var str = \"\";\n  ++n;\n  while (n > 0) {\n    --n;\n    str += String.fromCharCode(97 + n % 26);\n    n = Math.floor(n / 26);\n  }\n  return str;\n};\n\n// Converts a term to a string\nconst show = ([ctor, args], nams = []) => {\n  switch (ctor) {\n    case \"Var\":\n      var name = nams[nams.length - args.index - 1];\n      if (!name) {\n        return \"^\" + args.index;\n      } else {\n        var suff = \"\";\n        for (var i = 0; i < args.index - 1; ++i) {\n          if (nams[nams.length - i - 1] === name) {\n            var suff = suff + \"'\";\n          }\n        }\n        return name + suff;\n      }\n    case \"Typ\":\n      return \"Type\";\n    case \"All\":\n      var term = [ctor, args];\n      var erase = [];\n      var names = [];\n      var types = [];\n      while (term[0] === \"All\") {\n        erase.push(term[1].eras);\n        names.push(term[1].name);\n        types.push(show(term[1].bind, nams.concat(names.slice(0,-1))));\n        term = term[1].body;\n      }\n      var text = \"{\";\n      for (var i = 0; i < names.length; ++i) {\n        text += erase[i] ? \"~\" : \"\";\n        text += names[i] + \" : \" + types[i];\n        text += i < names.length - 1 ? \", \" : \"\";\n      }\n      text += \"} -> \";\n      text += show(term, nams.concat(names));\n      return text;\n    case \"Lam\":\n      var term = [ctor, args];\n      var numb = null;\n      var erase = [];\n      var names = [];\n      var types = [];\n      while (term[0] === \"Lam\") {\n        numb = term_to_numb(term);\n        if (numb !== null) {\n          break;\n        } else {\n          erase.push(term[1].eras);\n          names.push(term[1].name);\n          types.push(term[1].bind ? show(term[1].bind, nams.concat(names.slice(0,-1))) : null);\n          term = term[1].body;\n        }\n      }\n      var text = \"{\";\n      for (var i = 0; i < names.length; ++i) {\n        text += erase[i] ? \"~\" : \"\";\n        text += names[i] + (types[i] !== null ? \" : \" + types[i] : \"\");\n        text += i < names.length - 1 ? \", \" : \"\";\n      }\n      text += \"} => \";\n      if (numb !== null) {\n        text += \"%\" + Number(numb);\n      } else {\n        text += show(term, nams.concat(names));\n      }\n      return text;\n    case \"App\":\n      var text = \")\";\n      var term = [ctor, args];\n      while (term[0] === \"App\") {\n        text = (term[1].func[0] === \"App\" ? \", \" : \"\") + (term[1].eras ? \"~\" : \"\") + show(term[1].argm, nams) + text;\n        term = term[1].func;\n      }\n      return \"(\" + show(term, nams) + \")\" + \"(\" + text;\n    case \"Box\":\n      var expr = show(args.expr, nams);\n      return \"(!\" + expr + \")\";\n    case \"Put\":\n      var expr = show(args.expr, nams);\n      return \"(#\" + expr + \")\";\n    case \"Dup\":\n      var name = args.name;\n      var expr = show(args.expr, nams);\n      var body = show(args.body, nams.concat([name]));\n      return \"dup \" + name + \" = \" + expr + \"; \" + body;\n    case \"U32\":\n      return \"U32\";\n    case \"Num\":\n      return args.numb.toString();\n    case \"Op1\":\n    case \"Op2\":\n      var func = args.func;\n      var num0 = show(args.num0, nams);\n      var num1 = show(args.num1, nams);\n      return \"|\" + num0 + \" \" + func + \" \" + num1 + \"|\";\n    case \"Ite\":\n      var cond = show(args.cond, nams);\n      var pair = show(args.pair, nams);\n      return \"(if \" + cond + \" \" + pair + \")\";\n    case \"Cpy\":\n      var name = args.name;\n      var numb = show(args.numb, nams);\n      var body = show(args.body, nams.concat([name]));\n      return \"cpy \" + name + \" = \" + numb + \"; \" + body;\n    case \"Sig\":\n      var name = args.name;\n      var typ0 = show(args.typ0, nams);\n      var typ1 = show(args.typ1, nams.concat([name]));\n      var comm = args.eras ? \" ~ \" : \",\";\n      return \"[\" + name + \" : \" + typ0 + comm + typ1 + \"]\";\n    case \"Par\":\n      var text = term_to_text([ctor, args]);\n      if (text !== null) {\n        return \"\\\"\" + text + \"\\\"\";\n      } else {\n        var val0 = show(args.val0, nams);\n        var val1 = show(args.val1, nams);\n        var eras = args.eras ? \"~\" : \"\";\n        return \"[\" + val0 + \", \" + eras + val1 + \"]\";\n      }\n    case \"Fst\":\n      var pair = show(args.pair, nams);\n      var eras = args.eras ? \"~\" : \"\";\n      return \"(\" + eras + \"fst \" + pair + \")\";\n    case \"Snd\":\n      var pair = show(args.pair, nams);\n      var eras = args.eras ? \"~\" : \"\";\n      return \"(\" + eras + \"snd \" + pair + \")\";\n    case \"Prj\":\n      var nam0 = args.nam0;\n      var nam1 = args.nam1;\n      var pair = show(args.pair, nams);\n      var body = show(args.body, nams.concat([nam0, nam1]));\n      var eras = args.eras ? \"~\" : \"\";\n      return \"get [\" + nam0 + \",\" + eras + nam1 + \"] = \" + pair + \"; \" + body;\n    case \"Eql\":\n      var val0 = show(args.val0, nams);\n      var val1 = show(args.val1, nams);\n      return \"<\" + val0 + \" == \" + val1 + \">\";\n    case \"Rfl\":\n      var expr = show(args.expr, nams);\n      return \"(rfl \" + expr + \")\";\n    case \"Sym\":\n      var prof = show(args.prof, nams);\n      return \"(sym \" + prof + \")\";\n    case \"Rwt\":\n      var prof = show(args.prof, nams);\n      var name = args.name;\n      var type = show(args.type, nams.concat([name]));\n      var expr = show(args.expr, nams);\n      return \"(rwt \" + prof + \" <\" + name + \" @ \" + type + \"> \" + expr + \")\";\n    case \"Cst\":\n      var prof = show(args.prof, nams);\n      var val0 = show(args.val0, nams);\n      var val1 = show(args.val1, nams);\n      return \"(cst \" + prof + \" \" + val0 + \" \" + val1 + \")\";\n    case \"Slf\":\n      var name = args.name;\n      var type = show(args.type, nams.concat([name]));\n      return \"$\" + name + \" \" + type;\n    case \"New\":\n      var type = show(args.type, nams);\n      var expr = show(args.expr, nams);\n      return \"&\" + type + \" \" + expr;\n    case \"Use\":\n      var expr = show(args.expr, nams);\n      return \"%\" + expr;\n    case \"Ann\":\n      var expr = show(args.expr, nams);\n      return expr;\n    case \"Ref\":\n      return args.name;\n  }\n};\n\n// Maps defs\nconst rename_refs = ([ctor, term], renamer) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index);\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var name = term.name;\n      var bind = rename_refs(term.bind, renamer);\n      var body = rename_refs(term.body, renamer);\n      var eras = term.eras;\n      return All(name, bind, body, eras);\n    case \"Lam\":\n      var name = term.name;\n      var bind = term.bind && rename_refs(term.bind, renamer);\n      var body = rename_refs(term.body, renamer);\n      var eras = term.eras;\n      return Lam(name, bind, body, eras);\n    case \"App\":\n      var func = rename_refs(term.func, renamer);\n      var argm = rename_refs(term.argm, renamer);\n      var eras = term.eras;\n      return App(func, argm, term.eras);\n    case \"Box\":\n      var expr = rename_refs(term.expr, renamer);\n      return Box(expr);\n    case \"Put\":\n      var expr = rename_refs(term.expr, renamer);\n      return Put(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = rename_refs(term.expr, renamer);\n      var body = rename_refs(term.body, renamer);\n      return Dup(name, expr, body);\n    case \"U32\":\n      return U32();\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = rename_refs(term.num0, renamer);\n      var num1 = rename_refs(term.num1, renamer);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = rename_refs(term.cond, renamer);\n      var pair = rename_refs(term.pair, renamer);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = rename_refs(term.numb, renamer);\n      var body = rename_refs(term.body, renamer);\n      return Cpy(name, numb, body);\n    case \"Sig\":\n      var name = term.name;\n      var typ0 = rename_refs(term.typ0, renamer);\n      var typ1 = rename_refs(term.typ1, renamer);\n      var eras = term.eras;\n      return Sig(name, typ0, typ1, eras);\n    case \"Par\":\n      var val0 = rename_refs(term.val0, renamer);\n      var val1 = rename_refs(term.val1, renamer);\n      var eras = term.eras;\n      return Par(val0, val1, eras);\n    case \"Fst\":\n      var pair = rename_refs(term.pair, renamer);\n      var eras = term.eras;\n      return Fst(pair, eras);\n    case \"Snd\":\n      var pair = rename_refs(term.pair, renamer);\n      var eras = term.eras;\n      return Snd(pair, eras);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = rename_refs(term.pair, renamer);\n      var body = rename_refs(term.body, renamer);\n      var eras = term.eras;\n      return Prj(nam0, nam1, pair, body, eras);\n    case \"Eql\":\n      var val0 = rename_refs(term.val0, renamer);\n      var val1 = rename_refs(term.val1, renamer);\n      return Eql(val0, val1);\n    case \"Rfl\":\n      var expr = rename_refs(term.expr, renamer);\n      return Rfl(expr);\n    case \"Sym\":\n      var prof = rename_refs(term.prof, renamer);\n      return Sym(prof);\n    case \"Rwt\":\n      var prof = rename_refs(term.prof, renamer);\n      var name = term.name;\n      var type = rename_refs(term.type, renamer);\n      var expr = rename_refs(term.expr, renamer);\n      return Rwt(prof, name, type, expr);\n    case \"Cst\":\n      var prof = rename_refs(term.prof, renamer);\n      var val0 = rename_refs(term.val0, renamer);\n      var val1 = rename_refs(term.val1, renamer);\n      return Cst(prof, val0, val1);\n    case \"Slf\":\n      var name = term.name;\n      var type = rename_refs(term.type, renamer);\n      return Slf(name, type);\n    case \"New\":\n      var type = rename_refs(term.type, renamer);\n      var expr = rename_refs(term.expr, renamer);\n      return New(type, expr);\n    case \"Use\":\n      var expr = rename_refs(term.expr, renamer);\n      return Use(expr);\n    case \"Ann\":\n      var type = rename_refs(term.type, renamer);\n      var expr = rename_refs(term.expr, renamer);\n      var done = term.done;\n      return Ann(type, expr, done);\n    case \"Ref\":\n      return Ref(renamer(term.name), term.eras);\n  }\n}\n\nconst prefix_refs = (prefix, defs) => {\n  var new_defs = {};\n  for (var name in defs) {\n    new_defs[prefix + name] = rename_refs(defs[name], ref_name => {\n      return (defs[ref_name] ? prefix : \"\") + ref_name;\n    });\n  }\n  return new_defs;\n};\n\n// :::::::::::::::::::\n// :: Syntax Sugars ::\n// :::::::::::::::::::\n\n// Converts an utf-8 string to a λ-encoded term\nconst text_to_term = (text) => {\n  // Converts UTF-8 to bytes\n  var bytes = [].slice.call(new TextEncoder(\"utf-8\").encode(text), 0);\n\n  // Converts bytes to uints\n  while (bytes.length % 4 !== 0) {\n    bytes.push(0);\n  }\n  var nums = new Uint32Array(new Uint8Array(bytes).buffer);\n\n  // Converts uints to C-List of nums\n  var term = Var(0);\n  for (var i = nums.length - 1; i >= 0; --i) {\n    term = App(App(Var(1), Num(nums[i]), false), term, false);\n  }\n  term = Par(Num(0x74786574), Lam(\"c\", null, Dup(\"c\", Var(0), Put(Lam(\"n\", null, term, false))), false), false);\n  return term;\n}\n\n// Converts a λ-encoded term to a string, if possible\nconst term_to_text = (term) => {\n  try {\n    if (term[1].val0[1].numb === 0x74786574) {\n      try {\n        term = term[1].val1[1].body[1].body[1].expr[1].body;\n      } catch(e) {\n        term = term[1].val1[1].body[1].body;\n      }\n      var nums = [];\n      while (term[0] !== \"Var\") {\n        if (term[1].func[1].func[1].index !== 1) {\n          return null;\n        }\n        nums.push(term[1].func[1].argm[1].numb);\n        term = term[1].argm;\n      }\n      if (term[1].index !== 0) {\n        return null;\n      }\n      return new TextDecoder(\"utf-8\").decode(new Uint8Array(new Uint32Array(nums).buffer));\n    } else {\n      return null;\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\n// Converts a number to a λ-encoded nat for repeated application (bounded for-loop)\nconst numb_to_term = (numb) => {\n  var term = Var(0);\n  var log2 = Math.floor(Math.log(numb) / Math.log(2));\n  for (var i = 0; i < log2 + 1; ++i) {\n    term = (numb >>> (log2 - i)) & 1 ? App(Var(i + 1), term, false) : term;\n  }\n  term = Put(Lam(\"x\", null, term, false));\n  for (var i = 0; i < log2; ++i) {\n    term = Dup(\"s\" + (log2 - i), Put(Lam(\"x\", null, App(Var(1), App(Var(1), Var(0), false), false), false)), term);\n  }\n  term = Lam(\"s\", null, Dup(\"s0\", Var(0), term), false);\n  return term;\n}\n\n// Converts a number to a λ-encoded nat for repeated application (bounded for-loop)\nconst numb_to_tree_term = (numb) => {\n  var term = Put(Var(0));\n  for (var i = 0; i < numb; ++i) {\n    term = Dup(\"b\" + (numb - i - 1), Put(App(App(Var(numb - i), Var(0), false), Var(0), false)), term);\n  }\n  term = Dup(\"n\", Var(1), term);\n  term = Dup(\"b\", Var(1), term);\n  term = Lam(\"n\", null, term, false);\n  term = Lam(\"b\", null, term, false);\n  return term;\n}\n\n// Converts a λ-encoded nat to a number, if possible\nconst term_to_numb = (term) => {\n  return null;\n  try {\n    try {\n      term = term[1].body[1].body[1].expr[1].body;\n    } catch(e) {\n      term = term[1].body[1].body;\n    }\n    var count = 0;\n    while (term[0] !== \"Var\") {\n      if (term[1].func[1].index !== 1) {\n        return null;\n      }\n      count++;\n      term = term[1].argm;\n    }\n    if (term[1].index !== 0) {\n      return null;\n    }\n    return count;\n  } catch (e) {\n    return null;\n  }\n}\n\n// Syntax sugars for datatypes. They transform a statement like:\n// \n//   data ADT <p0 : Param0, p1 : Param1...> {i0 : Index0, i1 : Index1}\n//   | ctr0 {ctr_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} : Cr0Type \n//   | ctr1 {ctr_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} : Cr0Type \n//   | ...\n//\n// on its corresponding self-encoded datatype:\n//\n//   def ADT\n//   = {p0 : Param0, p1 : Param1, ..., i0 : Index0, i1 : Index1, ...} =>\n//     : Type\n//     $ self\n//     {~P   : {i0 : Index0, i1 : Index1, ..., wit : (ADT i0 i1...)} -> Type} ->\n//     {ctr0 : {ctr0_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} -> (Ctr0Type[ADT <- P] (ADT.ctr0 Param0 Param1... ctr0_fld0 ctr0_fld1 ...))} ->\n//     {ctr1 : {ctr1_fld0 : Ctr1_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} -> (Ctr0Type[ADT <- P] (ADT.ctr1 Param0 Param1... ctr1_fld1 ctr0_fld1 ...))} ->\n//     ... ->\n//     (P i0 i1... self)\n//  \n//   def ADT.ctr0\n//   = {~p0 : Param0, ~p1 : Param1, ..., ctr0_fld0 : Ctr0_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} =>\n//     : Ctr0Type\n//     @ Ctr0Type\n//       {~P, ctr0, ctr1, ...} => \n//       (ctr0 ctr0_fld0 ctr0_fld1 ...)\n//\n//   (...)\nconst derive_adt_type = ({adt_pram, adt_indx, adt_ctor, adt_name}) => {\n  return (function adt_arg(p, i) {\n    // ... {p0 : Param0, p1 : Param1...} ...\n    if (p < adt_pram.length) {\n      return Lam(adt_pram[p][0], adt_pram[p][1], adt_arg(p + 1, i), adt_pram[p][2]);\n    // ... {i0 : Index0, i1 : Index...} ...\n    } else if (i < adt_indx.length) {\n      var substs = [Ref(adt_name)];\n      for (var P = 0; P < p; ++P) {\n        substs.push(Var(-1 + i + p - P));\n      }\n      return Lam(adt_indx[i][0], subst_many(adt_indx[i][1], substs, i), adt_arg(p, i + 1), adt_indx[i][2]);\n    } else {\n      return (\n        // ... : Type ...\n        Ann(Typ(),\n        // ... $ self ...\n        Slf(\"self\",\n        // ... P : ...\n        All(\"P\",\n          (function motive(i) {\n            // ... {i0 : Index0, i1 : Index1...} ...\n            if (i < adt_indx.length) {\n              var substs = [Ref(adt_name)];\n              for (var P = 0; P < p; ++P) {\n                substs.push(Var(-1 + i + 1 + adt_indx.length + p - P));\n              }\n              return All(adt_indx[i][0], subst_many(adt_indx[i][1], substs, i), motive(i + 1), adt_indx[i][2]);\n            // ... {wit : (ADT i0 i1...)} -> Type ...\n            } else {\n              var wit_t = Ref(adt_name);\n              for (var P = 0; P < adt_pram.length; ++P) {\n                wit_t = App(wit_t, Var(-1 + i + 1 + i + adt_pram.length - P), adt_pram[P][2]); \n              }\n              for (var I = 0; I < i; ++I) {\n                wit_t = App(wit_t, Var(-1 + i - I), adt_indx[I][2]);\n              }\n              return All(\"wit\", wit_t, Typ(), false);\n            }\n          })(0),\n        (function ctor(i) {\n          if (i < adt_ctor.length) {\n            // ... ctrX : ...\n            return All(adt_ctor[i][0], (function field(j) {\n              var subst_prams = [];\n              for (var P = 0; P < adt_pram.length; ++P) {\n                subst_prams.push(Var(-1 + j + i + 1 + 1 + adt_indx.length + adt_pram.length - P));\n              }\n              // ... {ctrX_fldX : CtrX_FldX, ctrX_fld1 : CtrX_Fld1, ...} -> ...\n              if (j < adt_ctor[i][1].length) {\n                var sub = [Ref(adt_name)].concat(subst_prams);\n                var typ = subst_many(adt_ctor[i][1][j][1], sub, j);\n                return All(adt_ctor[i][1][j][0], typ, field(j + 1), adt_ctor[i][1][j][2]);\n              // ... (CtrXType[ADT <- P] (ADT.ctrX ParamX Param1... ctrX_fldX ctrX_fld1 ...)) -> ...\n              } else {\n                var typ = adt_ctor[i][2];\n                var sub = [Var(-1 + j + i + 1)].concat(subst_prams);\n                var typ = subst_many(adt_ctor[i][2], sub, j);\n                var rem = typ;\n                for (var I = 0; I < adt_indx.length; ++I) {\n                  rem = rem[1].func;\n                }\n                rem[0] = \"Var\";\n                rem[1] = {index: -1 + i + j + 1};\n                var wit = Ref(adt_name + \".\" + adt_ctor[i][0]);\n                for (var P = 0; P < adt_pram.length; ++P) {\n                  var wit = App(wit, Var(-1 + j + i + 1 + 1 + adt_indx.length + adt_pram.length - P), true);\n                }\n                for (var F = 0; F < adt_ctor[i][1].length; ++F) {\n                  var wit = App(wit, Var(-1 + j - F), adt_ctor[i][1][F][2]);\n                }\n                return App(typ, wit, false);\n              }\n            })(0),\n            ctor(i + 1),\n            false);\n          } else {\n            // ... (P i0 i1... self)\n            var ret = Var(adt_ctor.length + 1 - 1);\n            for (var i = 0; i < adt_indx.length; ++i) {\n              var ret = App(ret, Var(adt_ctor.length + 1 + 1 + adt_indx.length - i - 1), adt_indx[i][2]); \n            }\n            var ret = App(ret, Var(adt_ctor.length + 1 + 1 - 1), false);\n            return ret;\n          }\n        })(0),\n        true))));\n    }\n  })(0, 0);\n}\n\nconst derive_adt_ctor = ({adt_pram, adt_indx, adt_ctor, adt_name}, c) => {\n  return (function arg(p, i, f) {\n    var substs = [Ref(adt_name)];\n    for (var P = 0; P < p; ++P) {\n      substs.push(Var(-1 + f + p - P));\n    }\n    // {~p0 : Param0, ~p1 : Param1...} ...\n    if (p < adt_pram.length) {\n      return Lam(adt_pram[p][0], adt_pram[p][1], arg(p + 1, i, f), true);\n    // ... {ctr0_fld0 : Ctr0_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} ...\n    } else if (f < adt_ctor[c][1].length) {\n      return Lam(adt_ctor[c][1][f][0], subst_many(adt_ctor[c][1][f][1], substs, f), arg(p, i, f + 1), adt_ctor[c][1][f][2]);\n    } else {\n      var type = subst_many(adt_ctor[c][2], substs, f);\n      // ... : CtrXType {~P} ...\n      return Ann(type, New(type, Lam(\"P\", null, (function opt(k) {\n        // ... {ctr0, ctr1...} ...\n        if (k < adt_ctor.length) {\n          return Lam(adt_ctor[k][0], null, opt(k + 1), false);\n        // (ctrX ctrX_fld0 ctrX_fld1 ...)\n        } else {\n          var sel = Var(-1 + adt_ctor.length - c);\n          for (var F = 0; F < adt_ctor[c][1].length; ++F) {\n            var sel = App(sel, Var(-1 + adt_ctor.length + 1 + adt_ctor[c][1].length - F), adt_ctor[c][1][F][2]);\n          }\n          return sel;\n        }\n      })(0), true)), false);\n    }\n  })(0, adt_indx.length, 0);\n}\n\nconst derive_dependent_match = ({names, types, cased, erase, cadts}, type, case_tree) => {\n  return (function arg(a, last_carry = 0, carry = [], branch = []) {\n    //console.log(\"building arg \", a);\n\n    // For each argument to be projected\n    if (a < names.length) {\n      if (!cadts[a]) {\n        //console.log(\"not an adt\");\n        return arg(a + 1, last_carry, carry, branch);\n      } else {\n        var {adt_name, adt_pram, adt_indx, adt_ctor} = cadts[a];\n        //console.log(\"it is the adt\", adt_name);\n\n        // Creates the inductive pattern-matching function of this argument\n        var term = Use(Var(-1 + names.length - a));\n\n        // Applies the motive of this argument\n        var term = App(term, (function motive_idxs(i) {\n          if (i < adt_indx.length) {\n            return Lam(adt_indx[i][0], null, motive_idxs(i + 1), false);\n          } else {\n            return Lam(\"self\", null, (function motive_others(v) {\n              var substs = [];\n              for (var V = 0; V < v; ++V) {\n                var to_self = (v < a ? v : v - 1) + (v >= names.length ? carry.length : 0);\n                substs.push(Var(to_self - (V < a ? V + 1 : V === a ? 0 : V)));\n              }\n              if (v < names.length) {\n                if (v === a) {\n                  return motive_others(v + 1);\n                } else {\n                  return All(names[v], subst_many(types[v], substs, 0), motive_others(v + 1), v < a && cased[v]);\n                }\n              } else {\n                return (function motive_carrys(k) {\n                  if (k < carry.length) {\n                    return All(carry[k][0], carry[k][1], motive_carrys(k + 1), false);\n                  } else {\n                    return subst_many(type, substs, 0);\n                  }\n                })(0);\n              }\n            })(0), false);\n          }\n        })(0), true);\n\n        // Applies each case of this argument\n        for (var c = 0; c < adt_ctor.length; ++c) {\n          //console.log(\"building case\", adt_ctor[c][0]);\n          term = App(term, (function cases(f, v, k) {\n            // Case fields\n            if (f < adt_ctor[c][1].length) {\n              //console.log(\"field\", adt_ctor[c][1][f]);\n              return Lam(names[a] + \".\" + adt_ctor[c][1][f][0], null, cases(f + 1, v, k), adt_ctor[c][1][f][2]);\n            // Variables to hold the other values\n            } else if (v < names.length) {\n              // If this is the matched value, rebuild it\n              if (v === a) {\n                var wit = Ref(adt_name + \".\" + adt_ctor[c][0]);\n                for (var F = 0; F < f; ++F) {\n                  wit = App(wit, Var(-1 + v + f - F), adt_ctor[c][1][F][2]);\n                }\n                return subst(cases(f, v + 1, k), wit, 0);\n              // Otherwise, just create a lam for it\n              } else {\n                return Lam(names[v], null, cases(f, v + 1, k), v < a && cased[v]);\n              }\n            // Variables to hold carried values\n            } else if (k < carry.length) {\n              return Lam(carry[k][0], null, cases(f, v, k + 1), false);\n            // Body of the case\n            } else {\n              var new_carry = adt_ctor[c][1].map(([name,type,eras]) => {\n                return [names[a] + \".\" + name, subst(type, Ref(adt_name), 0)];\n              });\n              //console.log(\"extending carry\", JSON.stringify(carry), JSON.stringify(new_carry));\n              var case_body = arg(a + 1, adt_ctor[c][1].length, carry.concat(new_carry), branch.concat([adt_ctor[c][0]]));\n              //console.log(\"ue\", a + 1, names.length);\n              //if (a + 1 < names.length) {\n                //for (var C = 0; C < adt_ctor[c][1].length; ++C) {\n                  //case_body = App(case_body, Var(-1 + (v - 1) + adt_ctor[c][1].length - C), false);\n                  //case_body = App(case_body, Var(-1 + carry.length + names.length + adt_ctor[c][1].length - C), false);\n                //}\n              //}\n              return case_body;\n            }\n          })(0, 0, 0), false);\n        }\n\n        // Applies other values\n        for (var v = 0; v < names.length; ++v) {\n          if (v !== a) {\n            term = App(term, Var(-1 + carry.length - last_carry + names.length - v), v < a && cased[v]);\n          }\n        }\n\n        // Applies old carry values\n        for (var k = 0; k < carry.length - last_carry; ++k) {\n          term = App(term, Var(-1 + carry.length - last_carry - k), false);\n        }\n\n        // Applies new carry values\n        for (var k = 0; k < last_carry; ++k) {\n          term = App(term, Var(-1 + carry.length + names.length - k), false);\n        }\n\n        return term;\n      }\n\n    // Done (i.e., this is the deepest spot, so, put the nth pattern-matching body here)\n    } else {\n      var substs = [];\n\n      // Substitutes other values\n      for (var v = 0; v < names.length; ++v) {\n        if (v !== a) {\n          substs.push(Var(-1 + carry.length - last_carry + names.length - v));\n        }\n      }\n\n      // Substitutes old carry values\n      for (var k = 0; k < carry.length - last_carry; ++k) {\n        substs.push(Var(-1 + carry.length - last_carry - k));\n      }\n\n      // Substitutes new carry values\n      for (var k = 0; k < last_carry; ++k) {\n        substs.push(Var(-1 + carry.length + names.length - k));\n      }\n      var term = case_tree[branch.join(\"_\")];\n      var term = subst_many(term, substs, 0);\n      return term;\n    }\n  })(0);\n}\n\nmodule.exports = {\n  Var,\n  Typ,\n  All,\n  Lam,\n  App,\n  Box,\n  Put,\n  Dup,\n  U32,\n  Num,\n  Op1,\n  Op2,\n  Ite,\n  Cpy,\n  Sig,\n  Par,\n  Fst,\n  Snd,\n  Prj,\n  Eql,\n  Rfl,\n  Sym,\n  Rwt,\n  Cst,\n  Slf,\n  New,\n  Use,\n  Ann,\n  Ref,\n  shift,\n  subst,\n  subst_many,\n  norm,\n  erase,\n  equal,\n  boxcheck: boxcheck(show),\n  typecheck: typecheck(show),\n  parse,\n  gen_name,\n  show,\n  rename_refs,\n  prefix_refs,\n  text_to_term,\n  term_to_text,\n  numb_to_term,\n  numb_to_tree_term,\n  term_to_numb,\n  derive_adt_type,\n  derive_adt_ctor,\n  derive_dependent_match\n};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/FM-Core/fm-lang.js?");

/***/ }),

/***/ "../Formality-JavaScript/FM-Core/fm-to-js.js":
/*!***************************************************!*\
  !*** ../Formality-JavaScript/FM-Core/fm-to-js.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fmc = __webpack_require__(/*! ./fm-lang.js */ \"../Formality-JavaScript/FM-Core/fm-lang.js\");\n\n// Converts a Formality-Core Term to a native JavaScript function\nconst compile = (term, defs, vars) => {\n  var [ctor, term] = term();\n  switch (ctor) {\n    case \"Var\":\n      for (var i = 0; i < term.index; ++i) {\n        vars = vars[1];\n      }\n      return vars[0];\n    case \"Lam\":\n      return x => compile(term.body, defs, [x, vars]);\n    case \"App\":\n      var func = compile(term.func, defs, vars);\n      var argm = compile(term.argm, defs, vars);\n      return func(argm);\n    case \"Put\":\n      return compile(term.expr, defs, vars);\n    case \"Dup\": \n      var expr = compile(term.expr, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(expr);\n    case \"Num\":\n      return term.numb;\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = compile(term.num0, defs, vars);\n      var num1 = compile(term.num1, defs, vars);\n      switch (func) {\n        case \"+\"  : return (num0 + num1) >>> 0;\n        case \"-\"  : return (num0 - num1) >>> 0;\n        case \"*\"  : return (num0 * num1) >>> 0;\n        case \"/\"  : return (num0 / num1) >>> 0;\n        case \"%\"  : return (num0 % num1) >>> 0;\n        case \"**\" : return (num0 ** num1) >>> 0;\n        case \"^^\" : return (num0 ** (num1 / (2 ** 32))) >>> 0;\n        case \"&\"  : return (num0 & num1) >>> 0;\n        case \"|\"  : return (num0 | num1) >>> 0;\n        case \"^\"  : return (num0 ^ num1) >>> 0;\n        case \"~\"  : return (~ num1) >>> 0;\n        case \">>\" : return (num0 >>> num1) >>> 0;\n        case \"<<\" : return (num0 << num1) >>> 0;\n        case \">\"  : return (num0 > num1) >>> 0;\n        case \"<\"  : return (num0 < num1) >>> 0;\n        case \"==\" : return (num0 === num1) >>> 0;\n      }\n    case \"Ite\":\n      var cond = compile(term.cond, defs, vars);\n      var pair = compile(term.pair, defs, vars);\n      return cond ? pair[0] : pair[1];\n    case \"Cpy\":\n      var numb = compile(term.numb, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(numb);\n    case \"Par\":\n      var val0 = compile(term.val0, defs, vars);\n      var val1 = compile(term.val1, defs, vars);\n      return [val0, val1];\n    case \"Fst\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[0];\n    case \"Snd\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[1];\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = compile(term.pair, defs, vars);\n      var body = (x,y) => compile(term.body, defs, [y,[x,vars]]);\n      return body(pair[0], pair[1]);\n    case \"Ref\":\n      return compile(fmc.erase(defs[term.name]), defs, vars);\n  }\n};\n\n// Converts a native JavaScript function back to a Formality-Core term\nconst decompile = (func) => {\n  return (function go(term, depth) {\n    function APP(variable) {\n      return function FMC_DECOMPILE_GET(arg){\n        if (arg === null) {\n          return variable;\n        } else {\n          return APP(d => fmc.App(variable(d), go(arg, d)));\n        }\n      };\n    };\n    function VAR(d) {\n      return fmc.Var(d - 1 - depth);\n    };\n    if (typeof term === \"function\" && term.name === \"FMC_DECOMPILE_GET\") {\n      return term(null)(depth);\n    } else if (typeof term === \"object\") {\n      var val0 = go(term[0], depth);\n      var val1 = go(term[1], depth);\n      return fmc.Par(val0, val1);\n    } else if (typeof term === \"number\") {\n      return fmc.Num(term);\n    } else if (typeof term === \"function\") {\n      var body = go(term(APP(VAR)), depth + 1);\n      return fmc.Lam(fmc.gen_name(depth), body);\n    } else if (typeof term === \"string\") {\n      throw \"[ERROR]\\nThis native JS function can't be decompiled to FMC:\\n\\n\"\n        + func.toString()\n        + \"\\n\\nIt possibly uses numeric operators on free variables, which can't be decompiled yet.\";\n    } else {\n      return term;\n    }\n  })(func, 0);\n};\n\nmodule.exports = {compile, decompile};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/FM-Core/fm-to-js.js?");

/***/ }),

/***/ "../Formality-JavaScript/FM-Core/fm-to-net.js":
/*!****************************************************!*\
  !*** ../Formality-JavaScript/FM-Core/fm-to-net.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ~~ Compiles Formality Core to Formality Net ~~\n\nconst {Var, App, Lam, Num, Op1, Op2, Ite, Par, Fst, Snd, gen_name, erase} = __webpack_require__(/*! ./fm-lang.js */ \"../Formality-JavaScript/FM-Core/fm-lang.js\");\nconst {Net, Pointer, Numeric, addr_of, slot_of, type_of, numb_of, NOD, OP1, OP2, NUM, ITE, PTR, FOR} = __webpack_require__(/*! formality-net */ \"../Formality-JavaScript/FM-Core/node_modules/formality-net/fm-net.js\");\n\nconst op_kind = {\n   0 : \"+\"  , \"+\"  : 0, \n   1 : \"-\"  , \"-\"  : 1, \n   2 : \"*\"  , \"*\"  : 2, \n   3 : \"/\"  , \"/\"  : 3, \n   4 : \"%\"  , \"%\"  : 4,\n   5 : \"**\" , \"**\" : 5,\n   6 : \"^^\" , \"^^\" : 6,\n   7 : \"&\"  , \"&\"  : 7,\n   8 : \"|\"  , \"|\"  : 8,\n   9 : \"^\"  , \"^\"  : 9,\n  10 : \"~\"  , \"~\"  : 10,\n  11 : \">>\" , \">>\" : 11,\n  12 : \"<<\" , \"<<\" : 12,\n  13 : \">\"  , \">\"  : 13,\n  14 : \"<\"  , \"<\"  : 14,\n  15 : \"==\" , \"==\"  : 15,\n};\n\nconst compile = (term, defs = {}) => {\n  const build_net = (term, net, var_ptrs, level) => {\n    const get_var = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return ptrn;\n      } else {\n        if (net.enter_port(ptrn) === ptrn) {\n          return ptrn;\n        } else {\n          var dups_ptrn = net.enter_port(ptrn);\n          var dup_addr = net.alloc_node(NOD, level_of[ptrn] + 1);\n          net.link_ports(Pointer(dup_addr, 0), ptrn);\n          net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n          return Pointer(dup_addr, 2);\n        }\n      }\n    };\n    switch (term[0]) {\n      case \"Dup\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level);\n        level_of[expr_ptr] = level;\n        var_ptrs.push(expr_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Put\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level + 1);\n        return expr_ptr;\n      case \"Lam\":\n        var lam_addr = net.alloc_node(NOD, 0);\n        net.link_ports(Pointer(lam_addr, 1), Pointer(lam_addr, 1));\n        level_of[Pointer(lam_addr, 1)] = level;\n        var_ptrs.push(Pointer(lam_addr, 1));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        net.link_ports(Pointer(lam_addr, 2), body_ptr);\n        return Pointer(lam_addr, 0);\n      case \"App\":\n        var app_addr = net.alloc_node(NOD, 0);\n        var func_ptr = build_net(term[1].func, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 0), func_ptr);\n        var argm_ptr = build_net(term[1].argm, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 1), argm_ptr)\n        return Pointer(app_addr, 2);\n      case \"Num\":\n        return Numeric(term[1].numb >>> 0);\n      case \"Op1\":\n        var op1_addr = net.alloc_node(OP1, op_kind[term[1].func]);\n        net.link_ports(Numeric(term[1].num1()[1].numb), Pointer(op1_addr, 1));\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(num0_ptr, Pointer(op1_addr, 0));\n        return Pointer(op1_addr, 2);\n      case \"Op2\":\n        var op2_addr = net.alloc_node(OP2, op_kind[term[1].func]);\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 1), num0_ptr);\n        var num1_ptr = build_net(term[1].num1, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 0), num1_ptr);\n        return Pointer(op2_addr, 2);\n      case \"Par\":\n        var par_addr = net.alloc_node(NOD, 0xFFFF);\n        var val0_ptr = build_net(term[1].val0, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 1), val0_ptr);\n        var val1_ptr = build_net(term[1].val1, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 2), val1_ptr);\n        return Pointer(par_addr, 0);\n      case \"Fst\":\n        var fst_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(fst_addr, 0), pair_ptr);\n        net.link_ports(Pointer(fst_addr, 2), Pointer(fst_addr, 2));\n        return Pointer(fst_addr, 1);\n      case \"Snd\":\n        var snd_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(snd_addr, 0), pair_ptr);\n        net.link_ports(Pointer(snd_addr, 1), Pointer(snd_addr, 1));\n        return Pointer(snd_addr, 2);\n      case \"Prj\":\n        var prj_addr = net.alloc_node(NOD, 0xFFFF);\n        level_of[Pointer(prj_addr, 1)] = level;\n        level_of[Pointer(prj_addr, 2)] = level;\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        var_ptrs.push(Pointer(prj_addr, 1));\n        var_ptrs.push(Pointer(prj_addr, 2));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        var_ptrs.pop();\n        net.link_ports(Pointer(prj_addr, 0), pair_ptr);\n        return body_ptr;\n      case \"Ite\":\n        var ite_addr = net.alloc_node(ITE, 0xFFFF);\n        var cond_ptr = build_net(term[1].cond, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 0), cond_ptr);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 1), pair_ptr);\n        return Pointer(ite_addr, 2);\n      case \"Cpy\":\n        var numb_ptr = build_net(term[1].numb, net, var_ptrs, level);\n        level_of[numb_ptr] = 0xFFFE;\n        var_ptrs.push(numb_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Var\":\n        return get_var(var_ptrs[var_ptrs.length - term[1].index - 1]);\n      case \"Ref\":\n        return build_net(erase(defs[term[1].name]), net, var_ptrs, level);\n      default:\n        return build_net(Lam(\"\", null, Var(0), false), net, var_ptrs, level);\n    }\n  };\n  var level_of = {};\n  var net = new Net();\n  var root_addr = net.alloc_node(NOD, 0);\n  var term_ptr = build_net(term, net, [], 0);\n  net.link_ports(Pointer(root_addr, 0), Pointer(root_addr, 2));\n  net.link_ports(Pointer(root_addr, 1), term_ptr);\n  // Removes invalid redexes. They can be created by the\n  // compiler when duplicating variables more than once.\n  net.redex = net.redex.filter((a_addr) => {\n    var b_ptrn = net.enter_port(Pointer(a_addr, 0));\n    if (type_of(b_ptrn) !== NUM) {\n      var b_addr = addr_of(b_ptrn);\n      var a_p0 = Pointer(a_addr, 0);\n      var b_p0 = Pointer(b_addr, 0);\n      var a_ok = net.enter_port(a_p0) === b_p0;\n      var b_ok = net.enter_port(b_p0) === a_p0;\n      return a_ok && b_ok;\n    } else {\n      return true;\n    }\n  });\n  return net;\n};\n\nconst decompile = (net) => {\n  const build_term = (net, ptrn, var_ptrs, dup_exit) => {\n    if (type_of(ptrn) === NUM) {\n      return Num(numb_of(ptrn));\n    } else {\n      var addr = addr_of(ptrn);\n      var type = net.type_of(addr);\n      var kind = net.kind_of(addr);\n      if (type === NOD) {\n        if (kind === 0) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var_ptrs.push(Pointer(addr, 1));\n              var body = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              var_ptrs.pop();\n              return Lam(gen_name(var_ptrs.length), null, body, false);\n            case 1:\n              for (var index = 0; index < var_ptrs.length; ++index) {\n                if (var_ptrs[var_ptrs.length - index - 1] === ptrn) {\n                  return Var(index);\n                }\n              }\n            case 2:\n              var argm = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var func = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return App(func, argm, false);\n          }\n        } else if (kind === 0xFFFF) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var val0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var val1 = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              return Par(val0, val1);\n            case 1:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Fst(pair);\n            case 2:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Snd(pair);\n          }\n        } else {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var exit = dup_exit.pop();\n              var term = build_term(net, net.enter_port(Pointer(addr, exit)), var_ptrs, dup_exit);\n              dup_exit.push(exit);\n              return term;\n            default:\n              dup_exit.push(slot_of(ptrn));\n              var term = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              dup_exit.pop();\n              return term;\n          }\n        }\n      } else if (type === OP1) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var num1 = Num(numb_of(net.enter_port(Pointer(addr, 1))));\n        return Op1(op_kind[kind], num0, num1);\n      } else if (type === OP2) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        var num1 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        return Op2(op_kind[kind], num0, num1);\n      } else if (type === ITE) {\n        var cond = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var pair = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        return Ite(cond, pair);\n      }\n    }\n  };\n  return build_term(net, net.enter_port(Pointer(0, 1)), [], []);\n};\n\nconst norm_with_stats = (term, defs = {}, lazy = true) => {\n  var net = compile(term, defs);\n  var stats = lazy ? net.reduce_lazy() : net.reduce();\n  var norm = decompile(net);\n  return {norm, stats};\n};\n\nconst norm = (term, defs, lazy) => {\n  return norm_with_stats(term, defs, lazy).norm;\n};\n\nmodule.exports = {compile, decompile, norm_with_stats, norm};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/FM-Core/fm-to-net.js?");

/***/ }),

/***/ "../Formality-JavaScript/FM-Core/node_modules/formality-net/fm-net.js":
/*!****************************************************************************!*\
  !*** ../Formality-JavaScript/FM-Core/node_modules/formality-net/fm-net.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Interaction Net System ~~\n\nconst Pointer = (addr, port) => (addr << 2) + (port & 3);\nconst addr_of = (ptr) => ptr >>> 2;\nconst slot_of = (ptr) => ptr & 3;\nconst Numeric = (numb) => numb + 0x100000000;\nconst numb_of = (numb) => numb - 0x100000000;\nconst type_of = (ptrn) => ptrn >= 0x100000000 ? NUM : PTR;\n\n// PtrNum types\nconst PTR = 0;\nconst NUM = 1;\n\n// Node types\nconst NOD = 0;\nconst OP1 = 1;\nconst OP2 = 2;\nconst ITE = 3;\n\nclass Net {\n  // A net stores nodes (this.nodes), reclaimable memory addrs (this.freed) and active pairs (this.redex)\n  constructor() {\n    this.nodes = []; // nodes\n    this.freed = []; // integers\n    this.redex = []; // array of (integer, integer) tuples representing addrs\n    this.find_redex = true;\n  }\n\n  // Allocates a new node, return its addr\n  alloc_node(type, kind) {\n\n    // If there is reclaimable memory, use it\n    if (this.freed.length > 0) {\n      var addr = this.freed.pop();\n\n    // Otherwise, extend the array of nodes\n    } else {\n      var addr = this.nodes.length / 4;\n    }\n\n    // Fill the memory with an empty node without pointers\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = (kind << 6) + ((type & 0x7) << 3);\n    return addr;\n  }\n\n  // Deallocates a node, allowing its space to be reclaimed\n  free_node(addr) {\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = 0;\n    this.freed.push(addr);\n  }\n\n  is_free(addr) {\n    return this.nodes[addr * 4 + 0] === addr * 4 + 0\n        && this.nodes[addr * 4 + 1] === addr * 4 + 1\n        && this.nodes[addr * 4 + 2] === addr * 4 + 2\n        && this.nodes[addr * 4 + 3] === 0;\n  }\n\n  // Returns if given slot holds a number\n  is_numeric(addr, slot) {\n    return (this.nodes[addr * 4 + 3] >>> slot) & 1; \n  }\n\n  set_port(addr, slot, ptrn) {\n    if (type_of(ptrn) === NUM) {\n      this.nodes[addr * 4 + slot] = numb_of(ptrn);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] | (1 << slot);\n    } else {\n      this.nodes[addr * 4 + slot] = ptrn;\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] & ~(1 << slot);\n    }\n  }\n\n  get_port(addr, slot) {\n    return this.nodes[addr * 4 + slot] + (this.is_numeric(addr, slot) ? 0x100000000 : 0);\n  }\n\n  type_of(addr) {\n    return (this.nodes[addr * 4 + 3] >>> 3) & 0x7;\n  }\n\n  set_type(addr, type) {\n    this.nodes[addr * 4 + 3] = (this.nodes[addr * 4 + 3] & ~0b111000) | (type << 3);\n  }\n\n  kind_of(addr) {\n    return this.nodes[addr * 4 + 3] >>> 6;\n  }\n\n  // Given a pointer to a port, returns a pointer to the opposing port\n  enter_port(ptrn) {\n    if (type_of(ptrn) === NUM) { \n      throw \"Can't enter a numeric pointer.\";\n    } else {\n      return this.get_port(addr_of(ptrn), slot_of(ptrn));\n    }\n  }\n\n  // Connects two ports\n  link_ports(a_ptrn, b_ptrn) {\n    var a_numb = type_of(a_ptrn) === NUM;\n    var b_numb = type_of(b_ptrn) === NUM;\n\n    // Point ports to each-other\n    if (!a_numb) this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), b_ptrn);\n    if (!b_numb) this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), a_ptrn);\n\n    // If both are main ports, add this to the list of active pairs\n    if (this.find_redex && !(a_numb && b_numb) && (a_numb || slot_of(a_ptrn) === 0) && (b_numb || slot_of(b_ptrn) === 0)) {\n      this.redex.push(a_numb ? addr_of(b_ptrn) : addr_of(a_ptrn));\n    }\n  }\n\n  // Disconnects a port, causing both sides to point to themselves\n  unlink_port(a_ptrn) {\n    if (type_of(a_ptrn) === PTR) {\n      var b_ptrn = this.enter_port(a_ptrn);\n      if (type_of(b_ptrn) === PTR && this.enter_port(b_ptrn) === a_ptrn) {\n        this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), a_ptrn);\n        this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), b_ptrn);\n      }\n    }\n  }\n\n  // Rewrites an active pair\n  rewrite(a_addr) {\n    var a_ptrn = Pointer(a_addr, 0);\n    var b_ptrn = this.get_port(a_addr, 0);\n    if (type_of(b_ptrn) === NUM) {\n      var a_type = this.type_of(a_addr);\n      var a_kind = this.kind_of(a_addr);\n\n      // UnaryOperation\n      if (a_type === OP1) {\n        var dst = this.enter_port(Pointer(a_addr, 2));\n        var fst = numb_of(b_ptrn);\n        var snd = numb_of(this.enter_port(Pointer(a_addr, 1)));\n        switch (a_kind) {\n          case  0: var res = Numeric((fst + snd) >>> 0); break;\n          case  1: var res = Numeric((fst - snd) >>> 0); break;\n          case  2: var res = Numeric((fst * snd) >>> 0); break;\n          case  3: var res = Numeric((fst / snd) >>> 0); break;\n          case  4: var res = Numeric((fst % snd) >>> 0); break;\n          case  5: var res = Numeric((fst ** snd) >>> 0); break;\n          case  6: var res = Numeric((fst ** (snd / (2 ** 32)) >>> 0)); break;\n          case  7: var res = Numeric((fst & snd) >>> 0); break;\n          case  8: var res = Numeric((fst | snd) >>> 0); break;\n          case  9: var res = Numeric((fst ^ snd) >>> 0); break;\n          case 10: var res = Numeric((~snd) >>> 0); break;\n          case 11: var res = Numeric((fst >>> snd) >>> 0); break;\n          case 12: var res = Numeric((fst << snd) >>> 0); break;\n          case 13: var res = Numeric((fst > snd ? 1 : 0) >>> 0); break;\n          case 14: var res = Numeric((fst < snd ? 1 : 0) >>> 0); break;\n          case 15: var res = Numeric((fst == snd ? 1 : 0) >>> 0); break;\n          default: throw \"[ERROR]\\nInvalid interaction.\";\n        }\n        this.link_ports(dst, res);\n        this.unlink_port(Pointer(a_addr, 0));\n        this.unlink_port(Pointer(a_addr, 2));\n        this.free_node(a_addr);\n      \n      // BinaryOperation\n      } else if (a_type === OP2) {\n        this.set_type(a_addr, OP1);\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.unlink_port(Pointer(a_addr, 1));\n        this.link_ports(Pointer(a_addr, 1), b_ptrn);\n    \n      // NumberDuplication\n      } else if (a_type === NOD) {\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 2)));\n        this.free_node(a_addr);\n\n      // IfThenElse\n      } else if (a_type === ITE) {\n        var cond_val = numb_of(b_ptrn) === 0;\n        var pair_ptr = this.enter_port(Pointer(a_addr, 1));\n        this.set_type(a_addr, NOD);\n        this.link_ports(Pointer(a_addr, 0), pair_ptr);\n        this.unlink_port(Pointer(a_addr, 1));\n        var dest_ptr = this.enter_port(Pointer(a_addr, 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 2 : 1), dest_ptr);\n        if (!cond_val) this.unlink_port(Pointer(a_addr, 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 1 : 2), Pointer(a_addr, cond_val ? 1 : 2));\n\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n\n    } else {\n      var b_addr = addr_of(b_ptrn);\n      var a_type = this.type_of(a_addr);\n      var b_type = this.type_of(b_addr);\n      var a_kind = this.kind_of(a_addr);\n      var b_kind = this.kind_of(b_addr);\n\n      // NodeAnnihilation, UnaryAnnihilation, BinaryAnnihilation\n      if ( a_type === NOD && b_type === NOD && a_kind === b_kind\n        || a_type === OP1 && b_type === OP1\n        || a_type === OP2 && b_type === OP2\n        || a_type === ITE && b_type === ITE) {\n        var a_aux1_dest = this.enter_port(Pointer(a_addr, 1));\n        var b_aux1_dest = this.enter_port(Pointer(b_addr, 1));\n        this.link_ports(a_aux1_dest, b_aux1_dest);\n        var a_aux2_dest = this.enter_port(Pointer(a_addr, 2));\n        var b_aux2_dest = this.enter_port(Pointer(b_addr, 2));\n        this.link_ports(a_aux2_dest, b_aux2_dest);\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // NodeDuplication, BinaryDuplication\n      } else if\n        (  a_type === NOD && b_type === NOD && a_kind !== b_kind\n        || a_type === NOD && b_type === OP2\n        || a_type === NOD && b_type === ITE) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var r_addr = this.alloc_node(a_type, a_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(r_addr, 1), Pointer(p_addr, 1));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(r_addr, 2), Pointer(q_addr, 1));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(r_addr, 0), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // UnaryDuplication\n      } else if\n        (  a_type === NOD && b_type === OP1\n        || a_type === ITE && b_type === OP1) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(p_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(q_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n      \n      // Permutations\n      } else if (a_type === OP1 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === OP2 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === ITE && b_type === NOD) {\n        return this.rewrite(b_addr);\n\n      // InvalidInteraction\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This could be performed in parallel and doesn't need GC.\n  reduce_strict(stats) {\n    var rewrites = 0;\n    var loops = 0;\n    var max_len = 0;\n    while (this.redex.length > 0) {\n      for (var i = 0, l = this.redex.length; i < l; ++i) {\n        this.rewrite(this.redex.pop());\n        stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n        ++stats.rewrites;\n      }\n      ++stats.loops;\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This avoids unecessary computations, but is sequential and would need GC.\n  reduce_lazy(stats) {\n    this.find_redex = false;\n    var warp = [];\n    var back = [];\n    var prev = Pointer(0, 1);\n    var next = this.enter_port(prev);\n    var rwts = 0;\n    while (true) {\n      ++stats.loops;\n      if (type_of(next) === PTR && (addr_of(next) === 0 || this.is_free(addr_of(next)))) {\n        if (warp.length === 0) {\n          break;\n        } else {\n          prev = warp.pop();\n          next = this.enter_port(prev);\n        }\n      } else {\n        if (slot_of(prev) === 0 && (type_of(next) === NUM || slot_of(next) === 0)) {\n          this.rewrite(addr_of(prev));\n          stats.rewrites += 1;\n          stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n          do { prev = back.pop(); } while (type_of(prev) !== PTR);\n          next = this.enter_port(prev);\n          ++rwts;\n        } else if (type_of(next) === NUM) {\n          [prev,next] = [next,prev];\n        } else if (slot_of(next) === 0) {\n          if (this.type_of(addr_of(next)) !== OP1) {\n            warp.push(Pointer(addr_of(next), 1));\n          }\n          prev = Pointer(addr_of(next), 2);\n          next = this.enter_port(prev);\n        } else {\n          back.push(prev);\n          prev = Pointer(addr_of(next), 0);\n          next = this.enter_port(prev);\n        }\n      }\n    }\n    this.find_redex = true;\n  }\n\n  // Returns a string that is preserved on reduction, good for debugging\n  denote(ptrn = this.enter_port(Pointer(0, 1)), exit = []) {\n    function path_to_string(path) {\n      var str = \"<\";\n      while (path) {\n        str += path.head === 1 ? \"a\" : \"b\";\n        path = path.tail; \n      }\n      str += \">\";\n      return str;\n    }\n    while (true) {\n      if (type_of(ptrn) === PTR) {\n        var ai = addr_of(ptrn);\n        var as = slot_of(ptrn)\n        var ak = this.kind_of(ai);\n        switch (this.type_of(ai)) {\n          case NOD:\n            if (slot_of(ptrn) === 0) {\n              if (exit[ak]) {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = new_exit[ak].tail;\n                ptrn = this.enter_port(Pointer(ai, Number(exit[ak].head)));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              } else {\n                var lft = this.denote(this.enter_port(Pointer(ai, 1)), exit);\n                var rgt = this.denote(this.enter_port(Pointer(ai, 2)), exit);\n                return \"(\" + ak + \" \" + lft + \" \" + rgt + \")\";\n              }\n            } else {\n              if (ai === 0) {\n                while (exit[exit.length - 1] === null) exit.pop();\n                return exit.map(path_to_string).join(\":\");\n              } else {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = {head: as, tail: new_exit[ak] || null};\n                ptrn = this.enter_port(Pointer(ai, 0));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              }\n            }\n            break;\n          default:\n            return \"<TODO>\";\n        }\n      } else {\n        return \"#\" + numb_of(ptrn);\n      }\n    }\n  }\n\n  to_string() {\n    const pointer = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return \"#\" + numb_of(ptrn);\n      } else {\n        return addr_of(ptrn) + \"abc\"[slot_of(ptrn)];\n      }\n    };\n    var text = '';\n    for (var i = 0; i < this.nodes.length / 4; i++) {\n      if (this.is_free(i)) {\n        text += i + \": ~\\n\";\n      } else {\n        var type = this.type_of(i);\n        var kind = this.kind_of(i);\n        text += i + ': ';\n        text += \"[\" + type + \":\" + kind + \"| \";\n        text += pointer(this.get_port(i, 0)) + \" \";\n        text += pointer(this.get_port(i, 1)) + \" \";\n        text += pointer(this.get_port(i, 2)) + \"]\";\n        text += \"...\" + this.is_numeric(i,0) + \" \" + this.is_numeric(i,1) + \" \" + this.is_numeric(i,2);\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n}\n\nmodule.exports = {Pointer, addr_of, slot_of, Numeric, numb_of, type_of, Net, NUM, PTR, NOD, OP1, OP2, ITE};\n\n\n//# sourceURL=webpack:///../Formality-JavaScript/FM-Core/node_modules/formality-net/fm-net.js?");

/***/ }),

/***/ "./node_modules/inferno-hyperscript/dist/index.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/inferno-hyperscript/dist/index.esm.js ***!
  \************************************************************/
/*! exports provided: h */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony import */ var inferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\n\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\n\nvar classIdSplit = /([.#]?[a-zA-Z0-9_:-]+)/;\nvar notClassId = /^\\.|#/;\nfunction parseTag(tag, props) {\n    if (!tag) {\n        return 'div';\n    }\n    if (tag === inferno__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"]) {\n        return tag;\n    }\n    var noId = props && isUndefined(props.id);\n    var tagParts = tag.split(classIdSplit);\n    var tagName = null;\n    if (notClassId.test(tagParts[1])) {\n        tagName = 'div';\n    }\n    var classes;\n    for (var i = 0, len = tagParts.length; i < len; ++i) {\n        var part = tagParts[i];\n        if (!part) {\n            continue;\n        }\n        var type = part.charAt(0);\n        if (!tagName) {\n            tagName = part;\n        }\n        else if (type === '.') {\n            if (classes === void 0) {\n                classes = [];\n            }\n            classes.push(part.substring(1, part.length));\n        }\n        else if (type === '#' && noId) {\n            props.id = part.substring(1, part.length);\n        }\n    }\n    if (classes) {\n        if (props.className) {\n            classes.push(props.className);\n        }\n        props.className = classes.join(' ');\n    }\n    return tagName || 'div';\n}\nfunction isChildren(x) {\n    return isStringOrNumber(x) || (x && isArray(x));\n}\n/**\n * Creates virtual node\n * @param {string|VNode|Function} _tag Name for virtual node\n * @param {object=} _props Additional properties for virtual node\n * @param {string|number|VNode|Array<string|number|VNode>|null=} _children Optional children for virtual node\n * @returns {VNode} returns new virtual node\n */\nfunction h(_tag, _props, _children) {\n    // If a child array or text node are passed as the second argument, shift them\n    if (!_children && isChildren(_props)) {\n        _children = _props;\n        _props = {};\n    }\n    var isElement = isString(_tag);\n    _props = _props || {};\n    var tag = isElement ? parseTag(_tag, _props) : _tag;\n    var newProps = {};\n    var key = null;\n    var ref = null;\n    var children = null;\n    var className = null;\n    for (var prop in _props) {\n        if (isElement && (prop === 'className' || prop === 'class')) {\n            className = _props[prop];\n        }\n        else if (prop === 'key') {\n            key = _props[prop];\n        }\n        else if (prop === 'ref') {\n            ref = _props[prop];\n        }\n        else if (prop === 'hooks') {\n            ref = _props[prop];\n        }\n        else if (prop === 'children') {\n            children = _props[prop];\n        }\n        else if (!isElement && prop.substr(0, 11) === 'onComponent') {\n            if (!ref) {\n                ref = {};\n            }\n            ref[prop] = _props[prop];\n        }\n        else {\n            newProps[prop] = _props[prop];\n        }\n    }\n    if (isElement) {\n        var flags = Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"])(tag);\n        if (flags & 8192 /* Fragment */) {\n            return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createFragment\"])(_children || children, 0 /* UnknownChildren */, key);\n        }\n        if (newProps.contenteditable !== void 0) {\n            flags |= 4096 /* ContentEditable */;\n        }\n        return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"])(flags, tag, className, _children || children, 0 /* UnknownChildren */, newProps, key, ref);\n    }\n    if (children || _children) {\n        newProps.children = children || _children;\n    }\n    return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"])(2 /* ComponentUnknown */, tag, newProps, key, ref);\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno-hyperscript/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/inferno/dist/index.esm.js ***!
  \************************************************/
/*! exports provided: Component, Fragment, EMPTY_OBJ, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, forwardRef, directClone, findDOMfromVNode, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version, _CI, _HI, _M, _MCCC, _ME, _MFCC, _MR, _MT, _MP, __render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return Fragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return EMPTY_OBJ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return createComponentVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createFragment\", function() { return createFragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return createPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return createRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return createRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return createTextVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return createVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardRef\", function() { return forwardRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return directClone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findDOMfromVNode\", function() { return findDOMfromVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return getFlagsForElementVnode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return linkEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return normalizeProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return options; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rerender\", function() { return rerender; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_CI\", function() { return createClassComponentInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_HI\", function() { return handleComponentInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_M\", function() { return mount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MCCC\", function() { return mountClassComponentCallbacks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_ME\", function() { return mountElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MFCC\", function() { return mountFunctionalComponentCallbacks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MR\", function() { return mountRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MT\", function() { return mountText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MP\", function() { return mountProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__render\", function() { return __render; });\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return isUndefined(o) || isNull(o);\n}\nfunction isInvalid(o) {\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isTrue(o) {\n    return o === true;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction isObject(o) {\n    return typeof o === 'object';\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n    parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n    if (isNull(nextNode)) {\n        appendChild(parentDOM, newNode);\n    }\n    else {\n        parentDOM.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n    parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n    parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n    var listener;\n    while ((listener = arrayFn.shift()) !== undefined) {\n        listener();\n    }\n}\nfunction findDOMfromVNode(vNode, start) {\n    var flags;\n    var children;\n    while (vNode) {\n        flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            return vNode.dom;\n        }\n        children = vNode.children;\n        if (flags & 8192 /* Fragment */) {\n            vNode = vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[start ? 0 : children.length - 1];\n        }\n        else if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        else {\n            vNode = children;\n        }\n    }\n    return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n    var flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n        removeChild(parentDOM, vNode.dom);\n    }\n    else {\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            removeVNodeDOM(children.$LI, parentDOM);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            removeVNodeDOM(children, parentDOM);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                removeVNodeDOM(children, parentDOM);\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    removeVNodeDOM(children[i], parentDOM);\n                }\n            }\n        }\n    }\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n    var flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n        insertOrAppend(parentDOM, vNode.dom, nextNode);\n    }\n    else {\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            moveVNodeDOM(children.$LI, parentDOM, nextNode);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            moveVNodeDOM(children, parentDOM, nextNode);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                moveVNodeDOM(children, parentDOM, nextNode);\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    moveVNodeDOM(children[i], parentDOM, nextNode);\n                }\n            }\n        }\n    }\n}\nfunction createDerivedState(instance, nextProps, state) {\n    if (instance.constructor.getDerivedStateFromProps) {\n        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n    }\n    return state;\n}\nvar renderCheck = {\n    v: false\n};\nvar options = {\n    componentComparator: null,\n    createVNode: null,\n    renderComplete: null\n};\nfunction setTextContent(dom, children) {\n    dom.textContent = children;\n}\nfunction isSameLinkEvent(lastValue, nextValue) {\n    return (lastValue &&\n        nextValue &&\n        isObject(lastValue) &&\n        isObject(nextValue) &&\n        lastValue.event === nextValue.event &&\n        lastValue.data === nextValue.data);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n    this.childFlags = childFlags;\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key === void 0 ? null : key;\n    this.props = props === void 0 ? null : props;\n    this.ref = ref === void 0 ? null : ref;\n    this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n    var optsVNode = options.createVNode;\n    if (isFunction(optsVNode)) {\n        optsVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    if ((flags & 2 /* ComponentUnknown */) !== 0) {\n        if (type.prototype && type.prototype.render) {\n            flags = 4 /* ComponentClass */;\n        }\n        else if (type.render) {\n            flags = 32776 /* ForwardRefComponent */;\n            type = type.render;\n        }\n        else {\n            flags = 8 /* ComponentFunction */;\n        }\n    }\n    // set default props\n    var defaultProps = type.defaultProps;\n    if (!isNullOrUndef(defaultProps)) {\n        if (!props) {\n            props = {}; // Props can be referenced and modified at application level so always create new object\n        }\n        for (var prop in defaultProps) {\n            if (isUndefined(props[prop])) {\n                props[prop] = defaultProps[prop];\n            }\n        }\n    }\n    if ((flags & 8 /* ComponentFunction */) > 0 && (flags & 32768 /* ForwardRef */) === 0) {\n        var defaultHooks = type.defaultHooks;\n        if (!isNullOrUndef(defaultHooks)) {\n            if (!ref) {\n                // As ref cannot be referenced from application level, we can use the same refs object\n                ref = defaultHooks;\n            }\n            else {\n                for (var prop$1 in defaultHooks) {\n                    if (isUndefined(ref[prop$1])) {\n                        ref[prop$1] = defaultHooks[prop$1];\n                    }\n                }\n            }\n        }\n    }\n    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, props, ref, type);\n    var optsVNode = options.createVNode;\n    if (isFunction(optsVNode)) {\n        optsVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n    switch (fragment.childFlags) {\n        case 1 /* HasInvalidChildren */:\n            fragment.children = createVoidVNode();\n            fragment.childFlags = 2 /* HasVNodeChildren */;\n            break;\n        case 16 /* HasTextChildren */:\n            fragment.children = [createTextVNode(children)];\n            fragment.childFlags = 4 /* HasNonKeyedChildren */;\n            break;\n        default:\n            break;\n    }\n    return fragment;\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                vNode.className = props.className || null;\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n    var clonedChildren;\n    var oldChildren = vNodeToClone.children;\n    var childFlags = vNodeToClone.childFlags;\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        clonedChildren = directClone(oldChildren);\n    }\n    else if (childFlags & 12 /* MultipleChildren */) {\n        clonedChildren = [];\n        for (var i = 0, len = oldChildren.length; i < len; ++i) {\n            clonedChildren.push(directClone(oldChildren[i]));\n        }\n    }\n    return createFragment(clonedChildren, childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n    var props = vNodeToClone.props;\n    if (flags & 14 /* Component */) {\n        if (!isNull(props)) {\n            var propsToClone = props;\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n    }\n    if ((flags & 8192 /* Fragment */) === 0) {\n        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n    }\n    return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, children, 0 /* UnknownChildren */, null, isInvalid(children) ? null : children.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    n.flags |= 65536 /* Normalized */;\n                    if (!isPrefixedKey) {\n                        if (isNull(oldKey)) {\n                            n.key = newKey;\n                        }\n                        else {\n                            n.key = currentKey + oldKey;\n                        }\n                    }\n                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    switch (type) {\n        case 'svg':\n            return 32 /* SvgElement */;\n        case 'input':\n            return 64 /* InputElement */;\n        case 'select':\n            return 256 /* SelectElement */;\n        case 'textarea':\n            return 128 /* TextareaElement */;\n        case Fragment:\n            return 8192 /* Fragment */;\n        default:\n            return 1 /* HtmlElement */;\n    }\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isStringOrNumber(children)) {\n        newChildFlags = 16 /* HasTextChildren */;\n        newChildren = children;\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        for (var i = 0; i < len; ++i) {\n            var n = children[i];\n            if (isInvalid(n) || isArray(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                _normalizeVNodes(children, newChildren, i, '');\n                break;\n            }\n            else if (isStringOrNumber(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                newChildren.push(createTextVNode(n, keyPrefix + i));\n            }\n            else {\n                var key = n.key;\n                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n                var isNullKey = isNull(key);\n                var isPrefixed = isString(key) && key[0] === keyPrefix;\n                if (needsCloning || isNullKey || isPrefixed) {\n                    newChildren = newChildren || children.slice(0, i);\n                    if (needsCloning || isPrefixed) {\n                        n = directClone(n);\n                    }\n                    if (isNullKey || isPrefixed) {\n                        n.key = keyPrefix + i;\n                    }\n                    newChildren.push(n);\n                }\n                else if (newChildren) {\n                    newChildren.push(n);\n                }\n                n.flags |= 65536 /* Normalized */;\n            }\n        }\n        newChildren = newChildren || children;\n        if (newChildren.length === 0) {\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            newChildFlags = 8 /* HasKeyedChildren */;\n        }\n    }\n    else {\n        newChildren = children;\n        newChildren.flags |= 65536 /* Normalized */;\n        if (children.flags & 81920 /* InUseOrNormalized */) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n    return {\n        onClick: v,\n        onDblClick: v,\n        onFocusIn: v,\n        onFocusOut: v,\n        onKeyDown: v,\n        onKeyPress: v,\n        onKeyUp: v,\n        onMouseDown: v,\n        onMouseMove: v,\n        onMouseUp: v,\n        onSubmit: v,\n        onTouchEnd: v,\n        onTouchMove: v,\n        onTouchStart: v\n    };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar delegatedEvents = getDelegatedEventObject(true);\nfunction handleEvent(name, nextEvent, dom) {\n    var eventsObject = dom.$EV;\n    if (nextEvent) {\n        if (attachedEventCounts[name] === 0) {\n            attachedEvents[name] = attachEventToDocument(name);\n        }\n        if (!eventsObject) {\n            eventsObject = dom.$EV = getDelegatedEventObject(null);\n        }\n        if (!eventsObject[name]) {\n            ++attachedEventCounts[name];\n        }\n        eventsObject[name] = nextEvent;\n    }\n    else if (eventsObject && eventsObject[name]) {\n        if (--attachedEventCounts[name] === 0) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = null;\n    }\n}\nfunction dispatchEvents(event, target, isClick, name, eventData) {\n    var dom = target;\n    while (!isNull(dom)) {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                if (currentEvent.event) {\n                    currentEvent.event(currentEvent.data, event);\n                }\n                else {\n                    currentEvent(event);\n                }\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    }\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction isDefaultPrevented() {\n    return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n    return this.cancelBubble;\n}\nfunction attachEventToDocument(name) {\n    var docEvent = function (event) {\n        var isClick = name === 'onClick' || name === 'onDblClick';\n        if (isClick && event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 12 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return;\n        }\n        event.isDefaultPrevented = isDefaultPrevented;\n        event.isPropagationStopped = isPropagationStopped;\n        event.stopPropagation = stopPropagation;\n        // Event data needs to be object to save reference to currentTarget getter\n        var eventData = {\n            dom: document\n        };\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            get: function get() {\n                return eventData.dom;\n            }\n        });\n        dispatchEvents(event, event.target, isClick, name, eventData);\n    };\n    document.addEventListener(normalizeEventName(name), docEvent);\n    return docEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; ++i) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction attachEvent(dom, event, handler) {\n    var previousKey = \"$\" + event;\n    var previousArgs = dom[previousKey];\n    if (previousArgs && previousArgs[1].wrapped) {\n        return;\n    }\n    if (previousArgs) {\n        dom.removeEventListener.apply(dom, previousArgs);\n        dom[previousKey] = null;\n    }\n    if (isFunction(handler)) {\n        dom.addEventListener(event, handler);\n        dom[previousKey] = [event, handler];\n    }\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        attachEvent(dom, 'change', wrappedOnChange);\n        attachEvent(dom, 'click', emptywrapper);\n    }\n    else {\n        attachEvent(dom, 'input', onTextInputChange);\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptions(vNode, value) {\n    if (vNode.type === 'option') {\n        updateChildOption(vNode, value);\n    }\n    else {\n        var children = vNode.children;\n        var flags = vNode.flags;\n        if (flags & 4 /* ComponentClass */) {\n            updateChildOptions(children.$LI, value);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; ++i) {\n                updateChildOptions(children[i], value);\n            }\n        }\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var index = nextPropsOrEmpty.selectedIndex;\n    if (index === -1) {\n        dom.selectedIndex = -1;\n    }\n    var childFlags = vNode.childFlags;\n    if (childFlags !== 1 /* HasInvalidChildren */) {\n        var value = nextPropsOrEmpty.value;\n        if (isNumber(index) && index > -1 && dom.options[index]) {\n            value = dom.options[index].value;\n        }\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        updateChildOptions(vNode, value);\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    attachEvent(dom, 'input', onTextareaInputChange);\n    if (nextPropsOrEmpty.onChange) {\n        attachEvent(dom, 'change', wrappedOnChange$1);\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\n/**\n * There is currently no support for switching same input between controlled and nonControlled\n * If that ever becomes a real issue, then re design controlled elements\n * Currently user must choose either controlled or non-controlled and stick with that\n */\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n    return {\n        current: null\n    };\n}\nvar forwardRef = function (render) {\n        return {\n            render: render\n        };\n    };\nfunction pushRef(dom, value, lifecycle) {\n    lifecycle.push(function () {\n        value(dom);\n    });\n}\nfunction unmountRef(ref) {\n    if (ref) {\n        if (isFunction(ref)) {\n            ref(null);\n        }\n        else if (ref.current) {\n            ref.current = null;\n        }\n    }\n}\nfunction mountRef(ref, value, lifecycle) {\n    if (ref) {\n        if (isFunction(ref)) {\n            pushRef(value, ref, lifecycle);\n        }\n        else if (ref.current !== void 0) {\n            ref.current = value;\n        }\n    }\n}\n\nfunction remove(vNode, parentDOM) {\n    unmount(vNode);\n    if (parentDOM) {\n        removeVNodeDOM(vNode, parentDOM);\n    }\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var ref;\n    if (flags & 481 /* Element */) {\n        ref = vNode.ref;\n        var props = vNode.props;\n        unmountRef(ref);\n        var childFlags = vNode.childFlags;\n        if (!isNull(props)) {\n            var keys = Object.keys(props);\n            for (var i = 0, len = keys.length; i < len; i++) {\n                var key = keys[i];\n                if (delegatedEvents[key]) {\n                    handleEvent(key, null, vNode.dom);\n                }\n            }\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n    }\n    else if (children) {\n        if (flags & 4 /* ComponentClass */) {\n            if (isFunction(children.componentWillUnmount)) {\n                children.componentWillUnmount();\n            }\n            unmountRef(vNode.ref);\n            children.$UN = true;\n            unmount(children.$LI);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            ref = vNode.ref;\n            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n            }\n            unmount(children);\n        }\n        else if (flags & 1024 /* Portal */) {\n            remove(children, vNode.ref);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags & 12 /* MultipleChildren */) {\n                unmountAllChildren(children);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        unmount(children[i]);\n    }\n}\nfunction clearDOM(dom) {\n    // Optimization for clearing dom\n    dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n    unmountAllChildren(children);\n    if (vNode.flags & 8192 /* Fragment */) {\n        removeVNodeDOM(vNode, dom);\n    }\n    else {\n        clearDOM(dom);\n    }\n}\n\nfunction createLinkEvent(linkEvent, nextValue) {\n    return function (e) {\n        linkEvent(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    var event = normalizeEventName(name);\n    if (isObject(nextValue) && !isNull(nextValue)) {\n        var linkEvent = nextValue.event;\n        if (!isSameLinkEvent(lastValue, nextValue)) {\n            attachEvent(dom, event, createLinkEvent(linkEvent, nextValue));\n        }\n    }\n    else {\n        attachEvent(dom, event, nextValue);\n    }\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isNullOrUndef(nextAttrValue)) {\n        dom.removeAttribute('style');\n        return;\n    }\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle.setProperty(style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle.removeProperty(style);\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle.setProperty(style, value);\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                break;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'style':\n            patchStyle(lastValue, nextValue, dom);\n            break;\n        case 'dangerouslySetInnerHTML':\n            var lastHtml = (lastValue && lastValue.__html) || '';\n            var nextHtml = (nextValue && nextValue.__html) || '';\n            if (lastHtml !== nextHtml) {\n                if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n                    if (!isNull(lastVNode)) {\n                        if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                            unmountAllChildren(lastVNode.children);\n                        }\n                        else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                            unmount(lastVNode.children);\n                        }\n                        lastVNode.children = null;\n                        lastVNode.childFlags = 1 /* HasInvalidChildren */;\n                    }\n                    dom.innerHTML = nextHtml;\n                }\n            }\n            break;\n        default:\n            if (delegatedEvents[prop]) {\n                if (!isSameLinkEvent(lastValue, nextValue)) {\n                    handleEvent(prop, nextValue, dom);\n                }\n            }\n            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n                patchEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction renderNewInput(instance, props, context) {\n    var nextInput = handleComponentInput(instance.render(props, instance.state, context));\n    var childContext = context;\n    if (isFunction(instance.getChildContext)) {\n        childContext = combineFrom(context, instance.getChildContext());\n    }\n    instance.$CX = childContext;\n    return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    var instance = new Component(props, context);\n    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));\n    instance.$SVG = isSVG;\n    instance.$L = lifecycle;\n    vNode.children = instance;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    if (!usesNewAPI) {\n        if (isFunction(instance.componentWillMount)) {\n            instance.$BR = true;\n            instance.componentWillMount();\n            var pending = instance.$PS;\n            if (!isNull(pending)) {\n                var state = instance.state;\n                if (isNull(state)) {\n                    instance.state = pending;\n                }\n                else {\n                    for (var key in pending) {\n                        state[key] = pending[key];\n                    }\n                }\n                instance.$PS = null;\n            }\n            instance.$BR = false;\n        }\n    }\n    else {\n        instance.state = createDerivedState(instance, props, instance.state);\n    }\n    instance.$LI = renderNewInput(instance, props, context);\n    return instance;\n}\nfunction handleComponentInput(input) {\n    if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input, null);\n    }\n    else if (isArray(input)) {\n        input = createFragment(input, 0 /* UnknownChildren */, null);\n    }\n    else if (input.flags & 16384 /* InUse */) {\n        input = directClone(input);\n    }\n    return input;\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = (vNode.flags |= 16384 /* InUse */);\n    if (flags & 481 /* Element */) {\n        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 4 /* ComponentClass */) {\n        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 8 /* ComponentFunction */) {\n        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        mountText(vNode, parentDOM, nextNode);\n    }\n    else if (flags & 8192 /* Fragment */) {\n        mountFragment(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 1024 /* Portal */) {\n        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n    }\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n    mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n    var placeHolderVNode = createVoidVNode();\n    mountText(placeHolderVNode, parentDOM, nextNode);\n    vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n        children = vNode.children = createVoidVNode();\n    }\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        mount(children, parentDOM, nextNode, isSVG, nextNode, lifecycle);\n    }\n    else {\n        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = vNode.flags;\n    var props = vNode.props;\n    var className = vNode.className;\n    var ref = vNode.ref;\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;\n    var dom = documentCreateElement(vNode.type, isSVG);\n    vNode.dom = dom;\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (childFlags === 16 /* HasTextChildren */) {\n        setTextContent(dom, children);\n    }\n    else if (childFlags !== 1 /* HasInvalidChildren */) {\n        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            if (children.flags & 16384 /* InUse */) {\n                vNode.children = children = directClone(children);\n            }\n            mount(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n    }\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    mountRef(ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        var child = children[i];\n        if (child.flags & 16384 /* InUse */) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var ref = vNode.ref;\n    var input = handleComponentInput(vNode.flags & 32768 /* ForwardRef */ ? type(props, ref, context) : type(props, context));\n    vNode.children = input;\n    mount(input, parentDOM, context, isSVG, nextNode, lifecycle);\n    mountFunctionalComponentCallbacks(props, ref, vNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.componentDidMount();\n    };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n    mountRef(ref, instance, lifecycle);\n    if (isFunction(instance.componentDidMount)) {\n        lifecycle.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, vNode, props) {\n    return function () {\n        ref.onComponentDidMount(findDOMfromVNode(vNode, true), props);\n    };\n}\nfunction mountFunctionalComponentCallbacks(props, ref, vNode, lifecycle) {\n    if (!isNullOrUndef(ref)) {\n        if (isFunction(ref.onComponentWillMount)) {\n            ref.onComponentWillMount(props);\n        }\n        if (isFunction(ref.onComponentDidMount)) {\n            lifecycle.push(createOnMountCallback(ref, vNode, props));\n        }\n    }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastVNode);\n    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n        // Single DOM operation, when we have dom references available\n        mount(nextVNode, null, context, isSVG, null, lifecycle);\n        // Single DOM operation, when we have dom references available\n        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n    }\n    else {\n        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n        removeVNodeDOM(lastVNode, parentDOM);\n    }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);\n    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || (nextFlags & 2048 /* ReCreate */) !== 0) {\n        if (lastVNode.flags & 16384 /* InUse */) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n        }\n        else {\n            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n    }\n    else if (nextFlags & 4 /* ComponentClass */) {\n        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 8 /* ComponentFunction */) {\n        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else if (nextFlags & 8192 /* Fragment */) {\n        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context, lifecycle);\n    }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n    if (lastChildren !== nextChildren) {\n        if (lastChildren !== '') {\n            parentDOM.firstChild.nodeValue = nextChildren;\n        }\n        else {\n            setTextContent(parentDOM, nextChildren);\n        }\n    }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n    if (dom.textContent !== nextChildren) {\n        dom.textContent = nextChildren;\n    }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    var lastChildren = lastVNode.children;\n    var nextChildren = nextVNode.children;\n    var lastChildFlags = lastVNode.childFlags;\n    var nextChildFlags = nextVNode.childFlags;\n    var nextNode = null;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n        nextChildren = nextVNode.children = createVoidVNode();\n    }\n    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n    if (lastChildFlags & 12 /* MultipleChildren */) {\n        var lastLen = lastChildren.length;\n        // We need to know Fragment's edge node when\n        if (\n        // It uses keyed algorithm\n        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||\n            // It transforms from many to single\n            nextIsSingle ||\n            // It will append more nodes\n            (!nextIsSingle && nextChildren.length > lastLen)) {\n            // When fragment has multiple children there is always at least one vNode\n            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n        }\n    }\n    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n    var lastContainer = lastVNode.ref;\n    var nextContainer = nextVNode.ref;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        removeChild(lastContainer, node);\n        appendChild(nextContainer, node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n    var dom = lastVNode.dom;\n    var lastProps = lastVNode.props;\n    var nextProps = nextVNode.props;\n    var isFormElement = false;\n    var hasControlledValue = false;\n    var nextPropsOrEmpty;\n    nextVNode.dom = dom;\n    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n    // inlined patchProps  -- starts --\n    if (lastProps !== nextProps) {\n        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n        nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n        if (nextPropsOrEmpty !== EMPTY_OBJ) {\n            isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n            if (isFormElement) {\n                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n            }\n            for (var prop in nextPropsOrEmpty) {\n                var lastValue = lastPropsOrEmpty[prop];\n                var nextValue = nextPropsOrEmpty[prop];\n                if (lastValue !== nextValue) {\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n        if (lastPropsOrEmpty !== EMPTY_OBJ) {\n            for (var prop$1 in lastPropsOrEmpty) {\n                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n    }\n    var nextChildren = nextVNode.children;\n    var nextClassName = nextVNode.className;\n    // inlined patchProps  -- ends --\n    if (lastVNode.className !== nextClassName) {\n        if (isNullOrUndef(nextClassName)) {\n            dom.removeAttribute('class');\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', nextClassName);\n        }\n        else {\n            dom.className = nextClassName;\n        }\n    }\n    if (nextFlags & 4096 /* ContentEditable */) {\n        patchContentEditableChildren(dom, nextChildren);\n    }\n    else {\n        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n    }\n    if (isFormElement) {\n        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n    }\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, dom, lifecycle);\n    }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastChildren);\n    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n    removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                case 16 /* HasTextChildren */:\n                    unmount(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                case 16 /* HasTextChildren */:\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        case 16 /* HasTextChildren */:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    clearDOM(parentDOM);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    clearDOM(parentDOM);\n                    break;\n                default:\n                    clearDOM(parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        default:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    unmountAllChildren(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    break;\n                default:\n                    var lastLength = lastChildren.length | 0;\n                    var nextLength = nextChildren.length | 0;\n                    // Fast path's for both algorithms\n                    if (lastLength === 0) {\n                        if (nextLength > 0) {\n                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                        }\n                    }\n                    else if (nextLength === 0) {\n                        removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    }\n                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n                    }\n                    else {\n                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n                    }\n                    break;\n            }\n            break;\n    }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n    lifecycle.push(function () {\n        instance.componentDidUpdate(lastProps, lastState, snapshot);\n    });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    var usesNewAPI = Boolean(instance.$N);\n    var hasSCU = isFunction(instance.shouldComponentUpdate);\n    if (usesNewAPI) {\n        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n    }\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n            instance.componentWillUpdate(nextProps, nextState, context);\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        var snapshot = null;\n        var nextInput = renderNewInput(instance, nextProps, context);\n        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n        }\n        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n        // Dont update Last input, until patch has been succesfully executed\n        instance.$LI = nextInput;\n        if (isFunction(instance.componentDidUpdate)) {\n            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = (nextVNode.children = lastVNode.children);\n    // If Component has crashed, ignore it to stay functional\n    if (isNull(instance)) {\n        return;\n    }\n    instance.$L = lifecycle;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    var nextState = instance.state;\n    if (!instance.$N) {\n        if (isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (!isNull(instance.$PS)) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PS = null;\n        }\n    }\n    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, instance, lifecycle);\n    }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var shouldUpdate = true;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastProps = lastVNode.props;\n    var nextHooksDefined = !isNullOrUndef(nextRef);\n    var lastInput = lastVNode.children;\n    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n    }\n    if (shouldUpdate !== false) {\n        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n            nextRef.onComponentWillUpdate(lastProps, nextProps);\n        }\n        var type = nextVNode.type;\n        var nextInput = handleComponentInput(nextVNode.flags & 32768 /* ForwardRef */ ? type(nextProps, nextRef, context) : type(nextProps, context));\n        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n        nextVNode.children = nextInput;\n        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n            nextRef.onComponentDidUpdate(lastProps, nextProps);\n        }\n    }\n    else {\n        nextVNode.children = lastInput;\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = lastVNode.dom;\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n    nextVNode.dom = dom;\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; ++i) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.flags & 16384 /* InUse */) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; ++i) {\n            nextChild = nextChildren[i];\n            if (nextChild.flags & 16384 /* InUse */) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; ++i) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var i = 0;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    var nextNode;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[j] = bNode;\n            ++j;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                ++j;\n                mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        var aStart = j;\n        var bStart = j;\n        var aLeft = aEnd - j + 1;\n        var bLeft = bEnd - j + 1;\n        var sources = new Int32Array(bLeft - i + 1);\n        i = bLeft + 2;\n        // Keep track if its possible to remove whole DOM using textContent = '';\n        var canRemoveWholeContent = aLeft === aLength;\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        // When sizes are small, just loop them through\n        if (bLength < 4 || (aLeft | bLeft) < 32) {\n            for (i = aStart; i <= aEnd; ++i) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i + 1;\n                            if (canRemoveWholeContent) {\n                                canRemoveWholeContent = false;\n                                while (aStart < i) {\n                                    remove(a[aStart++], dom);\n                                }\n                            }\n                            if (pos > j) {\n                                moved = true;\n                            }\n                            else {\n                                pos = j;\n                            }\n                            if (bNode.flags & 16384 /* InUse */) {\n                                b[j] = bNode = directClone(bNode);\n                            }\n                            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                            ++patched;\n                            break;\n                        }\n                    }\n                    if (!canRemoveWholeContent && j > bEnd) {\n                        remove(aNode, dom);\n                    }\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n        }\n        else {\n            var keyIndex = {};\n            // Map keys by their index\n            for (i = bStart; i <= bEnd; ++i) {\n                keyIndex[b[i].key] = i;\n            }\n            // Try to patch same keys\n            for (i = aStart; i <= aEnd; ++i) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    j = keyIndex[aNode.key];\n                    if (j !== void 0) {\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (i > aStart) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        bNode = b[j];\n                        sources[j - bStart] = i + 1;\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.flags & 16384 /* InUse */) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                        ++patched;\n                    }\n                    else if (!canRemoveWholeContent) {\n                        remove(aNode, dom);\n                    }\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n        }\n        // fast-path: if nothing patched remove all old and add all new\n        if (canRemoveWholeContent) {\n            removeAllChildren(dom, parentVNode, a);\n            mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n        }\n        else if (moved) {\n            var seq = lis_algorithm(sources);\n            j = seq.length - 1;\n            for (i = bLeft - 1; i >= 0; i--) {\n                if (sources[i] === 0) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[pos] = bNode = directClone(bNode);\n                    }\n                    nextPos = pos + 1;\n                    mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n                }\n                else if (j < 0 || i !== seq[j]) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    nextPos = pos + 1;\n                    moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n                }\n                else {\n                    j--;\n                }\n            }\n        }\n        else if (patched !== bLeft) {\n            // when patched count doesn't match b length we need to insert those new ones\n            // loop backwards so we can use insertBefore\n            for (i = bLeft - 1; i >= 0; i--) {\n                if (sources[i] === 0) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[pos] = bNode = directClone(bNode);\n                    }\n                    nextPos = pos + 1;\n                    mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n                }\n            }\n        }\n    }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var arrI = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var u = 0;\n    var v = 0;\n    var c = 0;\n    var len = arr.length;\n    if (len > maxLen) {\n        maxLen = len;\n        result = new Int32Array(len);\n        p = new Int32Array(len);\n    }\n    for (; i < len; ++i) {\n        arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[k];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result[++k] = i;\n                continue;\n            }\n            u = 0;\n            v = k;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = i = k + 1;\n    var seq = new Int32Array(u);\n    v = result[u - 1];\n    while (u-- > 0) {\n        seq[u] = v;\n        v = p[v];\n    }\n    while (i-- > 0) {\n        result[i] = 0;\n    }\n    return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nvar documentBody = null;\nif (hasDocumentAvailable) {\n    documentBody = document.body;\n    /*\n     * Defining $EV and $V properties on Node.prototype\n     * fixes v8 \"wrong map\" de-optimization\n     */\n    Node.prototype.$EV = null;\n    Node.prototype.$V = null;\n}\nfunction __render(input, parentDOM, callback, context) {\n    var lifecycle = [];\n    var rootInput = parentDOM.$V;\n    renderCheck.v = true;\n    if (isNullOrUndef(rootInput)) {\n        if (!isNullOrUndef(input)) {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            mount(input, parentDOM, context, false, null, lifecycle);\n            parentDOM.$V = input;\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDOM);\n            parentDOM.$V = null;\n        }\n        else {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n            rootInput = parentDOM.$V = input;\n        }\n    }\n    if (lifecycle.length > 0) {\n        callAll(lifecycle);\n    }\n    renderCheck.v = false;\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput, parentDOM);\n    }\n}\nfunction render(input, parentDOM, callback, context) {\n    if ( callback === void 0 ) callback = null;\n    if ( context === void 0 ) context = EMPTY_OBJ;\n\n    __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n    return function renderer(lastInput, nextInput, callback, context) {\n        if (!parentDOM) {\n            parentDOM = lastInput;\n        }\n        render(nextInput, parentDOM, callback, context);\n    };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout.bind(window);\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n    var pending = component.$PS;\n    if (isFunction(newState)) {\n        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n    }\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$BR) {\n        if (!renderCheck.v) {\n            if (QUEUE.length === 0) {\n                applyState(component, force, callback);\n                return;\n            }\n        }\n        if (QUEUE.indexOf(component) === -1) {\n            QUEUE.push(component);\n        }\n        if (!microTaskPending) {\n            microTaskPending = true;\n            nextTick(rerender);\n        }\n        if (isFunction(callback)) {\n            var QU = component.$QU;\n            if (!QU) {\n                QU = component.$QU = [];\n            }\n            QU.push(callback);\n        }\n    }\n    else if (isFunction(callback)) {\n        component.$L.push(callback.bind(component));\n    }\n}\nfunction callSetStateCallbacks(component) {\n    var queue = component.$QU;\n    for (var i = 0, len = queue.length; i < len; ++i) {\n        queue[i].call(component);\n    }\n    component.$QU = null;\n}\nfunction rerender() {\n    var component;\n    microTaskPending = false;\n    while ((component = QUEUE.pop())) {\n        var queue = component.$QU;\n        applyState(component, false, queue ? callSetStateCallbacks.bind(null, component) : null);\n    }\n}\nfunction applyState(component, force, callback) {\n    if (component.$UN) {\n        return;\n    }\n    if (force || !component.$BR) {\n        var pendingState = component.$PS;\n        component.$PS = null;\n        var lifecycle = [];\n        renderCheck.v = true;\n        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n        if (lifecycle.length > 0) {\n            callAll(lifecycle);\n        }\n        renderCheck.v = false;\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n    if (isFunction(callback)) {\n        callback.call(component);\n    }\n}\nvar Component = function Component(props, context) {\n    // Public\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$QU = null; // QUEUE\n    this.$N = false; // Uses new lifecycle API Flag\n    this.$L = null; // Current lifecycle of this component\n    this.$SVG = false; // Flag to keep track if component is inside SVG tree\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n    else {\n        return;\n    }\n};\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) {\n    return null;\n};\n\nvar version = \"7.1.10\";\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/index.esm.js":
/*!*******************************************!*\
  !*** ./node_modules/inferno/index.esm.js ***!
  \*******************************************/
/*! exports provided: Component, Fragment, EMPTY_OBJ, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, forwardRef, directClone, findDOMfromVNode, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version, _CI, _HI, _M, _MCCC, _ME, _MFCC, _MR, _MT, _MP, __render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.esm.js */ \"./node_modules/inferno/dist/index.esm.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"EMPTY_OBJ\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createFragment\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createFragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createPortal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createRenderer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createTextVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"forwardRef\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"forwardRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"directClone\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"findDOMfromVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"findDOMfromVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"linkEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"normalizeProps\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"options\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rerender\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"rerender\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"version\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_CI\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_CI\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_HI\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_HI\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_M\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_M\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MCCC\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MCCC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_ME\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_ME\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MFCC\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MFCC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MR\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MR\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MT\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MT\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MP\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MP\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__render\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"__render\"]; });\n\n\n\nif (true) {\n  console.warn('You are running production build of Inferno in development mode. Use dev:module entry point.');\n}\n\n\n//# sourceURL=webpack:///./node_modules/inferno/index.esm.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Component, render} = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\nconst h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\nconst fm = __webpack_require__(/*! ./../../Formality-JavaScript/FM-Core */ \"../Formality-JavaScript/FM-Core/exports.js\");\n\nconst code = `\n// ::::::::::\n// :: Bool ::\n// ::::::::::\n\n// Bool datatype. Desugars to:\n// def Bool       : Type = $ self {~P : {b : Bool} -> Type, T : (P Bool.true), F : (P Bool.false)} -> (P self)\n// def Bool.true  : Bool = @ Bool {~P, T, F} => T\n// def Bool.false : Bool = @ Bool {~P, T, F} => F\nT Bool\n| true\n| false \n\n// Simple not\nBool.not : {|b : Bool} -> Bool\n| true  = Bool.false\n| false = Bool.true\n\n// ::::::::::\n// :: List ::\n// ::::::::::\n\nT List <A : Type>\n| push  {head : A, tail : List(A)}\n| empty\n\n// The dependent pattern match syntax is still not able to deal with indices,\n// so we must use the case syntax\nhead : {~T : Type, default : T, list : List(T)} -> T\n  case<List> list\n  | push  => head\n  | empty => default\n  : T\n\ntail : {~T : Type, list : List(T)} -> List(T)\n  case<List> list\n  | push  => tail\n  | empty => List.empty(~T)\n  : List(T)\n`;\n\nconst tokens = fm.lang.parse(code, true).tokens;\n\nconst elems = [];\nfor (var i = 0; i < tokens.length; ++i) {\n  var attrs = (function(){\n    switch (tokens[i][0]) {\n      case \"txt\" : return {style: {color: \"black\"}};\n      case \"sym\" : return {style: {color: \"blue\"}};\n      case \"cmm\" : return {style: {color: \"gray\"}};\n      case \"num\" : return {style: {color: \"green\"}};\n      case \"var\" : return {style: {color: \"orange\"}};\n      case \"ref\" : return {style: {color: \"purple\", \"text-decoration\": \"underline\", cursor: \"pointer\"}};\n      case \"def\" : return {style: {color: \"red\", \"font-weight\": \"bold\", cursor: \"pointer\"}}; \n      default    : return {};\n    }\n  })();\n  elems.push(h(\"span\", attrs, tokens[i][1]));\n}\n\nclass Main extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {clicks: 0};\n  }\n  componentDidMount() {\n  }\n  render() {\n    return h(\"div\", {style: {\"font-family\": \"Gotham Book\"}}, [\n      h(\"div\", {style: {\n        \"background\": \"rgb(87,89,107)\",\n        \"margin-bottom\": \"24px\",\n        \"display\": \"flex\",\n        \"flex-flow\": \"row nowrap\",\n        \"align-items\": \"center\",\n        \"box-shadow\": \"inset 0px -32px 32px -32px rgba(0,0,0,0.5)\",\n        \"height\": \"64px\"\n        }}, [\n          h(\"img\", {style: {\"width\": \"42px\"}, src: \"fm-logo.png\"})\n        ]),\n      h(\"div\", {style: {\n        \"display\": \"flex\",\n        \"flex-flow\": \"column nowrap\",\n        \"align-items\": \"center\",\n        }}, [\n          h(\"code\", \n            {style: {\n              \"background\": \"white\",\n              \"width\": \"800px\",\n              \"overflow\": \"scroll\",\n              \"padding\": \"8px\",\n              \"border-radius\": \"6px\",\n              \"box-shadow\": \"0px 0px 6px 0px rgba(0,0,0,0.5)\"\n            }},\n            h(\"pre\", {}, elems))\n        ])\n        //\"Hello, world! Clicks! \" + this.state.clicks)\n    ]);\n  }\n}\n\nwindow.onload = () => {\n  render(h(Main), document.getElementById(\"main\"));\n};\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });